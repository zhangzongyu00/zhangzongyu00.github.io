<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爆发🍢小宇宙</title>
  
  <subtitle>所有的身不由己，都是因为不够强大</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangzongyu00.github.io/"/>
  <updated>2020-07-19T08:33:41.661Z</updated>
  <id>http://zhangzongyu00.github.io/</id>
  
  <author>
    <name>章肿鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://zhangzongyu00.github.io/2020/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://zhangzongyu00.github.io/2020/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-18T16:14:02.000Z</published>
    <updated>2020-07-19T08:33:41.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络七层协议-OSI七层模型"><a href="#网络七层协议-OSI七层模型" class="headerlink" title="网络七层协议/OSI七层模型"></a>网络七层协议/OSI七层模型</h1><ul><li>应用层<ul><li>用户接口、应用程序，<strong>网络进程</strong>访问应用层；</li><li>Application典型设备：网关；</li><li>典型协议、标准、应用：TELNET、FTP、HTTP、DNS；</li></ul></li><li>表示层<ul><li>数据表示、压缩、加密presentation，应用层数据的<strong>格式转化</strong>；</li><li>典型设备：网关；</li><li>典型协议、标准、应用：ASCLL、PICT、TIFF、JPEG｜MPEG；</li><li>表示层相当于一个东西的表示，表示的一些协议，如图片、声音、视频MPEG；</li></ul></li><li>会话层<ul><li>会话的建立和结束，<strong>应用程序间</strong>的会话；</li><li>典型设备：网关；</li><li>典型协议、标准、应用：RPC、SQL、NFS、X WINDOWS、ASP；</li></ul></li><li>传输层<ul><li>主要功能：端到端控制Transport，<code>网段</code>传输；</li><li>典型设备：网关；</li><li>典型协议、标准、应用：<strong>TCP</strong>、<strong>UDP</strong>、SPX；</li><li>错误检测和<strong>恢复</strong>：海明码；</li></ul></li><li>网络层<code>host-to-network</code>：IP头-&gt;源地址SIP-&gt;目标地址DIP-&gt;”DLL_Data”<ul><li>主要功能：路由、寻址NetWork，<code>数据包</code>传输；</li><li>典型设备：路由器Router；<ul><li>路由表<code>route</code>：目标网络、端口、距离(路径选择)；</li></ul></li><li>典型协议、标准、应用：<strong>IP</strong>、IPX、APPLETALK、ICMP、<strong>ARP、逆地址解析协议RARP</strong>；</li></ul></li><li>数据链路层：前导符_8-&gt;目标地址DMAC_6-&gt;源地址SMAC_6-&gt;长度_2-&gt;Data-&gt;FCS_4<ul><li>主要功能：保证无差错的疏忽链路的data link，<code>帧</code>传输；</li><li>典型设备：交换机、网桥、网卡；<ul><li>交换机各接口拥有各自冲突域；</li><li>同一广播域；</li><li>通过加压等手段，解决电流不分压问题；</li></ul></li><li>典型协议、标准、应用：802.2、802.3ATM、HDLC、FRAME RELAY；</li><li>错误检测：奇偶校验；CRC冗余校验、</li></ul></li><li>物理层<ul><li>主要功能：传输比特流Physical，二进制<code>位</code>传输；</li><li>典型设备：集线器、中继器；<ul><li>集线器特点：<ul><li>同一冲突域：CSMA/CD载波侦听多路访问控制；</li><li>同一广播域：电流扩散特性；</li><li>所有设备共享相同带宽：并联分压；</li></ul></li></ul></li><li>典型协议、标准、应用：V.35、EIA/TIA-232。</li></ul></li></ul><h1 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h1><p>TCP/IP协议是一个<strong>协议簇</strong>，包含很多协议，如UDP。<br>TCP/IP<strong>协议集/协议族</strong>包括：应用层、传输层、网络层、网络访问层/数据链路层。</p><ul><li>应用层</li><li>传输层</li><li>Internet层</li><li>数据链路层</li><li>物理层</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><code>Transmission Control Protocol</code>，传输控制协议，是<strong>面向连接</strong>的协议，在<strong>收发数据前必须建立起可靠的连接</strong>。<br>一个TCP连接必须要经过<strong>三次握手</strong>才能建立，经过<strong>四次挥手</strong>断开连接，大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互。</p><p>TCP报头：原端口_16位，目标端口_16，序列号_32，TCP头长度_4，reserved_6，控制代码_6，窗口大小_16，偏移量_16，校验和_16，选项_32(可选)。<br><em>TCP最小报头长度为20字节。</em></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>主机A通过向主机B发送一个<strong>含有同步序列号SYN的标识位的数据段</strong>给主机B，向主机B请求建立连接。<br>通过该数据段，主机A告诉主机B两件事：我想要和你通信；你可以用那个序列号作为起始数据段来回应我。</li><li>主机B收到主机A的请求后，用一个<strong>带有确认应答ACK和同步序列号SYN标识位的数据段</strong>响应主机A。<br>主机B回应主机A两件事：我已经收到你的请求，你可以传输数据了；你要用哪个序列号作为起始数据段来回应我。</li><li>主机A收到回应的数据段后，再发送一个<strong>确认应答ACK</strong>，确认已收到主机B的数据段“我已收到回复，我现在要开始传输实际数据了”。</li></ol><p>三次握手的特点：</p><ul><li>没有应用层的数据；</li><li>SYN这个标识位只有在TCP建立连接时才会被置为1，握手完成后SYN标识位被置为0。</li></ul><p>ACK：TCP报头的控制位之一，对数据进行确认，确认由目的端发出，告诉发送端某序列号之前的数据段都收到了。<br>    如，确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时，确认才有效；当ACK=0时，确认号无效，要求重传数据，保证数据的完整性。<br>SYN：同步序列号，TCP建立连接时，将该位置置为1。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li>当主机A完成数据传输后，将<strong>控制位FIN置为1</strong>，提出停止TCP连接的请求；</li><li>主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将要关闭，将<strong>ACK置为1</strong>；</li><li>主机B提出反方向的关闭请求，将<strong>FIN置为1</strong>；</li><li>主机A对主机B的请求进行确认，将<strong>ACK置为1</strong>，TCP连接关闭。</li></ol><p>FIN：发送端完成发送任务后，当TCP完成数据传输需要断开时，提出断开连接的一方将该位置为1。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><code>User Data Protocol</code>，用户数据报协议：</p><ul><li>UDP是一个<strong>非连接的协议</strong>，传输数据之前源端和终端不建立连接，当它想传送时就简单的去抓取来自应用程序的数据，并尽可能快的将其扔到网络上。<ul><li>发送端，UDP传送数据的速度仅仅受应用程序生成数据的速度、计算机的能力、传输带宽的限制；</li><li>接收端，UDP将每个消息段放在队列中，应用程序每次从队列中读取一个消息段；</li></ul></li><li>由于传输数据不建立连接，因此不需要维护连接状态(包括收发状态等)；<ul><li>一台服务器可同时向多个客户机传输相同的消息；</li></ul></li><li>UDP信息报的标题只有8个字节，信息报的额外开销小；</li><li>吞吐量不受拥塞控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制；</li><li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，主机不需要维持复杂的链接状态表；</li><li>UDP<strong>面向报文</strong>，发送方的UDP对应用程序交下来报文，在添加首部后就向下交付给IP层，既不拆分，也不合并，保留这些报文的边界。<ul><li>应用程序需要选择合适的报文大小。</li></ul></li></ul><p>UDP报头：源端口_16，目的端口_16，长度_16，校验和_16位。</p><h2 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs. UDP"></a>TCP vs. UDP</h2><p>TCP：一种<strong>流模式</strong>的协议，面向连接、传输可靠(保证数据正确性，保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销大(时间&amp;系统资源)，TCP程序结构较简单。<br>UDP：一种<strong>数据报模式</strong>的协议，面向非连接、传输不可靠、用于传输少量数据(数据报模式)、速度快，对系统资源占用少，UDP程序结构较简单。</p><h1 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h1><h2 id="Hypertext-Transfer-Protocol-超文本传输协议"><a href="#Hypertext-Transfer-Protocol-超文本传输协议" class="headerlink" title="Hypertext Transfer Protocol 超文本传输协议"></a>Hypertext Transfer Protocol 超文本传输协议</h2><p>Http是建立在TCP协议上的一种应用，是Web联网的基础。</p><p>核心：<strong>客户端发送的每次请求都需要服务器发送响应，在请求结束后，主动释放连接</strong>。</p><ul><li>从建立连接到关闭连接的过程称为<code>一次连接</code>。</li><li>Http连接是一种<code>**短连接**</code>，即要保持客户端程序的在线状态，需要不断的向服务器发起连接请求；<ul><li>若服务器长时间无法收到客户端的请求，则认为客户端“下线”；</li><li>若客户端长时间无法收到服务器的回复，则认为网络已经断开。</li></ul></li></ul><ul><li>Http 1.0<ul><li>客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，自动释放连接。</li><li>生命周期通过request界定，一个request对应一个response。</li></ul></li><li>Http 1.1<ul><li>可在一次连接中处理多个请求，并且多个请求可以交叠进行，不需要等待一个请求结束再发送下一个请求。</li><li>添加一个keep-alive，可将多个http请求合并为一个，即在一个http链接中，可以发送多个request，接受对应多个response。</li></ul></li></ul><p><em>response是被动的，不能主动发起。</em></p><h2 id="Hypertex-Transfer-Protocol-over-Secure-Socket-Layer"><a href="#Hypertex-Transfer-Protocol-over-Secure-Socket-Layer" class="headerlink" title="Hypertex Transfer Protocol over Secure Socket Layer"></a>Hypertex Transfer Protocol over Secure Socket Layer</h2><p>https是以安全为目标的http通道，在http下加入SSL层(安全加密)。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/https.jpeg" alt="https"></p><ol><li>客户端发送https请求，服务器端应非对称加密生成公钥和私钥；</li><li>服务端将公钥发送给客户端，服务端保存私钥；</li><li>客户端拿到公钥，生成一个密钥(客户端和服务端通信的🔑)；</li><li>客户端用公钥对密钥进行加密，发送给服务器；</li><li>服务器拿到客户端发送的加密后的密钥，用私钥进行解密，双方均获得通信的🔑。</li></ol><p>https与http的区别：</p><ul><li>https：需要<strong>ca申请证书</strong>，<strong>端口号443</strong>，https是由<code>ssl+http</code>构建的可进行<strong>加密传输、身份认证</strong>的网络协议。</li><li>http：超文本传输协议，明文信息传输，<strong>端口号80</strong>，http的连接是<strong>无状态</strong>的。</li></ul><h1 id="Socket-套接字协议"><a href="#Socket-套接字协议" class="headerlink" title="Socket 套接字协议"></a>Socket 套接字协议</h1><p>Socket是通信的基石，是支持TCP/IP协议的网络通信的<strong>基本操作单元</strong>。</p><p>Socket是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：</p><ul><li>连接使用的协议</li><li>本地主机的IP地址</li><li>本地进程的协议端口</li><li>远地主机的IP地址</li><li>远地进程的协议端口</li></ul><p>解决问题：</p><ul><li>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序提供并发服务的问题。</li><li>多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。</li><li>为了区别不同的应用程序进程和连接，操作系统为应用程序及TCP/IP协议交互提供了Socket接口。</li><li>应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，<strong>实现数据传输的并发服务</strong>。</li></ul><h2 id="Socket连接的建立"><a href="#Socket连接的建立" class="headerlink" title="Socket连接的建立"></a>Socket连接的建立</h2><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端<code>ClientSocket</code>，另一个运行于服务器端<code>ServerSocket</code>。</p><ol><li>服务器监听：ServerSocket不定位具体的ClientSocket，而是<strong>处于等待连接的状态</strong>，<strong>实时监控网络状态</strong>，等待客户端的连接请求。</li><li>客户端请求：ClientSocket提出连接请求，要连接的目标是ServerSocket。<ol><li>ClientSocket必须描述要连接的ServerSocket，指出S而verSocket的地址和端口号；</li><li>向ServerSocket提出连接请求。</li></ol></li><li>连接确认：当ServerSocket监听/接收到ClientSocket的连接请求，响应ClientSocket请求。<ol><li>建立一个新线程，将ServerSocket的描述发送给客户端；</li><li>待客户端确认该描述，双方正式建立连接；</li><li>ServerSocket继续处于监听状态，继续接收其它ClientSocket的连接请求。</li></ol></li></ol><h2 id="Socket连接-vs-TCP连接"><a href="#Socket连接-vs-TCP连接" class="headerlink" title="Socket连接 vs. TCP连接"></a>Socket连接 vs. TCP连接</h2><p>创建Socket连接时，可指定使用的传输层协议，当Socket使用TCP协议进行连接时(<strong>默认TCP</strong>)，Socket就是一个TCP连接。<br>当Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。</p><p>在实际网络应用中，客户端到服务器间的通信往往需要穿越多个中间节点(路由器、网关、防火墙等)而导致Socket连接中断，因此，<strong>需要通过<code>轮询</code>告诉网络该连接处于活跃状态</strong>。</p><h2 id="Socket连接-vs-http连接"><a href="#Socket连接-vs-http连接" class="headerlink" title="Socket连接 vs. http连接"></a>Socket连接 vs. http连接</h2><ul><li>Socket连接：服务器可主动向客户端推送数据，保持客户端于服务器数据的实时与同步；</li><li>http连接：<code>请求-响应</code>方式，在请求时需要先建立连接，在客户端向服务器发送请求后，服务器端才能回复数据；客户端需要定时向服务器端发送连接请求，使其保持在线状态，同时询问服务器是否有新数据。</li></ul><h1 id="session-amp-cookie"><a href="#session-amp-cookie" class="headerlink" title="session &amp; cookie"></a>session &amp; cookie</h1><p>针对http的无状态的特性，无法判断具体哪个用户，因此，设计了Cookie和Session。、</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie存储在客户端，用来记录用户状态，区分用户。<br>一般由服务端将生成的Cookie通过响应返回给客户端，由客户端进行保存。</p><ul><li>修改Cookie<ul><li>相同Key值得到的新的Cookie会<strong>覆盖</strong>旧的Cookie；</li><li>覆盖规则是<code>name path</code>和<code>domain</code>等需要与原有的一致。</li></ul></li><li>删除Cookie<ul><li>设置Cookie的expires为过去的一个时间点，或<code>maxAge = 0</code>。</li></ul></li></ul><p>如何保证Cookie的安全：</p><ul><li>对Cookie进行加密处理；</li><li>只在https上携带Cookie；</li><li>设置Cookie为httpOnly，防止跨站脚本攻击。</li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session存储在网络端，需要依赖Cookie机制。<br>服务端生成Session后，返回给客户端，客户端进行存储<code>setCookie:sessionID</code>；<br>再次请求时，客户端将Cookie发送给服务端，服务端解析出<code>SessionID</code>，根据<code>SessionID</code>判断当前用户。</p><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://www.bilibili.com/video/BV1yb41157bj?from=search&amp;seid=2308486019812769228" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yb41157bj?from=search&amp;seid=2308486019812769228</a></li><li><a href="https://www.jianshu.com/p/a9a960677508" target="_blank" rel="noopener">https://www.jianshu.com/p/a9a960677508</a></li><li><a href="https://blog.csdn.net/u013967628/article/details/85210036" target="_blank" rel="noopener">https://blog.csdn.net/u013967628/article/details/85210036</a></li><li><a href="https://www.jianshu.com/p/afb516bc4519" target="_blank" rel="noopener">https://www.jianshu.com/p/afb516bc4519</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络七层协议-OSI七层模型&quot;&gt;&lt;a href=&quot;#网络七层协议-OSI七层模型&quot; class=&quot;headerlink&quot; title=&quot;网络七层协议/OSI七层模型&quot;&gt;&lt;/a&gt;网络七层协议/OSI七层模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;应用层&lt;ul&gt;
&lt;li&gt;用户接口
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二进制运算</title>
    <link href="http://zhangzongyu00.github.io/2020/07/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/"/>
    <id>http://zhangzongyu00.github.io/2020/07/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/</id>
    <published>2020-07-16T07:16:04.000Z</published>
    <updated>2020-07-16T07:23:54.687Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">符号</th><th align="center">名称</th><th align="center">表示</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">按位与</td><td align="center">对应位均为1，才为1；否则为0</td></tr><tr><td align="center">|</td><td align="center">按位或</td><td align="center">对应位有1，即为1；否则为0</td></tr><tr><td align="center">^</td><td align="center">按位异或</td><td align="center">相同异或为1；不同异或为1</td></tr><tr><td align="center">~</td><td align="center">按位取反</td><td align="center">1变0，0变1</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">按位左移</td><td align="center">左移，右边补0，相当*2</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">有符号的右移</td><td align="center">右移，左边补符号位，负数以原码形式参与运算</td></tr><tr><td align="center">&gt;&gt;&gt;</td><td align="center">无符号的右移</td><td align="center">右移，左边补0，所有数据以无符号方式计算</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;符号&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;名称&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;表示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>runtime</title>
    <link href="http://zhangzongyu00.github.io/2020/07/13/runtime/"/>
    <id>http://zhangzongyu00.github.io/2020/07/13/runtime/</id>
    <published>2020-07-13T11:12:06.000Z</published>
    <updated>2020-07-19T08:55:37.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h1><p>将源代码转换为可执行的程序，通常需要经过三个步骤：<strong>编译、链接、运行</strong>。</p><p><em>C语言-静态类语言，在编译阶段就已经确定了所有变量的数据类型，同时确定好了要调用的函数，及函数的实现。</em></p><p>Objective-C语言，是一门<strong>动态语言</strong>，在编译阶段并不知道变量的具体数据类型，也不知道真正调用的是哪个函数。<br>只有在运行时才检查变量的数据类型，同时在运行时才会根据函数名查找要调用的具体函数。</p><p>Objective-C语言把一些决定性的工作从编译阶段、链接阶段推迟到运行时阶段的机制，使得Objective-C更加灵活。<br>在程序运行的时候，动态的去修改一个方法的实现，为“热更新”提供了可能性。</p><p>Objective-C语言<strong>运行时机制的一切基础</strong>：Runtime。</p><p>Runtime，实际是一个库，这个库使我们可以在程序运行时动态的创建对象、检查对象、修改类和对象的方法。</p><p>Runtime的作用：<em>不得已才使用</em></p><ul><li>调用已知私有方法，如调用没有在.h文件中声明，但在.m文件实现了的方法；</li><li>用runtime调用私有方法，方法编号后面开始，依次为传入给方法的参数。</li></ul><p>Runtime的具体应用：</p><ul><li>利用关联对象AssociatedObject给分类添加属性；</li><li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）；</li><li>交换方法实现（交换系统的方法）；</li><li>利用消息转发机制解决方法找不到的异常。</li></ul><h1 id="消息机制的基本原理"><a href="#消息机制的基本原理" class="headerlink" title="消息机制的基本原理"></a>消息机制的基本原理</h1><p>Objective-C语言中，对象方法调用都是类似<code>[receiver selector];</code>的形式，其本质就是让<strong>对象在运行时发送消息</strong>的过程。</p><h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><code>[receiver selector];</code>方法被编译器转换为：</p><ol><li>不带参数：<code>objc_msgSend(receiver,selector)</code></li><li>带参数：<code>objc_msgSend(receiver, selector, org1, org2)</code></li></ol><h2 id="运行时阶段"><a href="#运行时阶段" class="headerlink" title="运行时阶段"></a>运行时阶段</h2><p><strong>消息接受者receiver寻找对应的selector。</strong></p><ol><li>通过receiver的isa指针找到receiver的Class；</li><li>在Class的方法缓存cache的散列表中寻找对应的实现方法IMP；</li><li>若在cache中未找到对应的IMP，就继续在Class的方法列表<code>method list</code>中寻找对应的selector，找到后填充到cache中，并返回selector；</li><li>若在Class中没有找到该selector，就继续在其父类superClass中寻找；</li><li>一旦找到对应的selector，直接执行receiver对应的selector方法实现的IMP；</li><li>若找不到对应的selector，消息被转发或临时向receiver添加这个selector对应的实现方法，否则就会发生崩溃。</li></ol><h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>所有Objective-C方法调用在编译时都会转化为对C函数objc_msgSend的调用。<br><code>objc_msgSend(receiver,selector)</code>是<code>[receiver selector];</code>对应的C函数。</p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>在<code>objc/runtime.h</code>中，Class被定义为指向<code>objc_class结构体</code>的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_class结构体</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa;                                          &#x2F;&#x2F; objc_class 结构体的实例指针</span><br><span class="line"></span><br><span class="line">    #if !__OBJC2__</span><br><span class="line">        Class _Nullable super_class;                                 &#x2F;&#x2F; 指向父类的指针</span><br><span class="line">        const char * _Nonnull name;                                  &#x2F;&#x2F; 类的名字</span><br><span class="line">        long version;                                                &#x2F;&#x2F; 类的版本信息，默认为 0</span><br><span class="line">        long info;                                                   &#x2F;&#x2F; 类的信息，供运行期使用的一些位标识</span><br><span class="line">        long instance_size;                                          &#x2F;&#x2F; 该类的实例变量大小;</span><br><span class="line">        struct objc_ivar_list * _Nullable ivars;                     &#x2F;&#x2F; 该类的实例变量列表</span><br><span class="line">        struct objc_method_list * _Nullable * _Nullable methodLists; &#x2F;&#x2F; 方法定义的列表</span><br><span class="line">        struct objc_cache * _Nonnull cache;                          &#x2F;&#x2F; 方法缓存</span><br><span class="line">        struct objc_protocol_list * _Nullable protocols;             &#x2F;&#x2F; 遵守的协议列表</span><br><span class="line">    #endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_class结构体</code>存放的数据称为元数据metadata。<br><code>objc_class结构体</code>的第一个成员变量是isa指针，isa指针保存的是所属类的结构体的实例/对象的指针。<br>Class的本质其实就是一个对象，称为类对象。</p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>在<code>objc_objc.h</code>中关于Object的定义：Object被定义为<code>objc_object结构体</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; objc_object结构体</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa;       &#x2F;&#x2F; objc_object结构体的实例指针 或称 Class类型的isa指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 指向&#96;objc_object结构体&#96;的指针</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>一个对象Object唯一保存的就是所属类Class的地址，当对一个对象Object进行方法调用，如<code>[reveiver selector];</code>，将通过<code>objc_object结构体</code>的<code>isa指针</code>去寻找对应的<code>object_class结构体</code>，然后在<code>object_class结构体</code>的方法列表methodLists中找到要调用的方法，然后执行。</p><h3 id="Meta-Class（元类）"><a href="#Meta-Class（元类）" class="headerlink" title="Meta Class（元类）"></a>Meta Class（元类）</h3><p><code>object_class结构体</code>的isa指针指向的是对应的类对象<code>object_class结构体</code>，而<code>object_class结构体</code>的isa指针实际指向的是类对象自身的元类<code>Meta Class</code>。</p><p><code>Meta Class</code>就是一个类对象所属的类，一个对象所属的类叫做类对象，一个类对象所属的类称为元类。</p><p>Runtime中把类对象所属类型叫做<code>Meta Class</code>，用于描述类对象本身所具有的特征，类对象本身指向的就是元类。<br><strong>每个类对象有且仅有一个与之相关的元类</strong>。在元类的methodLists中，保存了类的方法链表/类方法。</p><p><strong>类方法的调用过程</strong>：</p><ol><li>通过类对象的isa指针找到所属的元类<code>Meta Class</code>;</li><li>在<code>Meta Class</code>的方法列表methodLists中找到对应的selector；</li><li>执行对应的selector。</li></ol><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *testString &#x3D; [NSString stringWithFormat:@&quot;%d,%s&quot;,3, &quot;test&quot;];</span><br></pre></td></tr></table></figure><p><code>stringWithFormat</code>被发送给了NSString类，NSString类通过isa指针找到NSString元类，然后在该元类的方法列表中找到对应的<code>stringWithFormat</code>方法，执行。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%AF%B9%E8%B1%A1_%E7%B1%BB_%E5%85%83%E7%B1%BB.png" alt="对象_类_元类"></p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><code>object_class结构体</code>的方法列表methodLists只存放的元素就是方法Method。</p><p>在<code>objc/runtime.h</code>中，表示Method的<code>object_class结构体</code>的数据结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 代表类定义中一个方法的不透明类型</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name;                    &#x2F;&#x2F; 方法名，SEL只是一个保存方法名的字符串</span><br><span class="line">    char * _Nullable method_types;               &#x2F;&#x2F; 方法类型，方法类型method_types是个字符串，存储方法的参数类型和返回值类型</span><br><span class="line">    IMP _Nonnull method_imp;                     &#x2F;&#x2F; 方法实现，用来找到函数地址，实质是函数指针，指向的为方法的实现</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Method将方法名SEL和函数指针IMP关联，当对一个对象发送消息时，会通过给出的SEL去找到IMP，然后执行。</p><h1 id="Runtime消息转发"><a href="#Runtime消息转发" class="headerlink" title="Runtime消息转发"></a>Runtime消息转发</h1><p>当找不到对应的方法selector时，Runtime提供了<strong>消息动态解析、消息接受者重定向、消息重定向</strong>等三步处理消息。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Runtime%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="Runtime消息转发"></p><h2 id="消息动态解析"><a href="#消息动态解析" class="headerlink" title="消息动态解析"></a>消息动态解析</h2><p>Objective-C运行时会调用<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>提供一个函数实现。<br>前者在对象方法未找到时调用，后者在类方法未找到时调用。<br>可通过重写这两个方法，添加其它函数实现，并返回YES，运行时系统就会重新启动一次消息发送的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类方法未找到时调起，可以在此添加方法实现</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel;</span><br><span class="line">&#x2F;&#x2F; 对象方法未找到时调起，可以在此添加方法实现</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * class_addMethod    向具有给定名称和实现的类中添加新方法</span><br><span class="line"> * @param cls         被添加方法的类</span><br><span class="line"> * @param name        selector 方法名</span><br><span class="line"> * @param imp         实现方法的函数指针</span><br><span class="line"> * @param types imp   指向函数的返回值与参数类型</span><br><span class="line"> * @return            如果添加方法成功返回 YES，否则返回 NO</span><br><span class="line"> *&#x2F;</span><br><span class="line">BOOL class_addMethod(Class cls, SEL name, IMP imp, </span><br><span class="line">                const char * _Nullable types);</span><br></pre></td></tr></table></figure><h2 id="消息接受者重定向"><a href="#消息接受者重定向" class="headerlink" title="消息接受者重定向"></a>消息接受者重定向</h2><p>如果消息动态解析<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>中没有添加其它函数实现，运行时就会进行下一步：消息接受者重定向。<br>如果当前对象实现了<code>-forwardingTargetForSeletor:</code>或<code>+forwardingTargetForSeletor:</code>方法，Runtime就会调用该方法，运行将消息的接受者转发给其它对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重定向类方法的消息接收者，返回一个类或实例对象</span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">&#x2F;&#x2F; 重定向方法的消息接收者，返回一个类或实例对象</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>通过<code>forwardingTargetForSeletor</code>可以修改消息的接受者，该方法返回参数是一个对象，<br>如果这个对象不是nil，也不是self，系统会将运行的消息转发给该对象执行。<br>否则，继续进行消息重定向。</p><h2 id="消息重定向"><a href="#消息重定向" class="headerlink" title="消息重定向"></a>消息重定向</h2><p>Runtime会利用<code>-methodSignatureForSelector:</code>或<code>+methodSignatureForSelector:</code>方法获取函数的参数和返回值类型。</p><ul><li>如果<code>methodSignatureForSelector:</code>返回了一个<code>NSMethodSignature</code>对象/函数签名，Runtime会创建一个<code>NSInvocation</code>对象，并通过<code>forwardInvocation:</code>消息通知当前对象，给此次消息发送最后一次寻找IMP的机会。</li><li>如果<code>methodSignatureForSelector:</code>返回nil，Runtime发出<code>doesNotRecognizeSelector:</code>消息，程序崩溃。</li></ul><p><code>forwardInvocation:</code>方法中对消息进行转发：</p><ol><li>类方法调用：<ol><li><code>+methodSignatureForSelector:</code></li><li><code>+forwardInvocation:</code></li><li><code>+doesNotRecognizeSelector:</code></li></ol></li><li>对象方法调用：<ol><li><code>-methodSignatureForSelector:</code></li><li><code>-forwardInvocation:</code></li><li><code>-doesNotRecognizeSelector:</code></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取类方法函数的参数和返回值类型，返回签名</span><br><span class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类方法消息重定向</span><br><span class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation；</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取对象方法函数的参数和返回值类型，返回签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象方法消息重定向</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation；</span><br></pre></td></tr></table></figure><h1 id="method-swizzling"><a href="#method-swizzling" class="headerlink" title="method swizzling"></a>method swizzling</h1><p>俗称黑魔法，其实就是进行方法交换。</p><p>在OC中调用一个方法，其实就是向一个对象发送消息，<strong>查找消息的唯一依据就是selector的名字</strong>。<br>利用OC的动态特性，可在<strong>运行时偷换selector对应的方法</strong>，达到给方法挂钩的目的。</p><p>交换方法的实现：</p><ul><li>利用<code>method_exchangeImplementations</code>交换两个方法的实现；</li><li>利用<code>class_replaceMethod</code>替换方法的实现；</li><li>利用<code>method_setImplementation</code>直接设置某个方法的IMP。</li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Swift和OC一样，都是采用基于引用计数的ARC内存管理方案(针对堆空间的内存管理)。</p><p>Swift中ARC有3中引用：</p><ul><li>强引用<code>strong reference</code>：默认使用的都是强引用；</li><li>弱引用<code>weak reference</code>：通过weak定义的引用，必须是可选类型的var；<ul><li>实例销毁后，ARC会自动将弱引用设置为nil；</li><li>ARC自动给弱引用设置nil时，不会触发属性观察；</li><li>weak引用添加了<strong>附加层</strong>，<code>间接地将unowned引用包裹到一个可选容器</code>，附加的机制需要正确的处理可选值。</li></ul></li><li>无主引用<code>unowned reference</code>：通过unowned定义的无主引用；<ul><li>不会产生强引用，实例销毁后仍存储着实例的内存地址，类似于OC中的<code>unsafe_unretained</code>；</li><li>试图在实例销毁后访问无主引用会产生运行时错误-野指针；</li><li>不会去验证引用对象的有效性，若无效，指向已经释放垃圾内存，“unowned(unsafe)”；</li><li>当一个unwoned引用被释放后，如果没有其它强引用/unowned引用指向该对象，最终将该对象将被<strong>析构</strong>，否则，对象将会保持未解析可访问状态。</li></ul></li></ul><p>循环引用问题：<br>weak、unowned都能解决循环引用的问题，unowned要比weak少一些性能消耗；</p><ul><li>在生命周期中可能会变成nil的使用weak；</li><li>初始化赋值后不会再变成nil的使用unowned，原始实例永远不会为nil，闭包可直接定义为显式解包可选值；</li></ul><p><em>闭包默认会对用到的外层对象(retain操作)产生额外的强引用，并且只有lazy修饰的闭包才能引用self。</em></p><h2 id="内存访问冲突"><a href="#内存访问冲突" class="headerlink" title="内存访问冲突"></a>内存访问冲突</h2><p>在swift中的内存访问冲突主要在两个访问满足下列条件时发生：</p><ul><li>至少一个是写入操作；</li><li>访问的是同一块内存；</li><li>访问时间重叠，如在同一函数内；若满足下条件，则安全：<ul><li>访问的是实例存储属性，而非计算属性或属性类；</li><li>结构体是局部变量，而非全局变量；</li><li>结构体没有被闭包捕获，或只被非逃逸闭包捕获。</li></ul></li></ul><hr><p>Swiftc编译过程：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/swiftc.png" alt="swiftc"></p><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/e709fde38de3" target="_blank" rel="noopener">https://www.jianshu.com/p/e709fde38de3</a></li><li><a href="https://www.jianshu.com/p/75849d7ea832" target="_blank" rel="noopener">https://www.jianshu.com/p/75849d7ea832</a></li><li><a href="https://www.jianshu.com/p/de4ef8d027ac" target="_blank" rel="noopener">https://www.jianshu.com/p/de4ef8d027ac</a></li><li><a href="https://www.jianshu.com/p/b46aae5bb1d0" target="_blank" rel="noopener">https://www.jianshu.com/p/b46aae5bb1d0</a></li><li><a href="https://www.jianshu.com/p/b18af4edd9b6" target="_blank" rel="noopener">https://www.jianshu.com/p/b18af4edd9b6</a></li></ul>]]></content>
    
    <summary type="html">
    
      接受者receiver -&gt; 选择器selector
    
    </summary>
    
    
      <category term="ios" scheme="http://zhangzongyu00.github.io/categories/ios/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="http://zhangzongyu00.github.io/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://zhangzongyu00.github.io/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2020-07-12T12:35:22.000Z</published>
    <updated>2020-07-17T10:26:16.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h1><p>软件实体应当对扩展开放，对修改关闭。当应用的<strong>需求改变</strong>时，在<strong>不修改软件实体的源代码</strong>或二进制代码的前提下，可以<strong>扩展模块的功能</strong>，使满足新的需求。</p><p><strong>软件实体</strong>包括：项目中划分出的模块、类与接口、方法。</p><h2 id="开闭原则的作用"><a href="#开闭原则的作用" class="headerlink" title="开闭原则的作用"></a>开闭原则的作用</h2><p>OCP是OOP的终极目标，使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。</p><ol><li>对软件测试的影响：测试时只需对扩展代码进行测试即可。</li><li>提高代码的可复用性：粒度越小，被复用的可能性越大；在OOP中，根据原子和抽象编程可提高代码的可复用性。</li><li>提高软件的可维护性：稳定性高、延续性强，软件易于开发和维护。</li></ol><h2 id="开闭原则的实现方法"><a href="#开闭原则的实现方法" class="headerlink" title="开闭原则的实现方法"></a>开闭原则的实现方法</h2><p>可通过“<strong>抽象约束、封装变化</strong>”来实现OCP，即通过接口或抽象类为软件实体定义一个相对稳定的抽象层，<strong>将相同的可变因素封装在相同的具体实现类</strong>中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，基本可以保持软件架构的稳定。<br>软件中易变的细节可从抽象派生来的实现类进行扩展。当软件需求发生变化时，只需根据需求重新派生一个实现类来扩展即可。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Windows%E6%A1%8C%E9%9D%A2%E4%B8%BB%E9%A2%98%E7%B1%BB%E5%9B%BE.png" alt="Windows桌面主题类图"></p><h1 id="里式替换原则LSP"><a href="#里式替换原则LSP" class="headerlink" title="里式替换原则LSP"></a>里式替换原则LSP</h1><p>继承必须确保超类所拥有的性质在子类中仍然成立。</p><p>LSP主要阐述了<strong>有关继承的一些原则</strong>，即何时应使用继承，什么时候不应该使用继承，及其中蕴含的原理。<br>LSP是继承复用的基础，反映了<strong>基类与子类间的关系</strong>，是对OCP的补充，是<strong>对实现抽象化的具体步骤的规范</strong>。</p><h2 id="里式替换原则的作用"><a href="#里式替换原则的作用" class="headerlink" title="里式替换原则的作用"></a>里式替换原则的作用</h2><ol><li>LSP是实现OCP的重要方式之一。</li><li>LSP克服了继承中重写父类造成的可复用性变差的缺点。</li><li>LSP是动作正确性的保证，即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li></ol><h2 id="里式替换原则的实现方法"><a href="#里式替换原则的实现方法" class="headerlink" title="里式替换原则的实现方法"></a>里式替换原则的实现方法</h2><p>LSP简单来讲，子类可以扩展父类的功能，但不能改变父类原有的功能，即子类继承父类时，除添加新的方法完成新增功能外，<strong>尽量不要重写父类的方法</strong>。</p><p><em>重写父类方法，会使整个继承体系的可复用性变差，特别是运用多态频繁时，程序运行出错的概率会非常大。</em></p><p>当程序违背了LSP，应取消原来的继承关系，重新设计它们间的关系。</p><p><em>鸟一般都会飞行，但新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算几维鸟飞行花费的时间。结果会发生“除零异常”或是“无穷大”。</em><br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%87%A0%E7%BB%B4%E9%B8%9F%E4%B8%8D%E6%98%AF%E9%B8%9F.png" alt="几维鸟不是鸟"></p><h1 id="依赖倒置原则DIP"><a href="#依赖倒置原则DIP" class="headerlink" title="依赖倒置原则DIP"></a>依赖倒置原则DIP</h1><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。即<strong>要面向接口编程，不要面向实现编程</strong>。</p><p>在软件设计中，细节(具体的实现类)具有多变性，而抽象层(接口或抽象类)相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定。</p><p>使用接口或抽象类的目的是<strong>制定好规范和契约</strong>，而不去涉及任何具体的操作，把<strong>展现细节的任务交给其实现类</strong>去完成。</p><h2 id="依赖倒置原则的作用"><a href="#依赖倒置原则的作用" class="headerlink" title="依赖倒置原则的作用"></a>依赖倒置原则的作用</h2><p>DIP是实现OCP的重要途径之一，降低了客户与实现模块之间的耦合。</p><ul><li>DIP可降低类间的耦合性；</li><li>DIP可提高系统的稳定性；</li><li>DIP可减少并行开发引起的风险；</li><li>DIP可提高代码的可读性和可维护性。</li></ul><h2 id="依赖倒置原则的实现方法"><a href="#依赖倒置原则的实现方法" class="headerlink" title="依赖倒置原则的实现方法"></a>依赖倒置原则的实现方法</h2><ol><li>每个类尽量提供接口或抽象类，或者两者均有；</li><li>变量的声明类型尽量是接口或抽象类；</li><li>任何类都不应该从具体类派生；</li><li>使用继承时尽量遵循DIP。</li></ol><h1 id="单一职责原则SRP-单一功能原则"><a href="#单一职责原则SRP-单一功能原则" class="headerlink" title="单一职责原则SRP / 单一功能原则"></a>单一职责原则SRP / 单一功能原则</h1><p>SRP规定<strong>一个类应该有且仅有一个引起它变化的原因(职责)</strong>，否则，类应该被拆分。</p><p>SRP提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ol><li>一个职责的变化可能会削弱/抑制这个类实现其它职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其它不需要的职责全部包含进来，从而造成冗余代码或代码的浪费。</li></ol><h2 id="单一职责的优点"><a href="#单一职责的优点" class="headerlink" title="单一职责的优点"></a>单一职责的优点</h2><p>SRP的核心就是<strong>控制类的粒度大小</strong>，将对象解耦，提高其内聚性。</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单。</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，自然更容易维护。</li><li>变更引起的风险降低。变更是必然的，若遵守SRP，当修改一个功能时，可显著降低对其它功能的影响。</li></ul><h2 id="单一职责原则的实现方法"><a href="#单一职责原则的实现方法" class="headerlink" title="单一职责原则的实现方法"></a>单一职责原则的实现方法</h2><p>SRP是最简单但又最难运用的原则，需要设计人员发现类的不同职责，并将其分离，再封装到不同的类或模块中。<br>发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p><h1 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h1><p>客户端不应该被迫依赖于它不使用的方法。一个类对另一个类的依赖应该建立在最小的接口上。<br>要为各个类建立它们需要的<strong>专用接口</strong>，而不是试图去建立一个庞大的接口供所有依赖它的类去调用。</p><p>ISP要求程序员尽量将臃肿庞大的<strong>接口拆分成更小的和更具体的接口</strong>，让接口中只包含客户感兴趣的方法。</p><h2 id="SRP和ISP的区别"><a href="#SRP和ISP的区别" class="headerlink" title="SRP和ISP的区别"></a>SRP和ISP的区别</h2><p>SRP和ISP都是为了提高类的内聚性，降低它们之间的耦合性，体现了封装的思想。</p><ul><li>SRP注重的是职责；ISP注重的是对接口的依赖；</li><li>SRP主要是约束类，针对的是程序中的实现和细节；ISP主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><h2 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h2><p>ISP是为了约束接口，降低类对接口的依赖性。</p><ul><li>将臃肿庞大的接口分解为多个粒度小的接口，可预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>ISP提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>若接口的粒度大小定义合理，能保证系统的稳定性；但如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义多大，灵活性降低，无法提高定制服务，给整体项目带来无法预料的风险。</li><li>使用<strong>多个专门的接口能体现对象的层次</strong>，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现该接口时被迫设计冗余的代码。</li></ul><h2 id="接口隔离原则的实现方法"><a href="#接口隔离原则的实现方法" class="headerlink" title="接口隔离原则的实现方法"></a>接口隔离原则的实现方法</h2><ul><li>接口尽量小，但要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深度了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事。</li></ul><h1 id="迪米特法则LoD-最少知识原则LKP"><a href="#迪米特法则LoD-最少知识原则LKP" class="headerlink" title="迪米特法则LoD / 最少知识原则LKP"></a>迪米特法则LoD / 最少知识原则LKP</h1><p>只与你的直接朋友交谈，不跟“陌生人”说话。<em>朋友可以为当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</em><br>如果两个软件实体无法直接通信，那就不应当发生直接的相互调用，可通过第三方转发该调用。</p><p>其目的是降低类之间的耦合度，提高模块的相对独立性。</p><h2 id="迪米特法则的优点"><a href="#迪米特法则的优点" class="headerlink" title="迪米特法则的优点"></a>迪米特法则的优点</h2><p>LoD要求<strong>限制软件实体间通信的宽度和深度</strong>。</p><ul><li>降低了类之间的耦合度，提高了模块的相对独立性。</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li></ul><p>过度使用LoD会使系统产生大量的中介类，从而增加系统的复杂性，使模块间的通信效率降低。<br>在采用LoD时需要<strong>反复权衡</strong>，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><h2 id="迪米特法则的实现方法"><a href="#迪米特法则的实现方法" class="headerlink" title="迪米特法则的实现方法"></a>迪米特法则的实现方法</h2><ul><li>从依赖者的角度来说，<strong>只依赖应该依赖的对象</strong>。</li><li>从被依赖者的角度说，<strong>只暴露应该暴露的方法</strong>。</li></ul><p>注意事项：</p><ul><li>在类的划分上，应创建弱耦合的类。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其它类的引用上，将引用其它对象的次数降到最低。</li><li>不暴露类的属性成员，提供对应的访问器(set和get方法)。</li><li>谨慎使用序列化Serializable功能。</li></ul><h1 id="合成复用原则CRP-组合-聚合复用原则CARP"><a href="#合成复用原则CRP-组合-聚合复用原则CARP" class="headerlink" title="合成复用原则CRP / 组合/聚合复用原则CARP"></a>合成复用原则CRP / 组合/聚合复用原则CARP</h1><p>要求在软件复用时，要尽量<strong>先使用组合或聚合等关联关系</strong>来实现，其次才考虑使用继承关系来实现。</p><p>如果要使用继承管理，必须要个遵守LSP。</p><p><em>CRP和LSP相辅相成，两者都是OCP的具体实现规范。</em></p><h2 id="合成复用原则的重要性"><a href="#合成复用原则的重要性" class="headerlink" title="合成复用原则的重要性"></a>合成复用原则的重要性</h2><p>通常类的复用分为继承复用和合成复用两种</p><ul><li>继承复用：简单、易实现；<ul><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，又称<code>白箱复用</code>。</li><li>子类与父类的耦合度高。父类的实现的任何改变会导致子类的实现发生改变，不利于类的扩展和维护。</li><li>限制类复用的灵活性。从父类继承的实现是静态的，在编译时已定义，在运行时不能发生变化。</li></ul></li><li>组合/聚合复用：可将已有对象纳入新对象，使之成为新对象的一部分，新对象可调用已有对象的功能；<ul><li>维持了类的封装性。因为成分对象的内部细节是新对象看不见的，又称<code>黑箱复用</code>。</li><li>新旧类的耦合度低。复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。复用可在运行时动态进行，新对象可动态地引用与成分对象类型相同的对象。</li></ul></li></ul><h2 id="合成复用原则的实现方法"><a href="#合成复用原则的实现方法" class="headerlink" title="合成复用原则的实现方法"></a>合成复用原则的实现方法</h2><p>CRP通过将已有对象纳入新对象中，作为新对象的成员对象来实现，新对象可调用已有对象的功能，从而达到复用。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1331.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1331.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据7条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。开闭原则OCP是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则LSP告诉我们不要破坏继承体系；依赖倒置原则DIP告诉我们要面向接口编程；单一职责原则SRP告诉我们实现类要职责单一；接口隔离原则ISP告诉我们在设计接口的时候要精简单一；迪米特法则LoD告诉我们要降低耦合度；合成复用原则CRP告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>统一建模语言Unified Modeling Language</title>
    <link href="http://zhangzongyu00.github.io/2020/07/12/UML/"/>
    <id>http://zhangzongyu00.github.io/2020/07/12/UML/</id>
    <published>2020-07-12T08:41:56.000Z</published>
    <updated>2020-07-12T12:01:21.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>特点：简单、统一、图形化、可表达软件设计中的动态和静态信息。</p><p>UML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图。</p><p><em>业界使用较多的为<code>Rational Rose</code>和轻量级的开源<code>Umlet</code>。</em></p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><h2 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h2><p>类指<strong>具有相同属性、方法、关系的对象的抽象</strong>，封装了数据和行为，是面向对象程序设计OOP的基础，具有<strong>封装性、继承性、多态性</strong>。</p><p>在UML中，类使用包含<strong>类名、属性、操作，并带有分隔线的矩形</strong>表示。</p><ul><li>类名Name：一个字符串；</li><li>属性Attribute，类的特性/成员变量：[可见性]属性名:类型[=默认值]<ul><li>可见性表示该属性对类外的元素是否可见；</li><li>公有Public对应<code>+</code>；</li><li>私有Private对应<code>-</code>；</li><li>受保护Protected对应<code>#</code>；</li><li>朋友Friendly对应<code>~</code>；</li></ul></li><li>操作Operations，类的任一实例对象都可使用的行为，类的成员方法：[可见性]名称(参数列表)[:返回类型]。</li></ul><h2 id="接口Interface"><a href="#接口Interface" class="headerlink" title="接口Interface"></a>接口Interface</h2><p>接口，具有类的结构，但<strong>不可被实例化</strong>，只能<strong>被子类实现</strong>。包含抽象操作，但不包含属性。</p><p>UML中，接口使用一个<strong>带有名称的小圆圈</strong>来表示。</p><h2 id="类图ClassDiagram"><a href="#类图ClassDiagram" class="headerlink" title="类图ClassDiagram"></a>类图ClassDiagram</h2><p>类图，用来<strong>显示系统中的类、接口、协作，及它们之间的静态结构和关系</strong>的一种<strong>静态结构</strong>。<br>主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。</p><p>类图在<strong>软件系统开发的整个生命周期</strong>都有效，是OOP建模中最常见的图。</p><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><p>根据类与类之间的耦合度从弱到强排列： 依赖关系、关联关系、聚合关系、组合关系、泛化关系==实现关系。</p><ol><li><p>依赖关系Dependency：<strong>带箭头的虚线</strong>，箭头指向被依赖的类。<br>一种使用关系，<strong>临时性关联</strong>，某个类的方法通过局部变量、方法的参数、对静态方法的调用，来访问另一个类(被依赖类)中的某些方法来完成一些职责。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="依赖关系"></p></li><li><p>关联关系Association：</p><ol><li>双向关联：用<strong>带两个箭头或没有箭头的实线</strong>表示；</li><li>单向关联：用<strong>带一个箭头的实线</strong>来表示；<br>对象间的一种<strong>引用关系</strong>，用于表示一类对象对另一类对象间的联系，通常将一个类的对象作为另一个类的成员变量来实现。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.png" alt="关联关系"></li></ol></li><li><p>聚合关系Aggregation：用<strong>带空心菱形的实线</strong>表示，菱形指向整体。<br>关联关系的一种，是<strong>强关联关系</strong>，是<strong>整体和部分</strong>间的关系。<br>聚合关系<strong>通过成员对象实现</strong>，其中，成员对象是整体对象的一部分，但<strong>成员对象可以脱离整体对象独立存在</strong>。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="聚合关系"></p></li><li><p>组合关系Composition：用<strong>带实心菱形的实线</strong>表示，菱形指向整体。<br>关联关系的一种，表示<strong>类间整体与部分</strong>的关系，是一种<strong>更强烈的聚合关系</strong>。<br>组合关系中，<strong>整体对象可以控制部分对象的生命周期</strong>，一旦整体对象不存在，部分对象也不存在了，<strong>部分对象不能脱离整体对象存在</strong>。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="组合关系"></p></li><li><p>泛化关系Generalization：用<strong>带空心三角箭头的实线</strong>表示，箭头从子类指向父类。<br><strong>对象间耦合度最大</strong>的一种关系，表示<strong>一般与特殊的关系</strong>，是<strong>父类与子类</strong>的关系，是一种<strong>继承</strong>关系。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB.png" alt="泛化关系"></p></li><li><p>实现关系Realization：用<strong>带空心三角箭头的虚线</strong>表示，箭头从实现类指向接口。<br>实线关系是<strong>接口与实现类</strong>间的关系，类实现了接口，类中的操作<strong>实现了接口中声明的所有的抽象操作</strong>。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.png" alt="实现关系"></p></li></ol><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://c.biancheng.net/view/1319.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1319.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      用来设计软件蓝图的可视化建模语言，1997年被国际对象管理组织OMG采纳为面向对象的建模语言的国际标准。UML为软件开发的所有阶段提供模型化和可视化支持，并且融入软件工程领域的新思想、新方法、新技术，使软件设计人员沟通更简明，进一步缩短了设计时间、减少开发成本。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://zhangzongyu00.github.io/2020/07/10/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhangzongyu00.github.io/2020/07/10/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-10T09:31:12.000Z</published>
    <updated>2020-07-18T12:15:44.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>基本数据类型：byte、short、int、long、float、double、boolean、char。<br>三大特性：封装、继承、多态(overload参数不同，override方法覆盖)。</p><h1 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals 和 == 的区别"></a>equals 和 == 的区别</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>若没有对Object的equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址，反之，比较的是内容。</p><ul><li>类覆盖了equals()方法，<strong>一般都覆盖equals()方法来比较两个对象的内容是否相等</strong>，若相同返回true；</li><li>类没有覆盖equals()方法，通过equals()比较类的两个对象时，等价于“==”。</li></ul><p><em>equals()方法不能作用于基本数据类型的变量。</em></p><h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>判断的是两个<strong>对象的地址</strong>，即两个对象是否为同一对象。</p><ul><li>对于基本数据类型，比较的是值；</li><li>对于引用数据类型，比较的是<strong>内存地址</strong>。</li></ul><h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h2><p>这两种类型的锁，是人们定义出来的概念/思想，主要是指看待<strong>并发同步</strong>的角度。</p><h3 id="乐观锁-Compare-and-Swap"><a href="#乐观锁-Compare-and-Swap" class="headerlink" title="乐观锁 Compare and Swap"></a>乐观锁 Compare and Swap</h3><p><em>通过CAS自旋实现原子操作的更新，典型例子就是原子类。</em></p><p>每次取拿数据的时候，都认为别人不会进行修改，所以不会上锁。<br>在更新的时候会判断在此期间有没有别人取更新该数据，一般使用<code>数据版本机制</code>或<code>CAS操作</code>实现。</p><ol><li>数据版本机制<ol><li>使用版本号：<code>update table set xxx=#{xxx}, version=version+1 where id=#{id} and version=#{version};</code><ol><li>一般在数据表中添加一个数据版本号version字段，表示数据被修改的次数。</li><li>在提交更新时，若读到的version值和当前数据库中的version值相等才更新，否则重试更新操作，直到更新成功为止。</li></ol></li><li>使用时间戳：和版本号类似。</li></ol></li><li>CAS操作<ul><li>CAS操作中包含三个操作数：读写内存位置V、进行比较的预期原值A、拟写入的新值B。</li><li>如果内存位置V的值与预期原值A相匹配，处理器会自动将该位置值更新为新值B，否则处理器不做处理。</li><li>当多个线程尝试使用CAS同时更新同一个变量时，<strong>只有其中一个线程能更新变量的值</strong>，失败的线程被告知竞争失败，重新尝试，不会挂起。</li></ul></li></ol><p>优点：</p><ul><li>CAS是CPU指令级的操作，只有一步原子操作，速度非常快。</li><li>CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了。</li><li>适用于多读的应用类型，可提高吞吐量。</li></ul><p><em>java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式。</em></p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最坏的情况，每次拿数据时都认为别人会修改，所以，每次在拿数据时都会上锁。<br>别人想拿数据时会被阻塞，直到它拿到锁。</p><p>在对任意记录进行修改前，先尝试为该记录<strong>添加排它锁 exclusive locking</strong>；<br>如果加锁失败，说明该记录正在被修改，当前查询可能要等待或抛出异常。<em>具体响应方式有开发者根据实际需要决定。</em><br>如果加锁成功，就对记录做修改，事务完成后就会解锁。</p><p>适用于写操作多的场景。</p><p><em>Java中的synchronized关键字修饰的都是悲观锁。</em></p><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h2><p>独享锁和共享锁是通过AQS来实现的，通过不同的方法，来实现独享或共享。</p><ul><li>独享锁：锁一次只能被一个线程所持有；如Java中的<code>Synchronized</code>、<code>ReentrantLock</code>、<code>ReadWriteLock</code>的写锁。</li><li>共享锁：该锁可被多个线程持有；如Java中<code>ReadWriteLock</code>的读锁。</li></ul><p><code>ReadWriteLock</code>的读写、写读、写写的过程是互斥的。</p><p><strong>AbstractQueuedSynchronizer</strong><br>AQS维护一个代表共享资源(volatile int state)和一个FIFO线程等待队列(多线程争用资源被阻塞时会进入此队列)。<br>AQS定义两种资源共享方式：</p><ul><li>Exclusive：独占，只有一个线程能执行；</li><li>Share：共享，多个线程可同时执行。<br>自定义同步器在实现时只需实现state的获取和释放方式即可。</li></ul><h2 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h2><p>对<strong>独享锁/共享锁的具体实现</strong>。</p><ul><li>互斥锁：在Java中的具体实现<code>ReentrantLock</code>；</li><li>读写锁：在Java中的具体实现<code>ReadWriteLock</code>；</li></ul><p>读写锁的性能都会比排他锁要好，因为大多数场景读是多于写的。<br>在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。<br>Java并发包提供读写锁的实现是ReentrantReadWriteLock。</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁/递归锁，指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p><p><strong>可重入锁可一定程度避免死锁。</strong></p><p>如<code>ReentrantLock</code>、<code>Synchronized</code>等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">synchronized void setA() throws Exception&#123;</span><br><span class="line">　　Thread.sleep(1000);</span><br><span class="line">　　setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized void setB() throws Exception&#123;</span><br><span class="line">　　Thread.sleep(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若没有可重入锁，setB可能不会被当前线程执行，可能造成死锁。</p><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><ul><li>公平锁：指多个线程按照申请锁的顺序来获取锁。</li><li>非公平锁：指多个线程获取锁的顺序不一定按照申请锁的顺序，吞吐量比公平锁大。</li></ul><p><code>ReentrantLock</code>通过构造函数指定(通过AQS来实现调度)该锁是否为公平锁，默认是非公平锁。<br><code>synchronized</code>是一种非公平锁。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p><em>一种锁的设计，并非具体结构。</em></p><p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁。</p><p><strong>ConcurrentHashMap</strong></p><ul><li>其并发的实现就是通过分段锁的形式，来实现高效的并发操作；</li><li>分段锁称为Segment(继承自ReentrantLock)，类似于HashMap结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；</li></ul><p>当需要<strong>put</strong>元素的时候，并不是对整个hashmap进行加锁，而是</p><ol><li>先通过hashcode来确定要放到那个分段；</li><li>对该分段进行加锁；</li><li>当多线程put时，只要不放在一个分段中，即可实现真正的并行的插入。</li></ol><h2 id="偏向锁-轻量级锁-重量级锁：针对synchronized"><a href="#偏向锁-轻量级锁-重量级锁：针对synchronized" class="headerlink" title="偏向锁/轻量级锁/重量级锁：针对synchronized"></a>偏向锁/轻量级锁/重量级锁：针对<code>synchronized</code></h2><p>这3种锁的状态是通过<strong>对象监视器在对象头中的字段</strong>来表明。</p><ul><li>偏向锁：一段同步代码<strong>一直被一个线程访问</strong>，该线程会自动获取锁，降低获取锁的代价。</li><li>轻量级锁：当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，其它线程会通过自旋的形式尝试获取锁，不会阻塞。</li><li>重量级锁：当锁为轻量级锁时，另一个线程虽然自旋，但自旋不会一直持续下去，当自旋一定次数时，还未获取到锁，就会进入阻塞，该锁膨胀为重量级锁。</li></ul><p><strong>重量级锁会让它申请的线程进入阻塞，性能降低。</strong></p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>指尝试获取锁的线程不会立即阻塞，而是采用<strong>循环</strong>的方式去尝试获取锁。</p><p>优点：减少线程上下文切换的消耗；<br>缺点：循环会消耗CPU。</p><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://www.cnblogs.com/hustzzl/p/9343797.html" target="_blank" rel="noopener">https://www.cnblogs.com/hustzzl/p/9343797.html</a></li><li><a href="https://www.jianshu.com/p/ab2c8fce878b" target="_blank" rel="noopener">https://www.jianshu.com/p/ab2c8fce878b</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;p&gt;基本数据类型：byte、short、int、long、float、double、boolean、char。&lt;br&gt;三大特性：
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>软件设计模式</title>
    <link href="http://zhangzongyu00.github.io/2020/07/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangzongyu00.github.io/2020/07/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-09T12:11:20.000Z</published>
    <updated>2020-07-20T07:23:51.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件设计模式概述"><a href="#软件设计模式概述" class="headerlink" title="软件设计模式概述"></a>软件设计模式概述</h1><p>GoF合作出版了《设计模式：可复用面向对象软件的基础》，共收录23种设计模式，从此树立了软件设计领域的里程碑，人称GoF设计模式。<br>这23种设计模式的本质是面向对象设计原则的实际应用，是对类的封装性、继承性、多态性，及类的关联关系和组合关系的充分理解。</p><p>软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：</p><ul><li>对于简单的程序，可能写一个简单的算法要比引入某种设计模式更容易；</li><li>对于大型项目或框架设计，用设计模式来组织代码可提高效率。</li></ul><h2 id="软件设计模式的基本要素："><a href="#软件设计模式的基本要素：" class="headerlink" title="软件设计模式的基本要素："></a>软件设计模式的<strong>基本要素</strong>：</h2><p><em>模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展、相关模式等。</em></p><ul><li>模式名称：有助于理解记忆；</li><li>问题：描述该模式的<strong>应用环境</strong>，解释了设计问题和问题存在的前因后果，及必须满足的一系列先决条件；</li><li>解决方案：包括设计的组成成分、相互关系、各自的职责和协作方式。并不描述一个特定而具体的设计或实现，只是<strong>提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合(类/对象的组合)来解决该问题</strong>。</li><li>效果：描述模式的应用效果及使用该模式应该权衡的问题，及模式的<strong>优缺点</strong>。主要是对时间和空间的衡量，及该模式对系统的灵活性、扩充性、可移植性的影响，并考虑其实现问题。</li></ul><h2 id="设计模式的分类："><a href="#设计模式的分类：" class="headerlink" title="设计模式的分类："></a>设计模式的<strong>分类</strong>：</h2><ol><li>根据目的划分：<ol><li>创建型模式：描述怎样创建对象，<strong>将对象的创建和使用分离</strong>。单例、原型、工厂方法、抽象工厂、建造者；</li><li>结构型模式：描述如何将类/对象按某种布局<strong>组成更大的结构</strong>。代理、适配器、桥接、装饰、外观、享元、组合；</li><li>行为型模式：描述类/对象间如何<strong>相互协作共同完成</strong>单个对象无法单独完成的任务，及如何分配职责。模版方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。</li></ol></li><li>根据作用范围划分：<ol><li>类模式：处理<strong>类与子类</strong>间的关系，通过<strong>继承</strong>建立，是<strong>静态</strong>的，在编译时便确定。工厂方法、适配器、模版方法、解释器；</li><li>对象模式：处理<strong>对象</strong>间的关系，通过<strong>组合或聚合</strong>实现，在运行时是<strong>动态</strong>变化的。除⬆️4种。</li></ol></li></ol><h1 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h1><p>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p><p>单例模式，指<strong>一个类只有一个实例</strong>，且该类能自行创建这个实例的一种模式。</p><h2 id="单例模式的特点："><a href="#单例模式的特点：" class="headerlink" title="单例模式的特点："></a>单例模式的特点：</h2><ul><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ul><p>优点：</p><ul><li>提供了对唯一实例的受控访问；</li><li>由于在系统内存中只存在一个对象，可节约系统资源，对一些需要频繁创建和销毁的对象单例模式可提高系统性能；</li><li>允许可变数目的实例。<br>缺点：</li><li>由于单例模式没有抽象层，因此单例类很<strong>难扩展</strong>；</li><li>单例类的职责过重，在一定程度上违背了<a href="/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="单一职责原则SRP">单一职责原则SRP</a>；</li><li>滥用单例将带来负面问题<ul><li>如为了节约系统资源，将数据库连接池对象设计为单例模式，可能导致共享连接池对象的程序过多而出现连接池溢出；</li><li>如实例化的对象长时间不使用，系统当作垃圾回收，将导致对象状态的丢失。</li></ul></li></ul><h2 id="单例模式的结构及实现"><a href="#单例模式的结构及实现" class="headerlink" title="单例模式的结构及实现"></a>单例模式的结构及实现</h2><p>通常，普通类的构造函数是公有的，外部类可通过“new 构造函数()”来生成多个实例。<br>若将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。<br>单例类自身<strong>必须定义一个静态私有实例</strong>，并<strong>向外提供一个静态的公有函数</strong>用于创建或获取该静态私有实例。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="单例模式结构图"></p><p>Singleton模式通常有两种实现形式：</p><ol><li>懒汉式单例：类加载时不生成单例，<strong>只有当第一次调用getInstance方法时才创建</strong>这个单例。<br>多线程时要保留volatile和synchronized关键字，但<strong>每次访问都要同步</strong>，会影响性能，且消耗更多资源。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton</span><br><span class="line">&#123;</span><br><span class="line">    private static volatile LazySingleton instance&#x3D;null;    &#x2F;&#x2F;保证 instance 在所有线程中同步</span><br><span class="line">    private LazySingleton()&#123;&#125;    &#x2F;&#x2F;private 避免类在外部被实例化</span><br><span class="line">    public static synchronized LazySingleton getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;getInstance 方法前加同步</span><br><span class="line">        if(instance&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            instance&#x3D;new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>饿汉式单例：<strong>类一旦加载就创建一个单例</strong>，保证在调用getInstance方法前单例就已存在。<br>类创建的同时就创建好一个静态对象供系统使用，以后不再改变，线程安全，可直接用于多线程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton</span><br><span class="line">&#123;</span><br><span class="line">    private static final HungrySingleton instance&#x3D;new HungrySingleton();</span><br><span class="line">    private HungrySingleton()&#123;&#125;</span><br><span class="line">    public static HungrySingleton getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>在应用场景中，某类只要求生成一个对象时。如一个班的班长，个人身份证号等；</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如web中的配置对象，数据库连接池等。</li><li>当某类需要频繁实例化，创建的对象又频繁被销毁时。如多线程的线程池，网络连接池等。</li></ul><h2 id="单例模式的扩展-多例模式"><a href="#单例模式的扩展-多例模式" class="headerlink" title="单例模式的扩展-多例模式"></a>单例模式的扩展-多例模式</h2><p>单例模式可扩展为有限的多例模式，这种模式可<strong>生成有限个实例并保存在ArrayList</strong>中，客户需要时可随机获取。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%9C%89%E9%99%90%E7%9A%84%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt="有限的多例模式"></p><h1 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h1><p>将一个对象作为原型，通过对其进行<strong>复制而克隆出多个和原型类似的新实例</strong>。</p><p>原型模式，指用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。<br>原型实例指定了要创建的对象的种类，用这种方式创建对象非常高效，<strong>无须知道对象创建的细节</strong>。</p><h2 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h2><p><em>Java提供了对象的clone()方法，用Java实现原型模式非常简单。</em></p><h3 id="原型模式的结构"><a href="#原型模式的结构" class="headerlink" title="原型模式的结构"></a>原型模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" alt="原型模式"></p><ol><li>抽象原型类：规定了具体原型对象必须实现的接口；</li><li>具体原型类：实现抽象原型类的clone()方法，是<strong>可被复制的对象</strong>；</li><li>访问类：使用具体原型类的clone()方法来复制新的对象。</li></ol><h3 id="原型模式的实现"><a href="#原型模式的实现" class="headerlink" title="原型模式的实现"></a>原型模式的实现</h3><ol><li>浅克隆：Java中的Object类提供了浅克隆的clone()方法，具体原型类只要实现Cloneable接口(抽象原型类)即可实现对象的浅克隆。</li><li>深克隆</li></ol><h2 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a>原型模式的应用场景</h2><ul><li>对象间相同或相似，即只有个别属性不同；</li><li>对象的创建过程繁琐，但复制比较简单。</li></ul><h2 id="原型模式的扩展"><a href="#原型模式的扩展" class="headerlink" title="原型模式的扩展"></a>原型模式的扩展</h2><p>带<strong>原型管理器</strong>的原型模式，在原型模式的基础上增加了一个原型管理器PrototypeManager类，该类使用HashMap保存多个复制的原型，Client类可通过管理器的get(String id)方法获取复制的原型。</p><h1 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式 Factory Method"></a>工厂方法模式 Factory Method</h1><p>定义一个用于创建<strong>产品的接口</strong>，由子类决定生产什么产品。</p><p>工厂方法模式，指定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中，满足创建型模式中要求的<strong>创建与使用相分离</strong>的特点。</p><p><strong>被创建的对象–产品，创建产品的对象–工厂。</strong></p><p>简单工厂模式<em>(不属于GoF)</em>，若要创建的产品不多，只要一个工厂类就可完成。<br>缺点：增加新产品时会违背OCP。</p><p>工厂方法模式，是对简单工厂模式的进一步抽象化，优势在于<strong>可使系统在不修改原代码的基础上引进新产品</strong>，即满足OCP。</p><h2 id="工厂方法模式的特点"><a href="#工厂方法模式的特点" class="headerlink" title="工厂方法模式的特点"></a>工厂方法模式的特点</h2><ul><li>优点：<ul><li>用户只需要知道具体工厂的名称，即可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时，只需添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足OCP。</li></ul></li><li>缺点：<ul><li>每增加一个产品，就要增加一个具体产品类和一个对应的具体工厂类，增加了系统的复杂度。</li></ul></li></ul><h2 id="工厂方法模式的结构和实现"><a href="#工厂方法模式的结构和实现" class="headerlink" title="工厂方法模式的结构和实现"></a>工厂方法模式的结构和实现</h2><p>工厂方法模式由<strong>抽象工厂、具体工厂、抽象产品、具体产品</strong>4个要素构成。</p><h3 id="工厂方法模式的结构"><a href="#工厂方法模式的结构" class="headerlink" title="工厂方法模式的结构"></a>工厂方法模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="工厂方法模式"></p><ol><li>抽象工厂<code>Abstract Factory</code>：提供了创建产品的接口，调用者通过访问具体工厂的工厂方法newProduct()来创建产品。</li><li>具体工厂<code>Concrete Factory</code>：实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品<code>Product</code>：定义了产品的规范，描述了<strong>产品的主要特性和功能</strong>。</li><li>具体产品<code>Concrete Product</code>：实现了抽象产品角色所定义的接口，<strong>由具体工厂创建</strong>，同具体工厂间一一对应。</li></ol><h2 id="工厂方法模式的应用场景"><a href="#工厂方法模式的应用场景" class="headerlink" title="工厂方法模式的应用场景"></a>工厂方法模式的应用场景</h2><ul><li>客户只知道创建产品的工厂名，不知道具体的产品名。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，抽象工厂只提供创建产品的链接。</li><li>客户不关心创建产品的细节，只关心产品的品牌。</li></ul><h2 id="工厂方法模式的扩展"><a href="#工厂方法模式的扩展" class="headerlink" title="工厂方法模式的扩展"></a>工厂方法模式的扩展</h2><p>当需要生产的产品不多，且不会增加，一个具体工厂类就可完成任务时，可删除抽象工厂类。<br>可将工厂方法模式退化为简单工厂模式。</p><h1 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 Abstract Factory"></a>抽象工厂模式 Abstract Factory</h1><p>提供一个<strong>创建产品族</strong>的接口，其<strong>每个子类可生产一系列相关的产品</strong>。</p><p>抽象工厂模式，指一种<strong>为访问类提供一个创建一组相关或相互依赖对象的接口</strong>，且访问类无须指定所要产品的具体类，就能得到同族的不同等级的产品的模式结构。</p><p><strong>抽象工厂和工厂方法模式的区别：</strong></p><ul><li>工厂方法模式<strong>只考虑生产<code>同等级/同种类</code>的产品</strong>；</li><li>抽象工厂模式<strong>考虑多等级产品的生产</strong>，将<code>同一具体工厂生产的位于不同等级的一组产品</code>成为一个产品族。</li><li>工厂方法模式只生产一个等级的产品，抽象工厂模式可生产多个等级的产品，是工厂方法模式的升级版。</li></ul><h2 id="抽象工厂模式的特点"><a href="#抽象工厂模式的特点" class="headerlink" title="抽象工厂模式的特点"></a>抽象工厂模式的特点</h2><ul><li>优点：<ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理；</li><li>当增加一个新的产品族时不需要修改原代码，满足OCP。</li></ul></li><li>缺点：<ul><li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li></ul></li></ul><h2 id="抽象工厂模式的结构与实现"><a href="#抽象工厂模式的结构与实现" class="headerlink" title="抽象工厂模式的结构与实现"></a>抽象工厂模式的结构与实现</h2><p>抽象工厂模式同工厂方法模式一样，都是由抽象工厂、具体工厂、抽象产品、具体产品等4个要素构成，但抽象方法中方法个数不同，抽象产品的个数也不同。</p><h3 id="抽象工厂模式的结构"><a href="#抽象工厂模式的结构" class="headerlink" title="抽象工厂模式的结构"></a>抽象工厂模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="抽象工厂模式"></p><ol><li>抽象工厂：提供了创建产品的接口，包含多个创建产品的方法newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂：主要实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品：定义了产品的规范，描述了产品的主要特性和性能，抽象工厂模式有多个抽象产品。</li><li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，同具体工厂间是<code>n:1</code>的关系。</li></ol><p>抽象工厂模式和工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以，<strong>创建产品的方法不止一个</strong>。</p><h3 id="抽象工厂模式的实现"><a href="#抽象工厂模式的实现" class="headerlink" title="抽象工厂模式的实现"></a>抽象工厂模式的实现</h3><ol><li>抽象工厂：提供了产品的生成方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface AbstractFactory &#123;</span><br><span class="line">    public Product1 newProduct1();</span><br><span class="line">    public Product2 newProduct2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体工厂：实现了产品的生成方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteFactory implements AbstractFactory &#123;</span><br><span class="line">    public Product1 newProduct1() &#123;</span><br><span class="line">        System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 1...&quot;);</span><br><span class="line">        return new ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">    public Product2 newProduct2() &#123;</span><br><span class="line">        System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 2...&quot;);</span><br><span class="line">        return new ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="抽象工厂模式的适用场景"><a href="#抽象工厂模式的适用场景" class="headerlink" title="抽象工厂模式的适用场景"></a>抽象工厂模式的适用场景</h2><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品；</li><li>系统一次只可消费其中某一族的产品，即同族的产品一起使用。</li></ul><p>具体来讲，可分为如下3种：</p><ul><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等；</li><li>系统中有多个产品族，但每次只使用其中的某一族产品，如有人只喜欢某一个品牌的衣服和鞋子；</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li></ul><p>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构建，如Java的AWT中的Button和Text等构件在Windows和UNIX中的本地实现是不同的。</p><h2 id="抽象工厂模式的扩展"><a href="#抽象工厂模式的扩展" class="headerlink" title="抽象工厂模式的扩展"></a>抽象工厂模式的扩展</h2><p>抽象工厂模式的扩展具有一定的OCP倾斜性：</p><ul><li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足OCP。</li><li>当产品族中需要增加一个新种类的产品时，所有的工厂类都需要进行修改，不满足OCP。</li></ul><p>当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p><h1 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h1><p>将一个<strong>复杂对象分解</strong>成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p><p>建造者模式，指将一个复杂对象的<strong>构造与其表示分离</strong>，<strong>使同样的构建过程可以创建不同的表示</strong>。<br>将一个复杂的对象分解为多个简单的对象，然后一步步构建而成；将变与不变相分离，即产品的组成部分是不变的，但<strong>每一部分是灵活选择</strong>的。</p><h2 id="建造者模式的特点"><a href="#建造者模式的特点" class="headerlink" title="建造者模式的特点"></a>建造者模式的特点</h2><p>建造者模式和工厂方法模式的区别：（🉑️结合使用）</p><ul><li>建造者模式<strong>注重零部件的组装过程</strong>；</li><li>工厂方法模式注重零部件的<strong>创建过程</strong>。</li></ul><ul><li>优点：<ul><li>各个具体的建造者相互独立，有利于系统的扩展；</li><li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li></ul></li><li>缺点：<ul><li>产品的组成部分必须相同，限制了其使用范围；</li><li>若产品的内部变化复杂，会增加很多的建造者类。</li></ul></li></ul><h2 id="建造者模式的结构与实现"><a href="#建造者模式的结构与实现" class="headerlink" title="建造者模式的结构与实现"></a>建造者模式的结构与实现</h2><p>建造者模式由<strong>产品、抽象建造者、具体建造者、指挥者</strong>4个要素构成。</p><h3 id="建造者模式的结构"><a href="#建造者模式的结构" class="headerlink" title="建造者模式的结构"></a>建造者模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="建造者模式"></p><ol><li>产品角色Product：包含<strong>多个组成部件的复杂对象</strong>，由具体建造者来创建其各个部件；</li><li>抽象建造者Builder：包含创建产品各个子部件的抽象方法的接口，通常还包含一个<strong>返回复杂产品的方法</strong>getResult()；</li><li>具体建造者<code>Concrete Builder</code>：实现Builder接口，完成复杂产品的各个部件的具体创建方法；</li><li>指挥者Director：调用建造者对象中的<strong>部件构造与装配方法</strong>，完成复杂对象的创建，在指挥者中<strong>不涉及具体产品的信息</strong>。</li></ol><h3 id="建造者模式的实现"><a href="#建造者模式的实现" class="headerlink" title="建造者模式的实现"></a>建造者模式的实现</h3><ol><li>产品角色：包含多个组成部件的复杂对象；</li><li>抽象建造者：包含创建产品各个子部件的抽象方法；</li><li>具体建造者：实现了抽象建造者接口；</li><li>指挥者：调用建造者中的方法完成复杂对象的创建；</li><li>客户类</li></ol><h2 id="建造者模式的应用场景"><a href="#建造者模式的应用场景" class="headerlink" title="建造者模式的应用场景"></a>建造者模式的应用场景</h2><p>建造者模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定：</p><ul><li>创建的对象复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的；</li><li>创建复杂对象的算法独立于该对象的组成部分及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><h2 id="建造者模式的扩展"><a href="#建造者模式的扩展" class="headerlink" title="建造者模式的扩展"></a>建造者模式的扩展</h2><p>建造者模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，可省略抽象建造者，甚至指挥者。</p><h1 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h1><p>为某对象提供一种代理以控制对该对象的访问。即<strong>客户端通过代理间接地访问该对象</strong>，从而限制、增强或修改该对象的一些特性。</p><p>代理模式，由于某些原因需要给某对象提供一个<strong>代理以控制对该对象的访问</strong>，访问对象不适合或不能直接引用目标对象，代理对象作为访问对象和目标对象的中介。</p><h2 id="代理模式的特点"><a href="#代理模式的特点" class="headerlink" title="代理模式的特点"></a>代理模式的特点</h2><ul><li>优点：<ul><li>代理模式在客户端与目标对象间起到一个中介作用和<strong>保护目标对象</strong>的作用；</li><li>代理对象可以<strong>扩展目标对象的功能</strong>；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul></li><li>缺点：<ul><li>在客户端和目标对象间增加一个代理对象，会造成请求处理速度变慢；</li><li>增加了系统的复杂度。</li></ul></li></ul><h2 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h2><p>代理模式的结构比较简单，主要是通过<strong>定义一个继承抽象主题的代理来包含真实主题</strong>，从而实现对真实主题的访问。</p><h3 id="代理模式的结构"><a href="#代理模式的结构" class="headerlink" title="代理模式的结构"></a>代理模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p><ol><li>抽象主题类Subject：通过接口或抽象类声明真实主题和代理对象实现的业务方法；</li><li>真实主题类<code>Real Subject</code>：实现类抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象；</li><li>代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，🉑️访问、控制、扩展真实主题的功能。</li></ol><h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><ul><li>远程代理：通常为了隐藏目标对象存在于<strong>不同地址空间</strong>的事实，方便客户端访问，如虚拟硬盘；</li><li>虚拟代理：通常用于要创建的目标对象开销较大时，先用<strong>小比例的虚拟代理替换真实对象</strong>，消除用户等待烦躁；</li><li>安全代理：通常用于控制不同种类客户对真实对象的访问权限；</li><li>智能指引：用于调用目标对象时，代理附加一些额外的处理功能；</li><li>延迟加载：为提高系统性能，延迟对目标的加载。</li></ul><h2 id="代理模式的扩展"><a href="#代理模式的扩展" class="headerlink" title="代理模式的扩展"></a>代理模式的扩展</h2><p>普通代理模式的缺点：</p><ul><li>真实主题于代理主题一一对应，增加真实主题需要增加对应代理；</li><li>设计代理之前，真实主题必须事先存在。</li></ul><p>动态代理模式：<em>如SpringAOP</em><br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="动态代理模式"></p><h1 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h1><p>将一个类的接口转换成客户希望的另一个接口，使得原本由于<strong>接口不兼容</strong>而不能一起工作的那些类可一起工作。</p><p>适配器模式，指将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类能够协同工作。</p><ul><li>类结构型模式：耦合度比对象结构型模式高，且要求程序员了解现有组件库中的相关组件的内部结构；</li><li>对象结构型模式</li></ul><h2 id="适配器模式的特点"><a href="#适配器模式的特点" class="headerlink" title="适配器模式的特点"></a>适配器模式的特点</h2><ul><li>优点：<ul><li>客户端通过适配器可以透明的调用目标接口；</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类；</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul></li><li>缺点：<ul><li>对类适配器来说，更换适配器的实现过程比较复杂。</li></ul></li></ul><h2 id="适配器模式的结构与实现"><a href="#适配器模式的结构与实现" class="headerlink" title="适配器模式的结构与实现"></a>适配器模式的结构与实现</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="类适配器模式"></p><ul><li>类适配器模式，可采用多重继承方式实现；<ul><li>如C++可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；</li><li>如Java不支持多继承，但可定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="对象适配器模式"></li></ul></li><li>对象适配器模式，可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</li></ul><h3 id="适配器模式的结构"><a href="#适配器模式的结构" class="headerlink" title="适配器模式的结构"></a>适配器模式的结构</h3><ol><li>目标接口Target：当前系统业务所期待的接口，可以是抽象类或接口；</li><li>适配者类：是被访问和适配的现存组件库中的组件接口；</li><li>适配器类：一个转换器，通过继承或引用适配者的对象，将适配者接口转换为目标接口，让客户按目标接口的格式访问适配者。</li></ol><h2 id="适配器模式的应用场景"><a href="#适配器模式的应用场景" class="headerlink" title="适配器模式的应用场景"></a>适配器模式的应用场景</h2><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致；</li><li>使用第三方提供的组件，但组件接口定义和所需的接口定义不同。</li></ul><h2 id="适配器模式的扩展"><a href="#适配器模式的扩展" class="headerlink" title="适配器模式的扩展"></a>适配器模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8F%8C%E5%90%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="双向适配器模式"></p><p>适配器模式可扩展为<strong>双向适配器模式</strong>，既可以把适配者接口转换为目标接口，也可以把目标接口转换为适配者接口。</p><h1 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 Bridge"></a>桥接模式 Bridge</h1><p>将抽象与实现分离，使它们可以独立变化。它是用<strong>组合关系代替继承关系</strong>来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><h2 id="桥接模式的特点"><a href="#桥接模式的特点" class="headerlink" title="桥接模式的特点"></a>桥接模式的特点</h2><ul><li>优点：<ul><li>由于抽象和实现分离，所以扩展能力强；</li><li>其实现细节对客户透明。</li></ul></li><li>缺点：<ul><li>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，增加了系统的理解与设计难度。</li></ul></li></ul><h2 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h2><p>可将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p><h3 id="桥接模式的结构"><a href="#桥接模式的结构" class="headerlink" title="桥接模式的结构"></a>桥接模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="桥接模式"></p><ol><li>抽象化角色Abstraction：定义抽象类，并包含一个对实现化对象的引用；</li><li>扩展抽象化角色<code>Refined Abstraction</code>：抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法；</li><li>实现化角色Implementor：定义实现化角色的接口，供扩展抽象化角色调用；</li><li>具体实现化角色<code>Concrete Implementor</code>：给出实现化角色接口的具体实现。</li></ol><h2 id="桥接模式的应用场景"><a href="#桥接模式的应用场景" class="headerlink" title="桥接模式的应用场景"></a>桥接模式的应用场景</h2><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；</li><li>当一个系统不希望使用继承或因多层次继承导致系统类的个数急剧增加；</li><li>当一个系统需要构件的抽象化角色和具体化角色间增加更多的灵活性。</li></ul><h2 id="桥接模式的扩展"><a href="#桥接模式的扩展" class="headerlink" title="桥接模式的扩展"></a>桥接模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8FAdd%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="桥接模式Add适配者模式"></p><p>当桥接模式的实现化角色的接口与现有类的接口不一致时，通常将桥接模式和适配器模式联合使用，通过在实现化角色和现有类之间定义一个适配器将其连接起来。<br>如上图，将原有具体实现化角色/适配者进行接口转换为具体实现化角色。</p><h1 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h1><p>动态的给对象增加一些职责，即增加其额外的功能。</p><p>装饰模式，指在<strong>不改变现有对象结构</strong>的情况下，动态的给该对象增加一些职责的模式，属于对象结构型模式。<br>在软件开发过程中，有时想用一些现存的组件，这些组件可能只是完成了一些核心功能，在不改变其结构的情况下，可以动态地扩展其功能。</p><h2 id="装饰模式的特点"><a href="#装饰模式的特点" class="headerlink" title="装饰模式的特点"></a>装饰模式的特点</h2><ul><li>优点：<ul><li>采用装饰模式扩展对象的功能比采用继承方式更加灵活；</li><li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li></ul></li><li>缺点：<ul><li>装饰模式增加了许多子类，过度使用会使程序变得很复杂。</li></ul></li></ul><h2 id="装饰模式的结构与实现"><a href="#装饰模式的结构与实现" class="headerlink" title="装饰模式的结构与实现"></a>装饰模式的结构与实现</h2><p>通常情况下，扩展一个类的功能会使用继承方式来实现，但<strong>继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会膨胀</strong>。<br>如果使用组合关系来创建一个包装对象(即装饰对象)来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</p><h3 id="装饰模式的结构"><a href="#装饰模式的结构" class="headerlink" title="装饰模式的结构"></a>装饰模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.png" alt="装饰模式"></p><ol><li>抽象构件角色Component：定义一个抽象接口以规范准备接收附加责任的对象；</li><li>具体构件角色<code>Concrete Component</code>：实现抽象构件，通过装饰角色为其添加一些职责；</li><li>抽象装饰角色Decorator：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能；</li><li>具体装饰角色<code>Concrete Decorator</code>：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ol><h2 id="装饰模式的应用场景"><a href="#装饰模式的应用场景" class="headerlink" title="装饰模式的应用场景"></a>装饰模式的应用场景</h2><ul><li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时，如该类被隐藏或该类时终极类或采用继承方式会产生大量子类；</li><li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系难以实现；</li><li>当对象的功能要求可以动态添加，也能动态的撤销时。</li></ul><p>装饰功能在Java中最著名的应用：Java I/O标准库的设计。<br>如，InputStream的子类FilterInputStream、OutputStream的子类FilterOutputStream、Reader的子类BufferedReader和FilterReader、Writer的子类BufferedWriter和FilterWriter及PrintWriter等，都是抽象装饰类。</p><h2 id="装饰模式的扩展（简化）"><a href="#装饰模式的扩展（简化）" class="headerlink" title="装饰模式的扩展（简化）"></a>装饰模式的扩展（简化）</h2><ul><li>只有一个具体构件，没有抽象构件时，可让抽象装饰继承具体构件；</li><li>只有一个具体装饰时，可将抽象装饰和具体装饰合并。</li></ul><h1 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h1><p>为多个复杂的子系统提供一个<strong>一致的接口</strong>，使这些子系统更加容易被访问。</p><h1 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h1><p>运用共享技术来有效地支持大量细粒度对象的复用。</p><h1 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h1><p>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p><h1 id="模版方法模式-Template-Method"><a href="#模版方法模式-Template-Method" class="headerlink" title="模版方法模式 Template Method"></a>模版方法模式 Template Method</h1><p>定义一个操作中的<strong>算法骨架</strong>，将算法的一些<strong>步骤延迟到子类</strong>中，使子类可以不改变该算法结构的情况下重新定义该算法的某些特定步骤。</p><h1 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h1><p>定义一系列算法，并对每个算法进行封装，使其可以相互替换，且算法的改变不会影响使用算法的客户。</p><h1 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h1><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。</p><h1 id="职责链模式-Chain-of-Responsibility"><a href="#职责链模式-Chain-of-Responsibility" class="headerlink" title="职责链模式 Chain of Responsibility"></a>职责链模式 Chain of Responsibility</h1><p>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方法去除对象间的耦合。</p><h1 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h1><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p><h1 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h1><p>多个对象间存在一对多关系，当一个对象发生改变时，<strong>把这种改变通知给其它多个对象</strong>，从而影响其它对象的行为。</p><p>观察者模式，又称<strong>发布-订阅模式、模型-视图模式</strong>，指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知，并被自动更新。</p><p>观察者模式是一种<strong>对象行为型</strong>模式，具有如下特点：</p><ol><li>优点：<ol><li>降低了目标与观察者之间的耦合关系，两者之间是<strong>抽象耦合关系</strong>；</li><li>目标与观察者之间建立了一套触发机制。</li></ol></li><li>缺点：<ol><li>目标与观察者之间的<strong>依赖关系</strong>并没有完全接触，而且有可能出现<strong>循环引用</strong>；</li><li>当观察者对象较多时，通知的发布会花费很多时间，影响程序效率。</li></ol></li></ol><h2 id="观察者模式的结构与实现"><a href="#观察者模式的结构与实现" class="headerlink" title="观察者模式的结构与实现"></a>观察者模式的结构与实现</h2><p><strong>具体目标对象和具体观察者对象间不能直接调用</strong>，否则会将两者紧密耦合，违反OOP设计原则。</p><h3 id="观察者的结构："><a href="#观察者的结构：" class="headerlink" title="观察者的结构："></a>观察者的结构：</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="观察者模式结构图"></p><ol><li>抽象主题角色Subject：也称抽象目标类，提供了一个用于<strong>保存观察者对象的聚集类</strong>和<strong>增加、删除观察者对象的方法</strong>，以及<strong>通知所有观察者的抽象方法</strong>。</li><li>具体主题角色<code>Concrete Subject</code>：，也称具体目标类，<strong>实现抽象目标中的通知方法</strong>，当具体主题的内部状态发生改变时，<strong>通知所有注册过的观察者对象</strong>。</li><li>抽象观察者角色Observer：一个抽象类/接口，包含了一个<strong>更新自己的抽象方法</strong>，当接到具体主题的更改通知时被调用。</li><li>具体观察者角色<code>Concrete Observer</code>：实现抽象观察者中定义的抽象方法，以便在<strong>得到目标的改变通知时更新自身的状态</strong>。</li></ol><h3 id="事件监听处理"><a href="#事件监听处理" class="headerlink" title="事件监听处理"></a>事件监听处理</h3><p>观察者模式在软件开发中用的最多的是<strong>窗体程序设计中的事件处理</strong>，<strong>窗体中的所有组件都是事件源，即目标对象</strong>，而<strong>事件处理程序类的对象是具体观察者对象</strong>。</p><h2 id="观察者模式应用场景"><a href="#观察者模式应用场景" class="headerlink" title="观察者模式应用场景"></a>观察者模式应用场景</h2><ul><li>对象间存在一对多的关系，一个对象的状态改变发生会影响其它对象。</li><li>当一个抽象模型有两方面，一方面依赖于另一方面时，可将二者封装在独立的对象中以使其可以各自独立的改变和复用。</li></ul><h2 id="观察者模式扩展"><a href="#观察者模式扩展" class="headerlink" title="观察者模式扩展"></a>观察者模式扩展</h2><p>Java中，通过<code>java.util.Observable</code>类和<code>java.util.Observer</code>接口定义了观察者模式，只要实现其子类即可编写观察者模式实例。</p><h3 id="Observable类"><a href="#Observable类" class="headerlink" title="Observable类"></a>Observable类</h3><p>Observable类是抽象目标类，有一个Vector向量，用于保存所有要通知的观察者对象。</p><ol><li><code>void addObserver(Observer o)</code>方法：用于将新的观察者添加到向量中；</li><li><code>void notifyObservers(Object arg)</code>方法：调用向量中的所有观察者对象的update方法，通知它们数据发生改变，通常越晚加入向量的观察者越先得到通知；</li><li><code>void setChange()</code>方法：用来设置一个boolean类型的内部标识位，注明目标对象发生类变化，当为真时，notifyObservers()才会通知观察者。</li></ol><h3 id="Observer接口"><a href="#Observer接口" class="headerlink" title="Observer接口"></a>Observer接口</h3><p>Observer接口是抽象观察者，监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用<code>void update(Observable o, Object arg)</code>方法执行更新。</p><h1 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 Mediator"></a>中介者模式 Mediator</h1><p>定义一个中介对象来简化原有对象间的交互关系，降低系统对象间的耦合度，使原有对象间不必相互了解。</p><h1 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h1><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p><h1 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式 Visitor"></a>访问者模式 Visitor</h1><p>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</p><h1 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式 Memento"></a>备忘录模式 Memento</h1><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便日后恢复它。</p><h1 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式 Interpreter"></a>解释器模式 Interpreter</h1><p>提供如何定义语言的文法，以及对语言橘子的解释方法，即解释器。</p><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://c.biancheng.net/view/1317.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1317.html</a></li><li><a href="https://www.jianshu.com/p/4475b2e1f9ae" target="_blank" rel="noopener">https://www.jianshu.com/p/4475b2e1f9ae</a></li></ul>]]></content>
    
    <summary type="html">
    
      设计模式Design Pattern是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，是一套可用来提高代码可复用性、可维护性、可读性、稳健型及安全性的解决方案。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>线程&amp;进程</title>
    <link href="http://zhangzongyu00.github.io/2020/07/07/%E7%BA%BF%E7%A8%8BVS%E8%BF%9B%E7%A8%8B/"/>
    <id>http://zhangzongyu00.github.io/2020/07/07/%E7%BA%BF%E7%A8%8BVS%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-07-07T11:55:48.000Z</published>
    <updated>2020-07-10T17:19:10.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程、协程"><a href="#进程与线程、协程" class="headerlink" title="进程与线程、协程"></a>进程与线程、协程</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%BC%AB%E7%94%BB.jpg" alt="进程和线程漫画"></p><h2 id="进程：最小资源管理单元"><a href="#进程：最小资源管理单元" class="headerlink" title="进程：最小资源管理单元"></a>进程：最小资源管理单元</h2><p>CPU处理器运行程序(一系列指令)，随后，为方便多任务处理，进行多任务分配，即进程。<br>操作系统为了执行进程间的切换，会维护着一张进程表ProcessTable，每个进程占用一个进程表项。</p><p>进程存放：</p><ul><li>地址空间(存放程序正文和数据等，包括下列所述)；</li><li>全局变量；</li><li>打开文件；</li><li>子进程；</li><li>即将发生的定时器；</li><li>信号和信号处理程序；</li><li>账号信息；</li></ul><ul><li>进程位于内核空间中，可被系统调用；</li><li>进程是基于时钟进行中断的；</li><li>一个进程的内存空间和其它资源共享，即父进程调用子进程时内存空间共享；</li><li>多个进程共享物理内存、磁盘、打印机和其它资源。</li></ul><p>创建进程：</p><ol><li>系统初始化init；</li><li>正在运行的程序执行创建进程的系统调用fork；</li><li>用户请求创建一个新建成(如打开app)；</li><li>初始化一个批处理工作。</li></ol><p><em>父进程和子进程具有相同的内存映像等基本环境<code>copy-on-write</code>，但是其内存地址不同。</em></p><p>退出进程：</p><ol><li>正常退出；</li><li>错误退出；</li><li>严重错误，这里指app自行处理错误，不交给系统；</li><li>被其它进程杀死kill。</li></ol><p>进程的状态：</p><ul><li>运行态，进程实际占用CPU时间片运行时；</li><li>就绪态，可运行，但因其它进程正在运行而处于就绪状态；</li><li>阻塞态，除非某种外部事件发生，否则进程不能运行pause。</li></ul><p>进程的状态切换：<br>  <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png" alt="进程状态切换"></p><ul><li>进程因为等待输入而阻塞；</li><li>调度程序选择另一个进程；</li><li>调度程序选择一个进程开始运行；</li><li>出现有效的输入。</li></ul><p>中断处理和调度过程：</p><ol><li>硬件压入堆栈程序计数器等；</li><li>硬件从中断向量(与IO类相关联)装入新的程序计数器；</li><li>汇编语言过程保存寄存器的值；</li><li>汇编语言过程设置新的堆栈；</li><li>C中断服务器运行（典型的读和缓存写入）；</li><li>调度器决定下面那个程序先运行；</li><li>C过程返回至汇编代码；</li><li>汇编语言过程开始新的当前进程。</li></ol><h2 id="线程：最小执行单元"><a href="#线程：最小执行单元" class="headerlink" title="线程：最小执行单元"></a>线程：最小执行单元</h2><p>类似于“车间中的工人”，用于协同完成一个进程任务。<br>线程是CPU上执行调度的实体。</p><p>线程存放：</p><ul><li>程序计数器，用来记录要执行哪条指令；</li><li>寄存器，保存线程当前正在使用的变量；</li><li>堆栈，记录程序的执行路径；</li><li>线程状态。</li></ul><ul><li>线程可位于内核空间，也可位于用户空间(抢占式调度)；</li><li>内核空间的线程也是基于时钟中断的，用户空间中的线程无法利用时钟中断强行让线程让出CPU；</li><li>用户空间中的同一进程中的所有线程拥有完全一致的地址空间，可共享同样的全局变量；</li><li>用户空间中的线程可以读取、写入、擦除另一个线程的堆栈；</li></ul><p>线程的实现：</p><ul><li>在用户空间实现线程，允许进程定制程序调度算法，效率高(不需切换到内核，不需上下文切换，不需对内存高速缓存进行刷新)；</li><li>在内核空间中实现线程，能够对线程进行阻塞调用，可避免缺页中断问题，能够使用轮转调度方式调度线程；</li><li>在用户和内核空间中混合实现线程：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%94%A8%E6%88%B7_%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="用户_内核线程多路复用"><ul><li>程序员可以自由控制用户线程和内核线程的数量；</li><li>内核只识别内核级线程，并对其进行调度；</li><li>内核级线程会被过个用户级线程多路复用。</li></ul><em>线程创建后，通常返回一个线程标识符，该标识符为新线程的name。</em></li></ul><p>线程的状态及转换：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p><p>线程的优势：</p><ul><li>多线程间共享同一块地址空间和所有可用数据的能力；</li><li>线程比进程更<strong>轻量级</strong>，比进程更容易创建和销毁，可快10-100倍；</li><li>若多个线程都是CPU密集型的，不能获得性能上的增强；</li><li>如果存在大量的计算和IO处理，拥有多线程能彼此重叠进行，会加快app的执行速度。</li></ul><h3 id="多线程的web服务器"><a href="#多线程的web服务器" class="headerlink" title="多线程的web服务器"></a>多线程的web服务器</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="多线程的web服务器"></p><ol><li>调度线程从网络中读入工作请求；</li><li>在调度线程检查完请求后，选择一个空闲的/阻塞的工作线程处理请求；</li><li>将消息的指针写入每个线程关联的特殊字中；</li><li>调度线程唤醒正在睡眠中的工作线程，将工作线程的状态从阻塞态变为就绪态。</li><li>工作线程检查请求是否在web页面的高速缓存中；</li><li>若不在高速缓存中，调用一个read操作从磁盘中读取页面并阻塞线程，直到磁盘操作完成。</li></ol><p><em>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显示的保存或重新装入相应的计算状态。每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，该类设计称为有限状态机<code>finite-state machine</code>。</em></p><table><thead><tr><th align="center">模型</th><th align="center">特性</th></tr></thead><tbody><tr><td align="center">单线程</td><td align="center">无并行性，性能较差，阻塞系统调用</td></tr><tr><td align="center">多线程</td><td align="center">并行性，阻塞系统调用</td></tr><tr><td align="center">有限状态机</td><td align="center">并行性，非阻塞系统调用、中断</td></tr></tbody></table><h3 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h3><p>为了使编写可移植线程程序成为可能，IEEE在IEEE标准1003.1c中定义了线程标准。线程包被定义为Pthreads。</p><p>POSIX线程/pthreads是一种独立于语言而存在的执行模型，以及并行执行模型。它允许程序控制时间上重叠多个不同的工作流程/线程。</p><h2 id="协程co-routine-纤程fiber"><a href="#协程co-routine-纤程fiber" class="headerlink" title="协程co-routine/纤程fiber"></a>协程co-routine/纤程fiber</h2><p>一个线程可拥有多个协程(串行)，由程序控制，在用户态执行。</p><ul><li>协程位于用户空间，进行的是非抢占式调度；</li><li>适用于事件驱动的编程。</li></ul><p>协程是一个特殊的函数，该函数可在某个地方挂起，并且可以重新在挂起处继续运行。</p><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池，即创建一些线程，它们的集合就称为线程池。使用线程池可以很好的提高性能，线程池在<strong>系统启动时即创建</strong>大量空闲的线程。<br>程序将一个任务传给线程池，线程池就会启动一个任务传给线程池，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p><p>线程池的<strong>工作机制：</strong></p><ul><li>在线程池的编程模式下，任务是提交给线程池，而不是直接提交给某个线程；</li><li>线程池在拿到任务后，就在内部寻找是否有空闲的进程，如果有，则将任务交给某个空闲的线程；</li><li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</li></ul><p>ExecutorService是Java提供的用于管理线程池的类，该类的两个作用：控制线程数量、重用线程。</p><p>线程池的<strong>实现</strong>：</p><ul><li>Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没之前建立的线程，有就直接使用，没有就建一个新的线程加入池中；缓存型池子通常用于执行一些生存期很短的异步型任务。</li><li>Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行该线程。</li><li>Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行。</li><li>Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO、LIFO、优先级)执行。</li></ul><p>定长线程池的大小最好根据系统资源进行设置，如Runtime.getRuntime().availableProcessors()。</p><p>线程池的优势：</p><ul><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li><li>方便线程并发数的管控，因为线程无限制的创建，可能会导致内存占用过多而产生内存溢出OOM，并会造成CPU过度切换；</li><li>可延时定时线程池。</li></ul><h2 id="自定义线程池：ThreadPoolExecutor和BlockingQueue连用"><a href="#自定义线程池：ThreadPoolExecutor和BlockingQueue连用" class="headerlink" title="自定义线程池：ThreadPoolExecutor和BlockingQueue连用"></a>自定义线程池：ThreadPoolExecutor和BlockingQueue连用</h2><p>自定义线程池，可使用ThreadPoolExecutor类创建，通过其构造方法来创建线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">- corePoolSize：线程池基本大小，当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize。除了利用提交新任务来创建和启动线程（按需构造），也可通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。</span><br><span class="line">- maximumPoolSize：线程池最大大小，线程池所允许的最大线程个数。当队列已满，且已创建的线程数小于maximumPoolSize，线程池会创建新的线程来执行任务。但对于无界队列，可忽略该参数。</span><br><span class="line">- keepAliveTime：线程存活保持时间，当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</span><br><span class="line">- workQueue：任务队列，用于传输和保存等待执行任务的阻塞队列。</span><br><span class="line">- threadFactory：线程工厂，用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</span><br><span class="line">- handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</span><br><span class="line">*&#x2F;</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池使用BlockingQueue原因：</strong></p><ul><li>阻塞队列可保证任务队列中没有任务时，阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源；</li><li>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行，使线程不至于一直占用cpu资源；</li></ul><p>  <em>线程执行完成任务后通过循环再次从任务中取出任务进行执行：<code>while (task != null || (task = getTask()) != null) {}</code></em></p><h2 id="缓冲队列-BlockingQueue"><a href="#缓冲队列-BlockingQueue" class="headerlink" title="缓冲队列 BlockingQueue"></a>缓冲队列 BlockingQueue</h2><p>BlockingQueue是双缓冲队列，其内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。<br>在保证并发安全的同时，提高了队列的存取效率。</p><ul><li>ArrayBlockingQueue(int i)：规定大小的BlockingQueue，其构造必须指定大小，其所含对象是FIFO顺序排列；</li><li>LinkedBlockingQueue()：大小不固定，其构造时可指定大小，不指定时由Integer.MAX_VALUE决定，其所含对象是FIFO顺序排列</li><li>PriorityBlockingQueue()：大小不固定，其构造时可指定大小，不指定时由Integer.MAX_VALUE决定，其所含对象由对象的自然顺序或构造函数的Comparator决定；</li><li>SynchronizedQueue()：特殊的BlockingQueue，对其操作必须时放和取交替完成。</li></ul><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384</a></li><li><a href="https://www.cnblogs.com/jiawen010/p/11855768.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiawen010/p/11855768.html</a></li><li><a href="https://www.jianshu.com/p/7726c70cdc40" target="_blank" rel="noopener">https://www.jianshu.com/p/7726c70cdc40</a></li></ul>]]></content>
    
    <summary type="html">
    
      操作系统最底层的就是调度程序，在此上面有很多进程。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>图像分类问题</title>
    <link href="http://zhangzongyu00.github.io/2020/07/05/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangzongyu00.github.io/2020/07/05/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-04T17:24:32.000Z</published>
    <updated>2020-07-09T17:23:51.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNN网络进化-结构演化"><a href="#CNN网络进化-结构演化" class="headerlink" title="CNN网络进化/结构演化"></a>CNN网络进化/结构演化</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CNN%E7%BB%93%E6%9E%84%E6%BC%94%E5%8C%96.png" alt="CNN结构演化"></p><p>AlexNet -&gt; VGG -&gt; GoogleNet -&gt; ResNet;</p><h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p><em>ImageNet-2012竞赛No.1，标志着DNN深度学习革命的开始。</em></p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/AlexNet.png" alt="AlexNet"></p><ul><li>使用了5个卷积层，3个全连接层；</li><li>使用了ReLu非线性激活；</li><li>进行<code>Max pooling</code>池化；</li><li>使用了Dropout regularization；</li><li>局部响应归一化LRN（被抛弃）；</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Alexnet%E7%BB%93%E6%9E%84.png" alt="Alexnet结构"></p><p>结构分解：</p><ol><li>输入层：224<em>224</em>3；</li><li>卷积层1：96<em>11<em>11</em>3，ReLU-&gt;MP-&gt;LRN；<em>tip：2个GPU\</em>48个卷积核，卷积核大小11*11，3通道。</em></li><li>卷积层2：256<em>5</em>5*48，ReLU-&gt;MP-&gt;LRN；</li><li>卷积层3：384<em>3</em>3*256，ReLU；</li><li>卷积层4：384<em>3</em>3*192，ReLU-&gt;MP；</li><li>卷积层5：256<em>3</em>3*192，ReLU；</li><li>全连接层1：4096，ReLu；</li><li>全连接层2：4096，ReLu；</li><li>全连接层3：1000，ReLu-&gt;MP；</li><li>Softmax层：1000；</li><li>Loss：$arg max_w{ \frac{1}{N} \sum -log(p(f(x,w)=y(x))) }$标签概率的log值的和。</li></ol><h2 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h2><p>优点：</p><ul><li>结构简单；</li><li>容易修改，迁移到其他任务中；</li><li>高层任务的基础网络；</li></ul><h2 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h2><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><h2 id="ImageNet数据集"><a href="#ImageNet数据集" class="headerlink" title="ImageNet数据集"></a><a href="http://image-net.org/" target="_blank" rel="noopener">ImageNet数据集</a></h2><p>根据WordNet组织的图片集，为一个名词提供平均1000张图片。</p><h2 id="MIT的数据集"><a href="#MIT的数据集" class="headerlink" title="MIT的数据集"></a>MIT的数据集</h2><p>Places2数据集</p><h2 id="CIFAR-10数据集"><a href="#CIFAR-10数据集" class="headerlink" title="CIFAR-10数据集"></a>CIFAR-10数据集</h2><p>共有6w张彩色图像，分辨率为32*32，分为10类，每类6k张图。</p><p>其中，</p><ul><li>5w张用于训练，构成5个epoch，每个epoch1w张；</li><li>1w张用于测试，单独为1批；</li><li>测试批中的数据，每类中抽取1k张。</li></ul><p>参考：</p><ul><li><a href="http://image-net.org/challenges/LSVRC/2017/" target="_blank" rel="noopener">http://image-net.org/challenges/LSVRC/2017/</a></li><li><a href="https://www.pianshen.com/article/2717286724/" target="_blank" rel="noopener">https://www.pianshen.com/article/2717286724/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CNN网络进化-结构演化&quot;&gt;&lt;a href=&quot;#CNN网络进化-结构演化&quot; class=&quot;headerlink&quot; title=&quot;CNN网络进化/结构演化&quot;&gt;&lt;/a&gt;CNN网络进化/结构演化&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsd
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>图论</title>
    <link href="http://zhangzongyu00.github.io/2020/07/01/%E5%9B%BE%E8%AE%BA/"/>
    <id>http://zhangzongyu00.github.io/2020/07/01/%E5%9B%BE%E8%AE%BA/</id>
    <published>2020-07-01T08:56:24.000Z</published>
    <updated>2020-07-01T09:04:05.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度优先遍历DFS"><a href="#深度优先遍历DFS" class="headerlink" title="深度优先遍历DFS"></a>深度优先遍历DFS</h1><p>思想：</p><ol><li>找一个未被访问过的顶点作为起始顶点，沿着当前顶点的边走到未访问过的顶点；</li><li>当没有找到未访问过的结点时，回到上一个顶点，继续寻找未访问结点；</li><li>直到所有顶点都被访问。</li></ol><h1 id="广度优先遍历BFS"><a href="#广度优先遍历BFS" class="headerlink" title="广度优先遍历BFS"></a>广度优先遍历BFS</h1><p>思想：类似于树的层次遍历</p><ol><li>找一个未被访问过的顶点作为起始顶点；</li><li>找到顶点的所有的邻接点，放入队列中；</li><li>从队列中依次取出结点，查找该结点的所有未被访问过的邻接点，存放到队列中；</li><li>直到队列为空。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度优先遍历DFS&quot;&gt;&lt;a href=&quot;#深度优先遍历DFS&quot; class=&quot;headerlink&quot; title=&quot;深度优先遍历DFS&quot;&gt;&lt;/a&gt;深度优先遍历DFS&lt;/h1&gt;&lt;p&gt;思想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找一个未被访问过的顶点作为起始顶点，沿着当前顶点的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>swift</title>
    <link href="http://zhangzongyu00.github.io/2020/06/30/swift/"/>
    <id>http://zhangzongyu00.github.io/2020/06/30/swift/</id>
    <published>2020-06-29T20:20:42.000Z</published>
    <updated>2020-07-18T06:59:01.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h1><p><em>所见及所得，可快速查看语法更改</em></p><h1 id="Cocoa框架"><a href="#Cocoa框架" class="headerlink" title="Cocoa框架"></a>Cocoa框架</h1><p>Cocoa是<code>OS X</code>和<code>ios</code>操作系统的程序的运行环境。</p><p>Cocoa拥有众多框架：Application、<strong>UIKit</strong>、Cocoa Touch、Media、Core Services/<strong>Foundation</strong>、Core OS。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Cocoa.png" alt="Cocoa"></p><p>Foundation框架：</p><h1 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h1><h2 id="SandBox"><a href="#SandBox" class="headerlink" title="SandBox"></a>SandBox</h2><p>ios中的沙盒机制是一种安全体系。每个app都有一个单独的文件系统/存储空间，而且只能在对应的文件系统中进行操作，即沙盒。所有的非代码文件（资源文件等）都保存在此。</p><p>沙盒包含的目录：</p><ul><li>/AppName.app<ul><li>应用程序的程序包目录；</li><li>由于应用程序必须经过<strong>签名</strong>，所以不能在运行时对这个目录中的内容进行修改，否则会导致应用程序无法启动。</li></ul></li><li>/Documents/<ul><li>保存<strong>应用程序的重要数据文件和用户数据文件</strong>等；</li><li>iTunes<strong>同步</strong>时会<strong>备份</strong>该目录。</li></ul></li><li>/Library/Caches<ul><li>保存应用程序使用时产生的支持文件和缓存文件，还有日志文件最好也放在这个目录；</li><li>iTunes同步时<strong>不备份</strong>该目录。</li></ul></li><li>/Library/Preferences<ul><li>保存应用程序的偏好设置文件；</li><li>使用<code>NSUserDefaults</code>类设置时创建，不应手动创建。</li></ul></li><li>/tmp/<ul><li>保存应用运行时所需要的临时数据；</li><li>iphone<strong>重启时会清空</strong>该目录下所有文件。</li></ul></li></ul><p>查询app沙盒路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在项目中执行代码打印获取</span><br><span class="line">let homeDir &#x3D; NSHomeDirectory() as Stringprintln(homeDir)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1、获取沙盒根目录</span><br><span class="line">let homeDir &#x3D; NSHomeDirectory() as String</span><br><span class="line">&#x2F;&#x2F; 2、获取 Documents 目录</span><br><span class="line">let docDirs &#x3D; NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true) as NSArraylet docDir &#x3D; docDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 3、获取 Caches 目录</span><br><span class="line">let cachesDirs &#x3D; NSSearchPathForDirectoriesInDomains(.CachesDirectory, .UserDomainMask, true) as NSArraylet cachesDir &#x3D; cachesDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 4、获取 Library 目录</span><br><span class="line">let libDirs &#x3D; NSSearchPathForDirectoriesInDomains(.LibraryDirectory, .UserDomainMask, true) as NSArraylet libDir &#x3D; libDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 5、获取 tmp 目录</span><br><span class="line">let tmpDir &#x3D; NSTemporaryDirectory() as String</span><br></pre></td></tr></table></figure><h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><p>通过<code>fileManager</code>对沙盒中的目录/文件进行操作。</p><h3 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h3><p>app都是通过<code>bundle</code>进行封装的，可以将<code>bundle</code>理解为上述沙盒中的<code>AppName.app</code>文件。</p><p>在<code>Finder</code>中，会把<code>bundle</code>当做文件显示，防止用户误操作，但其内部是一个目录，包含图像、媒体资源、编译的代码、nib文件等，这个目录称为<code>main bundle</code>。</p><p><code>Cocaoa</code>提供了<code>NSBundle类</code>封装了<code>bundle</code>操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取应用程序的 main bundle</span><br><span class="line">var mainBundle &#x3D; NSBundle.mainBundle()</span><br><span class="line">&#x2F;&#x2F; 使用 main bundle 获取资源路径</span><br><span class="line">var testFilePath &#x3D; mainBundle.pathForResource(&quot;logo&quot;, ofType: &quot;png&quot;)</span><br></pre></td></tr></table></figure><h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><h2 id="KVC设值"><a href="#KVC设值" class="headerlink" title="KVC设值"></a>KVC设值</h2><p>通过对象中对应的key，KVC在内部寻找key，并调用<code>setValue:属性值forKey:@&quot;name&quot;</code>，底层执行机制为：</p><ol><li>程序优先调用<code>set&lt;Key&gt;:属性值</code>方法，代码通过setter方法完成设置。*<key>指成员变量名，首字母大小写要符合KVC命名规则。*</li><li>若没有找到<code>setName:</code>方法，<ol><li>KVC机制会检查<code>+(BOOL)accessInstanceVariablesDirectly</code>方法有没有返回YES，默认返回YES；</li><li>若重写该方法返回NO，会执行<code>setValue:forUndefinedKey</code>方法，一般不会这么做，当找不到时，会直接执行第4步。</li><li>KVC机制会搜索该类中名为<key>的成员变量，无论该变量是在类接口处定义，还是在类实现处定义，无论使用怎样的访问修饰符，只要存在以<key>命名的变量，KVC都可对该成员变量赋值。</li></ol></li><li>若该类既没有<code>set&lt;key&gt;:</code>方法，也没有<code>_&lt;key&gt;</code>和<code>_is&lt;key&gt;</code>成员变量，KVC机制会搜索<code>&lt;key&gt;</code>和<code>is&lt;key&gt;</code>的成员变量，并赋值。</li><li>如果方法或成员变量都不存在，系统将会执行该对象的<code>setValue:forUndefinedKey:</code>方法，默认为抛出异常。</li></ol><h2 id="KVC取值"><a href="#KVC取值" class="headerlink" title="KVC取值"></a>KVC取值</h2><p>当调用<code>valueForKey:@&quot;name&quot;</code>时，KVC对key的搜索方式不同于<code>setValue:属性值forKey:@&quot;name&quot;</code>，其搜索方式为：</p><ol><li>首先，按<code>get&lt;key&gt;,&lt;key&gt;,is&lt;key&gt;</code>的顺序方法查找getter方法，找到就直接调用；如果是BOOL或Int等值类型，会将其包装成一个NSNumber对象。</li><li>如果getter没有找到，KVC会查找<code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes</code>格式的方法；<ol><li>如果<code>countOf&lt;Key&gt;</code>和另外两个方法中的一个，那么就会返回一个可以响应NSArray所有方法的代理集合(NSkeyValueArray，是NSArray的子类)；</li><li>调用该代理集合的方法，或给该代理发送属于NSArray的方法，就会以<code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes</code>方法组合的形式调用；</li><li>可选方法<code>get&lt;Key&gt;:range:</code>。</li></ol></li><li>若没有找到，会同时查找<code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;, memberOf&lt;Key&gt;</code>格式的方法；<ol><li>如果找到这三个方法，则返回一个可响应NSSet所有方法的代理集合；</li><li>给该代理集合发送NSSet的消息，就会以<code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;, memberOf&lt;Key&gt;</code>组合的形式调用。</li></ol></li><li>若还没找到，检查类方法<code>+(BOOL)accessInstanceVariablesDirectly</code>；<ol><li>若返回YES（默认），按照<code>_&lt;Key&gt;, _is&lt;Key&gt;, &lt;Key&gt;, is&lt;Key&gt;</code>的顺序搜索成员变量名；</li><li>如重写了类方法<code>+(BOOL)accessInstanceVariablesDirectly</code>，返回NO，便直接调用<code>valueForUndefinedKey:</code>方法，默认抛出异常。</li></ol></li></ol><h2 id="KVC处理数值和结构体类型属性"><a href="#KVC处理数值和结构体类型属性" class="headerlink" title="KVC处理数值和结构体类型属性"></a>KVC处理数值和结构体类型属性</h2><p><code>valueForKey:</code>总是返回一个🆔对象，若原本变量类型为值类型或结构体，返回值会封装成NSNumber或NSValue对象。<br><code>setValue:forKey:</code>需要手动将值类型转换为NSNumber或NSValue类型。</p><p>因为传递进去和取出来的都是id类型，所以需要开发者自己担保类型的正确性，运行时Objective-C在发送消息时会检查类型，如果错误会直接抛出异常。</p><h2 id="KVC处理集合"><a href="#KVC处理集合" class="headerlink" title="KVC处理集合"></a>KVC处理集合</h2><p>简单集合运算符：@avg，@count，@max，@min，@sum。<br>对象运算符：能以数组的方式返回指定的内容。</p><ul><li><code>@distinctUnionOfObjects</code>：返回元素唯一，类似Set；</li><li><code>@unionOfObjects</code>：返回全部元素。</li></ul><h2 id="KVC处理字典"><a href="#KVC处理字典" class="headerlink" title="KVC处理字典"></a>KVC处理字典</h2><p>当对NSDictionary对象使用KVC时，<code>valueForKey:</code>表现行为和<code>objectForKey:</code>一样，常使用<code>valueForKeyPath:</code>来访问多层嵌套的字典。</p><p><code>dictionaryWithValuesForKeys:</code>指输入一组key，返回这组key对应的属性，再组成一个字典。<br><code>setValuesForKeysWithDictionary</code>用来修改Model中对应key的属性。</p><h2 id="KVC处理异常"><a href="#KVC处理异常" class="headerlink" title="KVC处理异常"></a>KVC处理异常</h2><p>KVC处理nil异常：重写<code>setNilValueForKey:</code>方法。</p><p>KVC处理UndefinedKey异常：重写<code>forUndefinedKey</code>方法。</p><h2 id="KVC使用场景"><a href="#KVC使用场景" class="headerlink" title="KVC使用场景"></a>KVC使用场景</h2><ul><li>动态地取值和设值；</li><li>访问和修改私有变量；</li><li>Model和字典转换：通常和runtime组合使用；</li><li>修改部分控件的内部属性；</li><li>操作集合：<code>valueForKey:</code>方法的特殊实现，如NSArray和NSSet容器类；</li><li>实现高阶消息传递<code>valueForKey:</code>传递给容器的每一个对象，结果添加到返回的容器中；</li></ul><h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p><code>Key-Value Observing</code>，键值观察，是基于KVC实现的，是一种<strong>观察者模式的衍生</strong>。</p><p><strong>基本思想：</strong>对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的KVO接口方法，自动的通知观察者。</p><p>KVO可以通过监听key，来获得value的变化，用来在对象之间监听状态变化。<br>KVO的原理是修改被观察者的setter方法。<br>KVO的定义都是对NSObject的扩展来实现的，OC中有个显式的NSKeyValueObserving类别名，对于所有继承NSObject的类型，都可使用KVO。</p><p>KVO中，观察者和被观察者的改变发生在<strong>同一线程</strong>上，需要确保线程安全。</p><h2 id="注册与解除注册"><a href="#注册与解除注册" class="headerlink" title="注册与解除注册"></a>注册与解除注册</h2><p>若已经拥有可供键值观察属性的类，即可通过在该类的对象(被观察对象)上调用名为NSKeyValueObserverRegistration的category方法将观察者对象与被观察者对象注册与解除注册。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>observer:观察者，也就是KVO通知的订阅者；</li><li>observeValueForKeyPath:ofObject:change:context:方法；</li><li>keyPath：描述将要观察的属性，相对于被观察者；</li><li>options：KVO的一些属性配置；<ul><li>NSKeyValueObservingOptionNew：change字典包括改变后的值；</li><li>NSKeyValueObservingOptionOld:change字典包括改变前的值；</li><li>NSKeyValueObservingOptionInitial:注册后立刻触发KVO通知；</li><li>NSKeyValueObservingOptionPrior:值改变前是否也要通知（这个key决定了是否在改变前改变后通知两次）</li></ul></li><li>context: 上下文，传递到订阅者的函数中，用来区分消息。</li></ul><p>系统通过重写dealloc方法来<strong>释放资源</strong>。</p><h2 id="KVO实现"><a href="#KVO实现" class="headerlink" title="KVO实现"></a>KVO实现</h2><p>KVO是通过<code>isa-swizzling</code>实现的，基本流程为：</p><ul><li>编译器自动为被观察者对象创造一个派生类，并将被观察对象的isa指向该派生类；</li><li>若用户注册了对此目标对象的某一个属性的观察，派生类会重写该方法(只重写注册观察者的属性方法)，并在其中添加通知对象；</li><li>OC在发送消息时，通过isa指针找到当前对象所属的类对象，类对象中保存着当前对象的实例方法，因此向此对象发送消息，实际上是发送到了派生类对象的方法；</li><li>由于编译器对派生类的方法进行了override，并添加了通知对象，因此会向注册的对象发送通知。</li></ul><h2 id="手动KVO"><a href="#手动KVO" class="headerlink" title="手动KVO"></a>手动KVO</h2><ul><li><code>- (void)willChangeValueForKey:(NSString *)key;</code>：将要发生改变；</li><li><code>- (void)didChangeValueForKey:(NSString *)key;</code>：已经发生改变；<br>在不用的时候，一定要<strong>解除注册</strong>，否则会导致内存泄漏。</li></ul><p>每当监听的keyPath发生变化，就会在<code>-(void)observeValueForKeyPath:</code>函数中进行回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context</span><br></pre></td></tr></table></figure><p><em>键值观察依赖键</em></p><h2 id="禁用KVO"><a href="#禁用KVO" class="headerlink" title="禁用KVO"></a>禁用KVO</h2><p>实现类方法<code>automaticallyNotifiesObserversForKey</code>返回NO，实现属性的setter方法，不调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>在swift中有专门的指针类型，均被定义为<strong>unsafe</strong>：</p><ul><li><code>UnsafePointer&lt;Pointee&gt;</code>：类似于C语言中的<code>const Pointee *</code>，只能访问内存，不能修改内存；</li><li><code>UnsafeMutablePointer&lt;Pointee&gt;</code>：类似于C语言中的<code>Pointee *</code>，可访问和修改内存；</li><li><code>UnsafeRawPointer</code>：类似于<code>const void *</code>，只读，不支持泛型；</li><li><code>UnsafeMutableRawPointer</code>：类似于void，可读可写，不支持泛型。</li></ul><p>获取变量的指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取可变的变量指针, value参数接受变量地址，取决于body闭包的返回值</span><br><span class="line">@inlinable public func withUnsafeMutablePointer&lt;T, Result&gt;(to value: inout T, _ body: (UnsafeMutablePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</span><br><span class="line">&#x2F;&#x2F; 获取不可变的变量指针, value参数接受变量，取决于body闭包的返回值</span><br><span class="line">@inlinable public func withUnsafePointer&lt;T, Result&gt;(to value: T, _ body: (UnsafePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</span><br><span class="line">&#x2F;&#x2F; 获取不可变的变量指针, value参数接受变量地址，取决于body闭包的返回值</span><br><span class="line">@inlinable public func withUnsafePointer&lt;T, Result&gt;(to value: inout T, _ body: (UnsafePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</span><br></pre></td></tr></table></figure><p>分配内存创建指针：</p><ul><li>malloc</li><li>allocate：只有<code>UnsafeMutableRawPointer</code>和<code>UnsafeMutablePointer&lt;T&gt;</code>才有此分配方法。</li></ul><p>参考：</p><ul><li><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/" target="_blank" rel="noopener">https://numbbbbb.gitbooks.io/-the-swift-programming-language-/</a></li><li><a href="https://www.cnblogs.com/zjoch/p/4702873.html" target="_blank" rel="noopener">https://www.cnblogs.com/zjoch/p/4702873.html</a></li><li><a href="https://blog.csdn.net/Listron/article/details/80197347" target="_blank" rel="noopener">https://blog.csdn.net/Listron/article/details/80197347</a></li><li><a href="https://www.jianshu.com/p/2cef1e80042c" target="_blank" rel="noopener">https://www.jianshu.com/p/2cef1e80042c</a></li><li><a href="https://www.jianshu.com/p/b9f020a8b4c9" target="_blank" rel="noopener">https://www.jianshu.com/p/b9f020a8b4c9</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;playground&quot;&gt;&lt;a href=&quot;#playground&quot; class=&quot;headerlink&quot; title=&quot;playground&quot;&gt;&lt;/a&gt;playground&lt;/h1&gt;&lt;p&gt;&lt;em&gt;所见及所得，可快速查看语法更改&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;C
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>熵</title>
    <link href="http://zhangzongyu00.github.io/2020/06/27/%E7%86%B5/"/>
    <id>http://zhangzongyu00.github.io/2020/06/27/%E7%86%B5/</id>
    <published>2020-06-27T15:17:44.000Z</published>
    <updated>2020-06-27T16:53:16.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><ul><li>假设一个样本集中有<strong>两个概率分布p、q</strong>，其中p为真实分布，q为非真实分布；</li><li>按照真实分布p来衡量识别一个样本所需要的编码长度的期望为：$$\sum_i p(i) \cdot log(\frac{1}{p(i)})$$</li><li>按照错误分布q表示来自真实分布p的平均编码长度的期望为：$$\sum_i p(i) \cdot log(\frac{1}{q(i)})$$</li><li>$H(p,q)$称之为交叉熵。</li></ul><h1 id="相对熵-KL散度"><a href="#相对熵-KL散度" class="headerlink" title="相对熵/KL散度"></a>相对熵/KL散度</h1><p>KL散度，是两个概率分布P和Q差别的非对称性的度量。</p><p>通常情况下，</p><ul><li>P表示数据的真实分布；</li><li>Q表示数据的理论分布（模型分布、P的近似分布）$D(P||Q) = \sum P(x) log \frac{P(x)}{Q(x)}$ 。</li></ul><p>KL散度<strong>不对称</strong>，不满足距离的性质，即$D_{KL}(P||Q) \neq D_{KL}(Q||P)$ 。</p><h1 id="JS散度"><a href="#JS散度" class="headerlink" title="JS散度"></a>JS散度</h1><p>JS散度，度量两个概率分布的相似度；是基于KL散度的变体，解决了KL散度非对称性的问题。</p><p>$$JS(P||Q) = \frac{1}{2} KL(P(x)||\frac{P(x)+Q(x)}{2}) + \frac{1}{2} KL(Q(x)||\frac{P(x)+Q(x)}{2})$$</p><p>KL散度具有对称性，其取值区间为[0,1]。</p>]]></content>
    
    <summary type="html">
    
      度量两个概率分布的相似度等问题。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MVVM设计模式</title>
    <link href="http://zhangzongyu00.github.io/2020/06/23/MVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangzongyu00.github.io/2020/06/23/MVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-23T10:25:39.000Z</published>
    <updated>2020-07-19T16:31:51.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/mvc.png" alt="mvc"></p><p>所有的对象都可以被归类为一个model，一个view，或一个controller。–Apple</p><ul><li>M：模型model的对象通常比较简单。<ul><li>根据Apple的文档，model应包括数据和操作数据的业务逻辑；</li><li>在实际中，model层往往非常薄；</li><li>model层的业务逻辑不应被拖入到controller；</li></ul></li><li>V：视图view通常是UIKit控件或编码定义的UIKit控件的集合。<ul><li>View的构建可不告诉controller，也不应该直接引用model；</li><li>View仅仅通过IBAction事件引用controller；</li><li>视图本身不包含任何业务；</li></ul></li><li>C：控制器controller用于协调model和view间的所有交互，是app的“胶水代码”。<ul><li>controller负责管理所拥有的view的视图层次结构，并且响应view的loading、appearing、disappearing等；</li><li>包括不愿暴露给view的业务逻辑；</li><li>网络数据的请求及后续操作，本地数据库操作，及一些带有工具性质辅助方法等都加大了<code>Massive View Controller</code>的产生。</li></ul></li></ul><p><em>部分代码没有合适的存放位置，如网络逻辑。</em></p><p>弊端：</p><ul><li>大量的代码被放到controller，臃肿；</li><li>controller规模庞大，难以维护；</li><li>属性较多，难以管理；</li><li>遵循较多协议，protocol的响应代码和controller的逻辑代码混杂；</li><li>View Controller混合类视图处理逻辑和业务逻辑，分离这些成分的单元测试成为艰巨的任务。</li></ul><h1 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/MVVM.png" alt="MVVM"></p><p>MVVM是对MVC的一种演进，促进了UI代码和业务逻辑的分离。<br>MVVM正式规范了视图和控制器紧耦合的性质，并引入新的组件ViewModel。<br>项目中的请求数据，统一交给ViewModel管理，每个控制器对应一个专属ViewModel。</p><ul><li><p>特点：</p><ul><li>view和<code>view controller</code>正式联系在一起，将其视为一个组件；</li><li>view和<code>view controller</code>不能直接引用model，而是引用viewModel；</li><li>viewModel放置用户输入验证逻辑、视图显示逻辑、发起网络请求、数据解析等；</li><li>使用MVVM会增加少量代码量，但总体上减少了代码的复杂性。</li></ul></li><li><p>注意事项：</p><ul><li>view引用viewModel，但viewModel不能引用view；</li><li>viewModel引用model，但model不能引用ViewModel；</li><li>MVVM可兼容MVC架构；</li><li>MVVM配合一个绑定机制(如ReactiveCocoa)效果最好；</li><li>尽量使用viewModel处理业务逻辑；</li><li>viewController尽量不涉及业务逻辑，只接收view的事件、调用viewModel的方法、响应viewModel的变化；</li><li>viewModel间可以有依赖，但要避免过于臃肿。</li></ul></li><li><p>优点：</p><ul><li>低耦合：View可以独立于Model变化和修改，一个viewModel可以绑定到不同的View上；</li><li>可重用性：可将一些视图逻辑放到一个viewModel中，让view重用该视图逻辑；</li><li>独立开发：开发人员可专注于业务逻辑和数据的开发viewModel，设计人员可专注于页面设计View；</li><li>可测试：通常界面是比较难测试，MVVM模式可针对viewModel进行测试。</li></ul></li><li><p>缺点：</p><ul><li>数据绑定使得一个位置的Bug被快速传递到别的位置，难定位到原始位置；</li><li>对于过大的项目，数据绑定和数据转化需要花费更多的内存：<ul><li>数组内容的转化成本较高，数组中每项都要转化成Item对象，Item对象中可能还有类似数组；</li><li>转化后的数据大部分情况下不能直接被展示，还需二次转化；</li><li>只有在API返回的数据高度标准化时，Item的可复用程度才高，否则容易出现类型爆炸，提高维护成本；</li></ul></li><li>调试时通过Item查看数据内容，不如直接通过NSDictionary/NSArray直观；</li><li>同一API的数据被不同View展示时，难以控制数据转化的代码，可能散落在任何需要的地方。</li></ul></li></ul><hr><p>个人实战使用总结：</p><ul><li>Model：存放所需要用到的变量、定义字典等，用于转换数据；</li><li>View：控件相关，用于定义控件属性Cell、UI界面的设置等；</li><li>Controller：用于传递数据信息等，如给UIView内容赋值；</li><li>ViewModel：用于解析数据等。</li></ul><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://www.jianshu.com/p/d0bc12a63ccf" target="_blank" rel="noopener">https://www.jianshu.com/p/d0bc12a63ccf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MVC模式&quot;&gt;&lt;a href=&quot;#MVC模式&quot; class=&quot;headerlink&quot; title=&quot;MVC模式&quot;&gt;&lt;/a&gt;MVC模式&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/zhangzongyu00/i
      
    
    </summary>
    
    
      <category term="ios" scheme="http://zhangzongyu00.github.io/categories/ios/"/>
    
    
  </entry>
  
  <entry>
    <title>自编码机</title>
    <link href="http://zhangzongyu00.github.io/2020/06/23/%E8%87%AA%E7%BC%96%E7%A0%81%E6%9C%BA/"/>
    <id>http://zhangzongyu00.github.io/2020/06/23/%E8%87%AA%E7%BC%96%E7%A0%81%E6%9C%BA/</id>
    <published>2020-06-23T06:25:00.000Z</published>
    <updated>2020-07-20T10:10:40.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.png" alt="编码与解码"></p><p>左侧将原始图像编码为向量，右侧通过解卷积层“解码”，还原回原始图像。</p><p><em>可以用尽可能多的图像来训练网络，当保存了某张图像的编码向量，可用解码组件重建。</em></p><h1 id="经典自编码机VAE"><a href="#经典自编码机VAE" class="headerlink" title="经典自编码机VAE"></a>经典自编码机VAE</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE.png" alt="VAE"></p><p><em>通过编码向量，创造潜在向量，或实现连续、平滑的潜在空间表示。</em></p><p>通过给编码网络添加一个约束，使其所产生的潜在向量大体上服从单位高斯分布。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E7%BA%A6%E6%9D%9F.png" alt="VAE约束"></p><p>如图，只需从单位高斯分布中采样出一个潜在向量，并将其传递到解码器，就可以生成一张新的图像了。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E9%87%87%E6%A0%B7.png" alt="VAE采样"></p><p>基本思路：</p><ul><li>假定输入数据的数据集D的分布完全由一组隐变量z操控，并且，该组隐变量间相互独立且服从高斯分布；</li><li>VAE让encoder学习输入数据的隐变量模型，即学习该组隐变量的高斯概率分布的参数：隐变量高斯分布的均值$\mu$和方差$\theta$的$log$值；</li><li>隐变量z通过对参数的正态分布中采样得到：$z \sim N(\mu, \theta)$；</li><li>通过decoder对隐变量进行解码，重构函数。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E5%88%86%E5%B8%83.png" alt="VAE分布"></p><p>总体目标函数：<br>    $\mathcal{L}(x,\widehat{x}) + \sum_j KL(q_j(z|x)||p(z))$</p><p>误差：误差项精确度及潜在变量在单位高斯分布上的契合程度。</p><ul><li>生成误差，用以衡量网络重构图像精准度的均方误差；</li><li>潜在误差，用以衡量潜在变量在单位高斯分布上的契合程度的KL散度。</li></ul><h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h2><p><em>VAE模型并没有真正的用$z \sim N(\mu,\theta)$来采样得到z变量：因为采样后无法对$(\mu,\theta)$进行求导。</em></p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE_Reparameterization.png" alt="VAE_Reparameterization"></p><p>一般先采样一个标准的高斯分布/正态分布$\epsilon \sim N(0,1)$，然后令$z=\mu+\epsilon*\theta$，这样得到的z就服从$z \sim N(\mu,\theta)$，同时也可正常对(\mu,\theta)$求导。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点：遵循“编码-解码”模式，能直接将生成的图像同原始图像进行对比；</li><li>缺点：直接采用均方误差，导致其神经网络倾向生成较为模糊的图像。</li></ul><h1 id="VAE和GAN的区别"><a href="#VAE和GAN的区别" class="headerlink" title="VAE和GAN的区别"></a>VAE和GAN的区别</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE_vs_GAN.png" alt="VAE_vs_GAN"></p><p>GAN是VAE后半部分再加上一个鉴别网络，导致完全不同的训练方式。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_40955254/article/details/82315224" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315224</a></li><li><a href="https://blog.csdn.net/weixin_40955254/article/details/82315909?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315909?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编码与解码&quot;&gt;&lt;a href=&quot;#编码与解码&quot; class=&quot;headerlink&quot; title=&quot;编码与解码&quot;&gt;&lt;/a&gt;编码与解码&lt;/h1&gt;&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/zhangzongyu00/i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Alamofire框架</title>
    <link href="http://zhangzongyu00.github.io/2020/06/22/Alamofire%E6%A1%86%E6%9E%B6/"/>
    <id>http://zhangzongyu00.github.io/2020/06/22/Alamofire%E6%A1%86%E6%9E%B6/</id>
    <published>2020-06-22T02:13:19.000Z</published>
    <updated>2020-07-01T13:33:15.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alamofire（swift）"><a href="#Alamofire（swift）" class="headerlink" title="Alamofire（swift）"></a>Alamofire（swift）</h1><p>使用Cocoapods进行集成；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cocoapods</span><br></pre></td></tr></table></figure><ol><li>在项目目录下进行pod初始化设置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line"># platform :ios, &#39;9.0&#39;</span><br><span class="line"></span><br><span class="line">target &#39;***&#39; do</span><br><span class="line">  # Comment the next line if you don&#39;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # Pods for AlamofireTest</span><br><span class="line">  pod &#39;Alamofire&#39;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol start="3"><li>执行更新<code>pod install</code>，不更新本地库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install --no-repo-update</span><br></pre></td></tr></table></figure><ol start="4"><li><p>打开文件目录下<code>***.xcworkspace</code></p></li><li><p>重新配置<code>Pods_***.framework</code><br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AEframework.png" alt="重新配置framework"></p></li><li><p>修改<code>Allow Arbitrary Loads</code>访问http请求权限<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Allow_Arbitrary_Loads.png" alt="Allow_Arbitrary_Loads"></p></li></ol><hr><p><em><code>http://httpbin.org</code>用于处理http/https的相关请求</em></p><p>在实际开发中，为了不过于依赖某一个第三方框架，常使用封装的方式，将其封装到某一工具类，方便其框架不更新时进行修改。</p>]]></content>
    
    <summary type="html">
    
      第三方框架：AFNetworking（OC）-- Alamofire（swift）
    
    </summary>
    
    
      <category term="ios开发" scheme="http://zhangzongyu00.github.io/categories/ios%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://zhangzongyu00.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>生成对抗网络</title>
    <link href="http://zhangzongyu00.github.io/2020/06/09/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    <id>http://zhangzongyu00.github.io/2020/06/09/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/</id>
    <published>2020-06-09T05:05:22.000Z</published>
    <updated>2020-07-06T01:58:20.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成式模型和判别式模型"><a href="#生成式模型和判别式模型" class="headerlink" title="生成式模型和判别式模型"></a>生成式模型和判别式模型</h1><ul><li>判别式模型</li></ul><p>已知观察变量X和隐含变量z，对$p(z|X)$进行建模，根据输入的观察变量x得到隐含变量z出现的概率。</p><ul><li>生成式模型</li></ul><p>已知观察变量X和隐含变量z，对$p(X|z)$进行建模，根据隐含变量z得到输出是观察变量x的概率。</p><h1 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GAN%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="GAN基本流程"></p><ul><li><p>生成器网络Generator：$x = G(z; \theta^{(G)})$，负责生成样本数据；</p><ul><li>输入：高斯白噪声向量z；</li><li>输出：样本数据向量x；</li></ul></li><li><p>判别器网络Discriminator：$y = D(x, \theta^D)$，负责检测样本数据真假；</p><ul><li>输入：真实/生成 样本数据；</li><li>输出：真/假 标签；</li></ul></li></ul><p><em>该网络参数一定满足可微分。</em></p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/G2D.png" alt="G2D"></p><p>基本思路：</p><ol><li>让第一代的G产生一些图片，将其和部分真实图片放到D中学习；</li><li>让第一代的D能够分辨生成的图片和真实的图片；</li><li>训练第二代的G，让第二代G生成的图片，能欺骗过第一代的D；</li><li>训练第二代的D；</li><li>依次循环3、4，直到满足终止条件。</li></ol><p><em>通过将新一代的G和上一代的D连接起来(感觉有些类似级联分类器)，形成一个新的G，生成能欺骗过上一代D的图像。</em></p><p>模型的目标：</p><ul><li>训练数据集的模型：$x ~ p_{train} (x)$</li><li>生成样本的模型：$x ~ p_{model} (x)$</li><li>使其相等：$p_{train} (x) = p_{model} (x)$</li></ul><p>优化目标/价值函数：<br>  $$min_G max_D V(D,G) = E_{x \sim p_{data}(x)} [log D(x)] + E_{z \sim p_z(z)} [log (1-D(G(z)))]$$</p><ul><li>生成器G固定后，使用$max_D V(D,G)$来评价$p_{data}$和$p_z$间的差异；</li><li>判别器优化方向 -&gt; 最大化价值函数$$J(D) = -\frac{1}{2} E_{x \sim p_{data}} log D(x) - \frac{1}{2} E_z log(1-D(G(z)))$$</li><li>生成器优化方向 -&gt; 最小化价值函数$$J(G) = -J(D) = \frac{1}{2} E_z log(1-D(G(z)))$$</li></ul><p>  <em>优化目标函数，直到达到纳什均衡</em></p><p>为了引入KL散度和JS散度，对目标函数进行变换：</p><ol><li>$KL(P_1||P_2)=E_{x \sim P_1} log \frac{P_1}{P_2}$</li><li>$JS(P_1||P_2)=\frac{1}{2} KL(P_1|| \frac{P_1+P_2}{2} + \frac{1}{2} KL(P_2|| \frac{P_1+P_2}{2})$</li><li>$2JS(P_r||P_g) - 2log2$</li><li>$E_{x \sim P_r}[log D(x)] + E_{x \sim P_g}[log (1-D(x)]$</li><li>$E_{x \sim P_r}log \frac{P_r (x)}{\frac{1}{2} [P-r(x) + P_g(x)]} + E_{x \sim P_g}log \frac{P_g(x)}{\frac{1}{2} [P_r(x) + P_g(x)]} - 2log2$</li></ol><p>在最优判别器下，GAN定义的$G_{loss}$可等价变换为<strong>最小化真实函数与生成分布</strong>的JS散度。</p><p>主要解决问题：</p><ul><li>构建高维、复杂概率分布；</li><li>解决数据缺少问题；</li><li>用于多模态输出；</li><li>解决真实输出任务；</li><li>进行数据预测etc。</li></ul><p>存在问题：</p><ul><li>训练困难，难以达到纳什均衡点，且无法有效监控收敛状态；</li><li>模型崩溃，D能力明显强于G；</li><li>输出多样性低，G将数据集中生成在D最好的空间点；</li><li>不适用于离散输出（不可微分）。</li></ul><h2 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DCGAN.png" alt="DCGAN"></p><p>模型稳定训练的tricks：</p><ul><li>全连接层、池化层、上采样层 -&gt; 卷积层；</li><li>使用<code>batch normalization</code>；</li><li>生成器中卷积层-&gt;反卷积层，并使用ReLU激活函数，输出使用Tanh；</li><li>判别器中使用<code>Leaky ReLU</code>激活函数；</li><li>使用Adam优化器训练，学习率建议0.0002。</li></ul><p>生成的特征具有向量的计算特性，即特征可以进行加减运算。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/z%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E7%89%B9%E6%80%A7.png" alt="z向量的计算特性"></p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/z%E5%90%91%E9%87%8F%E7%9A%84%E6%8F%92%E5%80%BC%E7%89%B9%E6%80%A7.png" alt="z向量的插值特性"></p><p>生成效果：LSUN数据集</p><ul><li>仅支持低分辨率的图片；</li><li>无法捕捉物体的结构特性。</li></ul><h2 id="CGAN"><a href="#CGAN" class="headerlink" title="CGAN"></a>CGAN</h2><p>将GAN中输入的随机的数据，更改为有意义的数据。ex.手写数字字体的生层，输入的是一个数字，输出对应的字体。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CGAN.png" alt="CGAN"></p><p>实现思路：</p><ul><li>在生成网络的输入z的基础上连接一个输入额外信息y；</li><li>在判别网络的输入x的基础上连接一个y；</li><li>目标函数变为$$min_G max_D V(D,G) = E_{x \sim p_{data}(x)} [log D(x|y)] + E_{z \sim p_z(z)} [log (1-D(G(z|y)))]$$</li></ul><h2 id="Wasserstein-GAN"><a href="#Wasserstein-GAN" class="headerlink" title="Wasserstein GAN"></a>Wasserstein GAN</h2><p>目标函数问题：</p><ul><li>$P_r$和$P_g$不重叠部分，JS为固定常数，对SGD来说梯度为0；</li><li>$P_r$和$P_g$的重叠部分基本可以忽略；</li><li>在最优D下，最小化G的loss等价于最小化$P_r$和$P_g$间的JS散度。</li></ul><p>由于$P_r$和$P_g$多少都会有可以忽略的重叠部分，所以，无论相聚多远，JS散度都是常数，最终导致G的梯度近似为0，梯度消失。</p><p>Wasserstein距离/Earth-Mover距离：$$W(P_r,P_G)=inf_{\gamma \sim \Pi(P_r, P_g)} \mathbb{E}_{(x,y)\sim \gamma} [||x-y||]$$</p><p>$W(P_r,P_G)$即为最优路径规划下的最小能量，可理解为将$P_r$转为$P_g$的能量。</p><p>Wasserstein距离相比KL散度、JS散度的优点：即便两个分布没有重叠，Wasserstein距离依然能反映$P_r$和$P_g$的距离。</p><p>目标函数：</p><ul><li>生成器loss：$-\mathbb{E}_{x\sim P_g}[f_w(x)]$</li><li>判别器loss：$\mathbb{E}<em>{x\sim P_g}[f_w(x)]-\mathbb{E}</em>{x\sim P_r}[f_w(x)]$</li></ul><p>创新点：</p><ol><li>判别器最后一层去掉sigmoid（不做分类，改为回归问题）；</li><li>G和D的loss不取log；</li><li>每次更新D的参数后将其绝对值截断到不超过一个固定常数c；</li><li>不用基于动量的优化算法(momentum、adam等)，推荐RMSProp、SGD等。</li></ol><p>实现效果：</p><ul><li>解决GAN训练不稳定的问题，无需担心平衡G和D的训练程度；</li><li>基本解决<code>collapse mode</code>的问题，确保生成样本的多样性；</li><li>训练过程中拥有了交叉熵、准确率等数值表示来指导训练的过程，数值越小G生成的图像质量越高；</li><li>最简单的多层全连接网络即可达到较好效果，不需精心设计的网络架构。</li></ul><p><em>WGAN不用DCGAN各种特殊的架构设计，与DCGAN结果类似。</em></p><h1 id="Super-ResolutionGAN"><a href="#Super-ResolutionGAN" class="headerlink" title="Super-ResolutionGAN"></a>Super-ResolutionGAN</h1><p>$I^{HR}$，高分辨率图像，来自数据库；<br>$I^{LR}$，由$I^{HR}$进行高斯滤波，然后下采样获得。</p><p>目标函数：<br>$min_{\theta_G} max_{\theta_D} \mathbb{E}<em>{I^{HR}\sim p</em>{train}(I^{HR})}[log D_{\theta_D}(I^{HR})]+\mathbb{E}<em>{I^{LR}\sim p_G(I^{LR})}[log(1-D</em>{\theta_D}(G_{\theta_G}(I^{LR})))]$</p><p>参数$\theta_G$通过优化一个损失函数$l^{SR}$得到：$\widehat{\theta}<em>G=arg min</em>{\theta_G}\frac{1}{N}\sum_{n=1}^N l^{SR}(G_{\theta_G}(I_n^{LR}),I_n^{HR})$</p><ol><li>生成网络：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/SRGAN_G.png" alt="SRGAN_G"><ul><li>应用分布相同的B残差块，每个残差块由两个卷积层；</li><li>卷积层后加上BN层，并用PReLU为激活函数；</li><li>卷积层的卷积核全部为3*3，并有64个特征图；</li><li>添加跳层/跃层连接。</li></ul></li><li>判别网络：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/SRGAN_D.png" alt="SRGAN_D"><ul><li>由连续卷积块构成，包括卷积层、LeakyReLU、BN层；</li><li>卷积核为3*3；</li><li>最后使用两个dense层，并通过sigmoid进行判别。</li></ul></li></ol><h1 id="CycleGAN"><a href="#CycleGAN" class="headerlink" title="CycleGAN"></a>CycleGAN</h1><p><em>可实现无配对的两个图片集的训练，结构有些类似于自动编码器。</em></p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CycleGAN.png" alt="CycleGAN"></p><p>CycleGAN本质上是镜像对称的GAN网络，构成了一个环形回路。两个GAN共享两个G，并各自带了一个D，一个单向GAN两个loss，因此，整个网络共有四个loss。</p><p>损失函数（使用均方误差）：<br>$L_{LSGAN}(G,D_Y,X,Y)=\mathbb{E}<em>{y\sim p</em>{data}(y)}[(D_Y(y)-1)^2]+\mathbb{E}<em>{x\sim p</em>{data}(x)}[1-D_Y(G(x))]^2$</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/104575937" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104575937</a><br><a href="https://blog.csdn.net/gdymind/article/details/82696481" target="_blank" rel="noopener">https://blog.csdn.net/gdymind/article/details/82696481</a><br><a href="https://zhuanlan.zhihu.com/p/83630387" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/83630387</a><br><a href="https://zhuanlan.zhihu.com/p/90835081" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90835081</a><br><a href="https://www.jianshu.com/p/64bf39804c80" target="_blank" rel="noopener">https://www.jianshu.com/p/64bf39804c80</a></p>]]></content>
    
    <summary type="html">
    
      简单来讲，生成器生成数据，鉴别器用于区分真假，通过训练使其达到一定平衡。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>卷积神经网络</title>
    <link href="http://zhangzongyu00.github.io/2020/06/08/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://zhangzongyu00.github.io/2020/06/08/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-06-08T02:39:27.000Z</published>
    <updated>2020-06-09T11:59:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNN基本组件"><a href="#CNN基本组件" class="headerlink" title="CNN基本组件"></a>CNN基本组件</h1><h2 id="卷积层-Convolutional-layer"><a href="#卷积层-Convolutional-layer" class="headerlink" title="卷积层 Convolutional_layer"></a>卷积层 Convolutional_layer</h2><p>用一个采样器从输入数据中采集关键数据内容；</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CNN%E5%8D%B7%E7%A7%AF%E5%8E%9F%E7%90%86.png" alt="CNN卷积原理"></p><p>3D滤波器/卷积核：</p><ul><li>以扫描窗的方式，对图像做卷积；</li><li><strong>每层包含多个卷积核，每个核对应一个输出通道</strong>；</li><li>用于提取局部特征；</li><li>权重参数根据训练学习获得。</li></ul><p>通过代码看卷积核的超参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.Conv2d(self, in_channels, out_channels, kernel_size, stride&#x3D;1, padding&#x3D;0, dilation&#x3D;1, groups&#x3D;1, bias&#x3D;True))</span><br></pre></td></tr></table></figure><ul><li>in_channel：输入数据的通道数;</li><li>out_channel：输出数据的通道数，根据模型调整，对应<strong>滤波器/卷积核的数量</strong>；</li><li>kennel_size：卷积核大小；</li><li>Stride：步长，默认为1；</li><li>padding：zero padding。</li></ul><p><em>卷积操作一般要把卷积核旋转$180^\circ$再相乘的(反向传播)。</em></p><a href="/2020/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" title="激活函数">激活函数</a><h2 id="池化层-Pooling-layer"><a href="#池化层-Pooling-layer" class="headerlink" title="池化层 Pooling_layer"></a>池化层 Pooling_layer</h2><p>对卷积层结果进行压缩，得到更加重要的特征，并有效控制过拟合。</p><p>计算类别：</p><ul><li>平均池化</li><li>最大池化</li></ul><p>通过代码查看最大池化层的超参数设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.MaxPool2d(kernel_size, stride&#x3D;None, padding&#x3D;0, dilation&#x3D;1, return_indices&#x3D;False, ceil_mode&#x3D;False)</span><br></pre></td></tr></table></figure><ul><li>kernel_size(int or tuple)：max pooling的窗口大小；</li><li>stride(int or tuple, optional)：max pooling的窗口移动的步长，默认kernel_size；</li><li>padding(int or tuple, optional)：输入的每一条边补充0的层数；</li><li>dilation(int or tuple, optional)：一个控制窗口中元素步幅的参数；</li><li>return_indices：若为True，返回输出最大值的序号，对于上采样操作有帮助；</li><li>ceil_mode：若为True，计算输出信号大小时，会使用向上取整，默认向下取整。</li></ul><h3 id="池化层的误差反向传播"><a href="#池化层的误差反向传播" class="headerlink" title="池化层的误差反向传播"></a>池化层的误差反向传播</h3><p>对pooling进行填充后，将卷积核旋转$180^\circ$，进行反向传播计算。</p><ol><li>mean-pooling</li></ol><ul><li>使用等值复制方式，将[[1,2],[3,4]]变为[[1,1,2,2],[1,1,2,2],[3,3,4,4],[3,3,4,4]];</li><li>需要满足反向传播时各层间残差总和不变，所以对卷积层对应的每个值需要平摊。</li></ul><ol start="2"><li>max-pooling</li></ol><ul><li>前向传播过程中<strong>需要记录pooling区域中最大值的位置</strong>；</li><li>将[[1,2],[3,4]]放入对应的最大值位置，如[[1,0,0,2],[0,0,0,0],[0,0,0,0],[3,0,0,4]];</li></ul><h2 id="全连接层-Fully-Connected-layer"><a href="#全连接层-Fully-Connected-layer" class="headerlink" title="全连接层 Fully-Connected_layer"></a>全连接层 Fully-Connected_layer</h2><p>对卷积后高度抽象化的特征进行整合，然后归一化，对各种分类情况输出一个概率，之后的分类器Classifier根据全连接得到的概率进行分类。</p><a href="/2020/06/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="SoftMax">SoftMax</a><p>FCL对接n维的software层，得到n类标签的概率，用于构建loss。</p>]]></content>
    
    <summary type="html">
    
      可先简单了解下神经网络
    
    </summary>
    
    
      <category term="deeplearning" scheme="http://zhangzongyu00.github.io/categories/deeplearning/"/>
    
    
      <category term="CNN" scheme="http://zhangzongyu00.github.io/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>Adam</title>
    <link href="http://zhangzongyu00.github.io/2020/06/07/Adam/"/>
    <id>http://zhangzongyu00.github.io/2020/06/07/Adam/</id>
    <published>2020-06-07T00:01:39.000Z</published>
    <updated>2020-07-04T02:57:59.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h1><p>动量momentum借用了物理中的动量概念，即将前几次的梯度也加入计算过程。为了表示动量，引入了一个新的变量v。v是<strong>之前的梯度的累加</strong>，但每回合都有一定的衰减。</p><p>计算梯度估计：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$</p><p>计算更新：<br>$$v \leftarrow \alpha v - \epsilon \widehat{g}$$</p><p>应用更新：<br>$$\theta \leftarrow \theta + v$$</p><p>当前后梯度方向一致时，能够加速学习；前后梯度方向不一致时，能够抑制震荡。</p><h1 id="Nesterov-Momentum"><a href="#Nesterov-Momentum" class="headerlink" title="Nesterov Momentum"></a>Nesterov Momentum</h1><p><em>对momentum的改进</em></p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Nesterov_Momentum.png" alt="Nesterov_Momentum"></p><p>计算梯度估计：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta + \alpha v),y_i)$$<br>计算更新：<br>$$v \leftarrow \alpha v - \epsilon \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + v$$</p><p>先对参数进行估计，然后使用估计后的参数来计算误差。</p><h1 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h1><p>主要解决：<strong>为不同参数设置不同的学习步长</strong>。</p><p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>累积平方梯度：<br>$$r \leftarrow r + \widehat{g} \odot \widehat{g}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \frac{\epsilon}{\delta + \sqrt{r}} \odot \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p><p><em>$\delta$为小常数，为了数值稳定，大约设置为$10^{-7}$</em>。</p><p>梯度越小，则学习步长越大；梯度越大，学习步长越小。即缓坡上大步跑，陡坡上小步挪。</p><h1 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h1><p><em>对Adagrad的改进</em></p><p>通过引入一个衰减系数，让r每回合都衰减一定比例。</p><p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>累积平方梯度：<br>$$r \leftarrow \rho r + (1 - \rho)\widehat{g} \odot \widehat{g}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \frac{\epsilon}{\delta + \sqrt{r}} \odot \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p><p>解决了Adagrad过早结束时间问题，适合处理非平稳目标，对RNN效果好。</p><h1 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h1><p>来源于<code>adaptive moment estimation</code>，自适应矩估计。</p><p>Adam本质上是带有动量项的RMSprop，利用梯度的一阶矩估计和二阶矩估计来动态调整每个参数的学习率。</p><p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>一阶矩估计：<br>$$s \leftarrow \rho_1 s + (1 - \rho_1) g$$<br>$$\widehat{s} \leftarrow \frac{s}{1 - \rho_1^t}$$<br>二阶矩估计：<br>$$r \leftarrow \rho_2 r + (1 - \rho_2) g \odot g$$<br>$$\widehat{r} \leftarrow \frac{r}{1 - \rho_2^t}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \epsilon \frac{\widehat{s}}{\sqrt{\widehat{r}} + \delta}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p><h1 id="几种梯度下降算法比较"><a href="#几种梯度下降算法比较" class="headerlink" title="几种梯度下降算法比较"></a>几种梯度下降算法比较</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Adam%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="Adam梯度下降算法比较"></p><ol><li>在minist上训练多层神经网络；</li><li>在cifar10上训练卷积神经网络。</li></ol><p>参考：<br><a href="https://blog.csdn.net/program_developer/article/details/80756008" target="_blank" rel="noopener">https://blog.csdn.net/program_developer/article/details/80756008</a></p>]]></content>
    
    <summary type="html">
    
      当前最常用的梯度下降算法
    
    </summary>
    
    
      <category term="deeplearning" scheme="http://zhangzongyu00.github.io/categories/deeplearning/"/>
    
    
  </entry>
  
  <entry>
    <title>小波变换</title>
    <link href="http://zhangzongyu00.github.io/2020/06/06/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://zhangzongyu00.github.io/2020/06/06/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</id>
    <published>2020-06-06T05:56:52.000Z</published>
    <updated>2020-06-06T06:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="连续小波变换CWT"><a href="#连续小波变换CWT" class="headerlink" title="连续小波变换CWT"></a>连续小波变换CWT</h1><p>将无限长的三角函数基转换为有限长的会衰减的小波基，不仅能获取频率，还可定位到时间。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2.png" alt="小波变换"></p><p>思路：</p><ol><li>取一个小波，将其与原始信号的开始一节进行比较；</li><li>计算数值F，F表示小波与所取一节信号的相似程度，计算结果取决于所选小波的形状；</li><li>向右移动小波，重复步骤1和步骤2，直至覆盖整个信号；</li><li>伸展小波，重复步骤1-3，对齐；</li><li>对于所有缩放，重复步骤1-4，进行压缩。</li></ol><h1 id="离散小波变换DWT"><a href="#离散小波变换DWT" class="headerlink" title="离散小波变换DWT"></a>离散小波变换DWT</h1><p>离散小波变换的有效方法是使用滤波器，由Mallat于1988年提出。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%9A%E5%B1%82%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E5%92%8C%E9%87%8D%E6%9E%84.png" alt="多层小波分解和重构"></p><h2 id="小波分解"><a href="#小波分解" class="headerlink" title="小波分解"></a>小波分解</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="离散小波分解示意图"></p><p>S表示原始的输入信号，通过两个互补的滤波器组，一个低通滤波器，得到信号的近似值A，另一个高通滤波器，得到该滤波器的细节值D。</p><h2 id="小波重构"><a href="#小波重构" class="headerlink" title="小波重构"></a>小波重构</h2><p>利用小波分解的系数还原出原始信号，也叫逆离散小波变换IDWT/小波合成。</p><h1 id="二维离散小波变换"><a href="#二维离散小波变换" class="headerlink" title="二维离散小波变换"></a>二维离散小波变换</h1><p>将二维信号在不同尺度进行分解，得到原始信号的近似值和细节。</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BA%8C%E7%BB%B4%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E5%92%8C%E9%87%8D%E6%9E%84.png" alt="二维小波分解和重构"></p><p>分解的结果为**近似分量cA、水平细节分量cH、垂直细节分量cV、对角细节分量cD。</p><h1 id="常见小波函数"><a href="#常见小波函数" class="headerlink" title="常见小波函数"></a>常见小波函数</h1><p>Haar系列，Daubechies系列，Moret系列，Sym系列，Meyer系列，Coif系列</p><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%B3%A2%E5%87%BD%E6%95%B0.png" alt="常用小波函数"></p><p>参考：<br><a href="https://www.cnblogs.com/keye/p/7809207.html" target="_blank" rel="noopener">https://www.cnblogs.com/keye/p/7809207.html</a><br><a href="https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html</a></p>]]></content>
    
    <summary type="html">
    
      小波变换就是将一个信号分解为一系列小波进行处理的过程。
    
    </summary>
    
    
      <category term="image" scheme="http://zhangzongyu00.github.io/categories/image/"/>
    
    
      <category term="多尺度变换" scheme="http://zhangzongyu00.github.io/tags/%E5%A4%9A%E5%B0%BA%E5%BA%A6%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>VS-Code配置</title>
    <link href="http://zhangzongyu00.github.io/2020/06/06/VSCode%E9%85%8D%E7%BD%AE/"/>
    <id>http://zhangzongyu00.github.io/2020/06/06/VSCode%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-06T05:41:39.000Z</published>
    <updated>2020-06-09T06:03:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>配置C环境<br><a href="https://www.jianshu.com/p/83879b4aa3fe" target="_blank" rel="noopener">https://www.jianshu.com/p/83879b4aa3fe</a></p><p>Latex学习<br><a href="https://www.cnblogs.com/zyg123/category/1415008.html" target="_blank" rel="noopener">https://www.cnblogs.com/zyg123/category/1415008.html</a></p>]]></content>
    
    <summary type="html">
    
      万能的VS-Code配置
    
    </summary>
    
    
    
  </entry>
  
</feed>
