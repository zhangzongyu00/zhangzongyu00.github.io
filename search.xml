<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Adam</title>
    <url>/2020/06/07/Adam/</url>
    <content><![CDATA[<h1 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h1><p>动量momentum借用了物理中的动量概念，即将前几次的梯度也加入计算过程。为了表示动量，引入了一个新的变量v。v是<strong>之前的梯度的累加</strong>，但每回合都有一定的衰减。</p>
<p>计算梯度估计：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$</p>
<p>计算更新：<br>$$v \leftarrow \alpha v - \epsilon \widehat{g}$$</p>
<p>应用更新：<br>$$\theta \leftarrow \theta + v$$</p>
<p>当前后梯度方向一致时，能够加速学习；前后梯度方向不一致时，能够抑制震荡。</p>
<h1 id="Nesterov-Momentum"><a href="#Nesterov-Momentum" class="headerlink" title="Nesterov Momentum"></a>Nesterov Momentum</h1><p><em>对momentum的改进</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Nesterov_Momentum.png" alt="Nesterov_Momentum"></p>
<p>计算梯度估计：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta + \alpha v),y_i)$$<br>计算更新：<br>$$v \leftarrow \alpha v - \epsilon \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + v$$</p>
<p>先对参数进行估计，然后使用估计后的参数来计算误差。</p>
<h1 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h1><p>主要解决：<strong>为不同参数设置不同的学习步长</strong>。</p>
<p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>累积平方梯度：<br>$$r \leftarrow r + \widehat{g} \odot \widehat{g}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \frac{\epsilon}{\delta + \sqrt{r}} \odot \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p>
<p><em>$\delta$为小常数，为了数值稳定，大约设置为$10^{-7}$</em>。</p>
<p>梯度越小，则学习步长越大；梯度越大，学习步长越小。即缓坡上大步跑，陡坡上小步挪。</p>
<h1 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h1><p><em>对Adagrad的改进</em></p>
<p>通过引入一个衰减系数，让r每回合都衰减一定比例。</p>
<p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>累积平方梯度：<br>$$r \leftarrow \rho r + (1 - \rho)\widehat{g} \odot \widehat{g}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \frac{\epsilon}{\delta + \sqrt{r}} \odot \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p>
<p>解决了Adagrad过早结束时间问题，适合处理非平稳目标，对RNN效果好。</p>
<h1 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h1><p>来源于<code>adaptive moment estimation</code>，自适应矩估计。</p>
<p>Adam本质上是带有动量项的RMSprop，利用梯度的一阶矩估计和二阶矩估计来动态调整每个参数的学习率。</p>
<p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>一阶矩估计：<br>$$s \leftarrow \rho_1 s + (1 - \rho_1) g$$<br>$$\widehat{s} \leftarrow \frac{s}{1 - \rho_1^t}$$<br>二阶矩估计：<br>$$r \leftarrow \rho_2 r + (1 - \rho_2) g \odot g$$<br>$$\widehat{r} \leftarrow \frac{r}{1 - \rho_2^t}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \epsilon \frac{\widehat{s}}{\sqrt{\widehat{r}} + \delta}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p>
<h1 id="几种梯度下降算法比较"><a href="#几种梯度下降算法比较" class="headerlink" title="几种梯度下降算法比较"></a>几种梯度下降算法比较</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Adam%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="Adam梯度下降算法比较"></p>
<ol>
<li>在minist上训练多层神经网络；</li>
<li>在cifar10上训练卷积神经网络。</li>
</ol>
<p>参考：<br><a href="https://blog.csdn.net/program_developer/article/details/80756008" target="_blank" rel="noopener">https://blog.csdn.net/program_developer/article/details/80756008</a></p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
  </entry>
  <entry>
    <title>Alamofire框架</title>
    <url>/2020/06/22/Alamofire%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Alamofire（swift）"><a href="#Alamofire（swift）" class="headerlink" title="Alamofire（swift）"></a>Alamofire（swift）</h1><p>使用Cocoapods进行集成；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install cocoapods</span><br></pre></td></tr></table></figure>

<ol>
<li>在项目目录下进行pod初始化设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line"># platform :ios, &#39;9.0&#39;</span><br><span class="line"></span><br><span class="line">target &#39;***&#39; do</span><br><span class="line">  # Comment the next line if you don&#39;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # Pods for AlamofireTest</span><br><span class="line">  pod &#39;Alamofire&#39;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行更新<code>pod install</code>，不更新本地库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install --no-repo-update</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>打开文件目录下<code>***.xcworkspace</code></p>
</li>
<li><p>重新配置<code>Pods_***.framework</code><br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AEframework.png" alt="重新配置framework"></p>
</li>
<li><p>修改<code>Allow Arbitrary Loads</code>访问http请求权限<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Allow_Arbitrary_Loads.png" alt="Allow_Arbitrary_Loads"></p>
</li>
</ol>
<hr>
<p><em><code>http://httpbin.org</code>用于处理http/https的相关请求</em></p>
<p>在实际开发中，为了不过于依赖某一个第三方框架，常使用封装的方式，将其封装到某一工具类，方便其框架不更新时进行修改。</p>
]]></content>
      <categories>
        <category>ios开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>BinaryTree</title>
    <url>/2020/07/29/BinaryTree/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><table>
<thead>
<tr>
<th align="center">树的类别</th>
<th align="center">树的特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">二叉搜索树</td>
<td align="center">左子树上所有结点的值均小于其根结点的值，右子树上所有结点的值均大于其根结点的值的树</td>
</tr>
<tr>
<td align="center">平衡二叉树</td>
<td align="center">每个结点的平衡因子都是1、0、-1的<strong>二叉排序树</strong>，即每个结点的左右子树的高度差最大为1的二叉排序树</td>
</tr>
<tr>
<td align="center">完全二叉树</td>
<td align="center">假设二叉树的深度为k，除第k层外，其它各层的结点数都达到最大个数，第k层所有的结点都连续集中在最左边</td>
</tr>
<tr>
<td align="center">满二叉树</td>
<td align="center">一棵二叉树的结点要么是叶子结点，要么它有两个子结点，并且二叉树的层数为K，结点总数需要是$2^k-1$</td>
</tr>
<tr>
<td align="center">最优二叉树/哈夫曼树</td>
<td align="center">树的带权路径长度达到最小，哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近</td>
</tr>
</tbody></table>
<h2 id="二叉搜索树-二叉查找树-二叉排序树BST"><a href="#二叉搜索树-二叉查找树-二叉排序树BST" class="headerlink" title="二叉搜索树/二叉查找树/二叉排序树BST"></a>二叉搜索树/二叉查找树/二叉排序树BST</h2><ul>
<li>任意结点的左子树不空，则左子树上所有结点的值均小于其根结点的值； </li>
<li>任意结点的右子树不空，则右子树上所有结点的值均大于其根结点的值； </li>
<li>任意结点的左、右子树也分别为二叉搜索树。</li>
</ul>
<p>时间复杂度：$O(log^n)$</p>
<p>优点：</p>
<ul>
<li>既有链表的快速插入与删除操作的特点</li>
<li>又有数组快速查找的优势；</li>
<li>对二叉搜索树进行中序遍历，得到的是一个有序集合。</li>
</ul>
<h2 id="平衡二叉树AVL"><a href="#平衡二叉树AVL" class="headerlink" title="平衡二叉树AVL"></a>平衡二叉树AVL</h2><p>平衡因子/平衡度：结点的平衡因子是结点的左子树的高度减右子树的高度的绝对值。</p>
<p>平衡二叉树，每个结点的平衡因子都是1、0、-1的<strong>二叉排序树</strong>，即每个结点的左右子树的高度差最大为1的二叉排序树。</p>
<ul>
<li>root结点的左右子树的高度差(平衡因子)的绝对值不超过1；</li>
<li>任意结点的左右子树也都是平衡二叉树；</li>
<li>平衡二叉树一定是二叉搜索树，但二叉搜索树不一定是平衡二叉树。</li>
</ul>
<p>优点：</p>
<ul>
<li>减少二叉查找树层次；</li>
<li>提高查找速度。</li>
</ul>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>Red Black Tree，本质上是一种二叉查找树（自平衡二叉查找树），但它在二叉查找树的基础上额外添加了一个颜色标记。</p>
<ol>
<li>Every node is either red or black；</li>
<li>The root is black；</li>
<li>Every leaf (NIL) is black；</li>
<li>If a node is red, then both its children are black；</li>
<li>For each node, all simple paths from the node to descendant leaves contain the same number of black nodes（从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点）。</li>
</ol>
<p>若一棵二叉查找树是红黑树，则它的任一子树必为红黑树。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><em>默认插入的结点设置为red，否则会破坏规则5。</em></p>
<p>可分为三种类型：</p>
<ul>
<li>要插入的结点的parent为black，直接插入即可；</li>
<li>要插入的结点的parent为red，uncle为red，change color；</li>
<li>要插入的结点的parent为red，uncle为black or null，分情况旋转后color。</li>
</ul>
<p>旋转：</p>
<ul>
<li>左左型：parent成为grandparent，grandparent成为parent的left结点；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5.jpg" alt="红黑树插入"></li>
<li>左右型：要插入的结点成为grandparent，grandparent成为left的uncle；</li>
<li>右右型：parent成为grandparent，grandparent成为parent的right结点；</li>
<li>右左型：要插入的结点成为grandparent，grandparent成为right的uncle；</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>亦可分为三种类型：</p>
<ul>
<li>要删除的节点正好是叶子节点，直接删除；</li>
<li>只有左孩子或者右孩子，直接把这个孩子上移放到要删除的位置上；</li>
<li>有左右两个孩子，需要选一个合适的孩子节点作为新的根节点，该节点称为继承节点。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4.png" alt="红黑树删除"></li>
</ul>
<p><em>删除结点需要考虑的与插入类似。</em></p>
<h1 id="B-树-B树-B-树"><a href="#B-树-B树-B-树" class="headerlink" title="B-树/B树/B_树"></a>B-树/B树/B_树</h1><p>B树，是一种<strong>平衡的多叉树</strong>，适用于外查找。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/B%E6%A0%91.png" alt="B树"></p>
<p>一棵m阶B树是一棵平衡的m路搜索树：</p>
<ul>
<li>根结点至少有两个子结点，或为空树；</li>
<li>每个非根结点所包含的关键字个数i满足$\ulcorner m/2 \urcorner - 1 \leq i \leq m - 1$；</li>
<li>除根结点和叶子结点外的所有结点的度数正好是关键字总数+1，所以内部子树的个数k满足$\ulcorner m/2 \urcorner \leq k \leq m$;</li>
<li>所有的叶子结点都位于同一层。</li>
</ul>
<p>B树的特点：</p>
<ul>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其<strong>搜索性能等价于在关键字全集内做一次二分查找</strong>；</li>
<li>自动层次控制；</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/B+%E6%A0%91.png" alt="B+树"></p>
<p>B+树，一种🌲数据结构，是一个n叉树，每个结点通常有多个孩子，一棵B+树包含根结点、内部结点、叶子结点，根结点可能是一个叶子结点，也可能是包含两个或以上孩子结点的结点。</p>
<p>优点；</p>
<ul>
<li>能够保持数据稳定有序；</li>
<li>其插入与修改拥有较稳定的对数时间复杂度。</li>
</ul>
<p>B+树通常用于数据库和操作系统的文件系统中，NTFS、ReiserFS、NSS、XFS、JFS、ReFS、BFS等文件系统都在使用B+树作为<strong>元数据索引</strong>。</p>
<h3 id="B-树-vs-B-树"><a href="#B-树-vs-B-树" class="headerlink" title="B-树 vs B+树"></a>B-树 vs B+树</h3><ul>
<li>B+树有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点；</li>
<li>B+树所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；</li>
<li>B+树所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。 </li>
</ul>
<p>通常在B+树上有两个头指针，一个指向根结点，一个<strong>指向关键字最小的叶子结点</strong>。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/B*%E6%A0%91.png" alt="B*树"></p>
<p>B*树，是在B+树的基础上，在非根和非叶子结点再增加指向兄弟的指针。</p>
<p>B*树定义了非叶子结点关键字个数至少为$(2/3) * M$，即块的最低使用率为$2/3$。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/yangyutong0506/article/details/78204953" target="_blank" rel="noopener">https://blog.csdn.net/yangyutong0506/article/details/78204953</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/79980618" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79980618</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1645429373049393021&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1645429373049393021&amp;wfr=spider&amp;for=pc</a></li>
<li><a href="https://blog.csdn.net/wyqwilliam/article/details/82935922" target="_blank" rel="noopener">https://blog.csdn.net/wyqwilliam/article/details/82935922</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>GCD</title>
    <url>/2020/07/29/GCD/</url>
    <content><![CDATA[<h1 id="GCD任务分组和线程数量控制"><a href="#GCD任务分组和线程数量控制" class="headerlink" title="GCD任务分组和线程数量控制"></a>GCD任务分组和线程数量控制</h1><p>利用GCD的<code>dispatch_group_t</code>和<code>semaphore</code>功能，可以对任务分组和控制线程数量，并且在所有任务执行完成之后得到通知。</p>
<p>GCD可分为4类：主线程队列、全局并行队列、串行队列、并行队列</p>
<h2 id="GCD控制线程数量"><a href="#GCD控制线程数量" class="headerlink" title="GCD控制线程数量"></a>GCD控制线程数量</h2><p>GCD不像NSOperation直接提供线程数量控制的方法，需要通过GCD的<strong>semaphore</strong>功能达到控制线程数量的效果。</p>
<ul>
<li><code>dispatch_semaphore_create(long value)</code>，利用给定的值创建一个新的可计数的信号量；</li>
<li><code>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</code>，如果信号量大于0，信号量-1，执行程序，否则等待信号量；</li>
<li><code>dispatch_semaphore_signal(dispatch_semaphore_t dsema);</code>，增加信号量。</li>
</ul>
<h2 id="GCD任务分组"><a href="#GCD任务分组" class="headerlink" title="GCD任务分组"></a>GCD任务分组</h2><p>GCD的<code>**dispatch_group_t**</code>功能可将多个任务进行分组，等待分组里面的所有任务执行完成后，GCD的<code>dispatch_group_notify</code>方法可以通知。</p>
<h2 id="dispatch-async异步调度"><a href="#dispatch-async异步调度" class="headerlink" title="dispatch_async异步调度"></a>dispatch_async异步调度</h2><p>调用dispatch_async将任务抛到<strong>dispatch_get_global_queue(全局并行队列)</strong>, 使第一个任务block中的线程跳到<strong>子线程</strong>。即主线程中创建任务，在子线程中执行任务，执行完任务后通知主线程。</p>
<p>将任务调度到主线程队列中，主线程会去执行该任务, 不死锁的原因是dispatch_sync并没有在主线程中创建, 而是在dispatch_get_global_queue中创建并等待任务执行结束, 由于它是子线程, 所以并不会阻塞。</p>
<h3 id="dispatch-sync-🆚-dispatch-async"><a href="#dispatch-sync-🆚-dispatch-async" class="headerlink" title="dispatch_sync 🆚 dispatch_async"></a>dispatch_sync 🆚 dispatch_async</h3><ul>
<li>dispatch_sync同步调度, 在指定队列中<strong>同步扔进去</strong>一个任务(block), 该任务可能由主线程或子线程处理；</li>
<li>dispatch_async异步调度，在指定队列中扔进去一个任务(block), 该任务可能由主线程或子线程处理。</li>
</ul>
<h1 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h1><p>主线程队列是串行队列, 队列中的任务是一个执行完成后才去执行另一个, 用同步方法将任务1提交到主线程队列就会阻塞住主线程, 而这个刚提交的任务1必须等待主线程中的任务执行完毕才可以执行, 但这时主线程已经被阻塞了, 就是说要等任务1执行完成后才能去执行原有的任务, 所以双方在互相等待而卡住, 最后一个任务也没机会执行到, 就造成了死锁。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/4021b0804da0" target="_blank" rel="noopener">https://www.jianshu.com/p/4021b0804da0</a></li>
<li><a href="https://www.jianshu.com/p/a6146b5764de" target="_blank" rel="noopener">https://www.jianshu.com/p/a6146b5764de</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>GrabCut分割</title>
    <url>/2020/06/06/GrabCut%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="GrabCut分割"><a href="#GrabCut分割" class="headerlink" title="GrabCut分割"></a>GrabCut分割</h1><p>前景/背景的颜色模型：</p>
<ul>
<li>假定前景和背景为高斯混合模型GMM；</li>
<li>对于每个要素，均来自于目标GMM/背景GMM的某个高斯分量；</li>
<li>用边界项来表示邻域像素间不连续的惩罚，若两邻域像素差别很小，则属于同一目标/背景的可能性就大，反之可能为边缘；</li>
<li>通过<a href="/2020/06/06/kmeans%E8%81%9A%E7%B1%BB/" title="kmeans聚类">kmeans聚类</a>算法迭代获得。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GrabCut.png" alt="GrabCut"></p>
<p>算法流程：</p>
<ol>
<li>使用标记初始化颜色模型（k=5）；</li>
<li>迭代进行GraphCut；<ul>
<li>优化前景/背景的颜色模型；</li>
<li>能量会随着不断迭代变小；</li>
<li>分割效果也越来越好。</li>
</ul>
</li>
</ol>
<h2 id="高斯混合模型GMM"><a href="#高斯混合模型GMM" class="headerlink" title="高斯混合模型GMM"></a>高斯混合模型GMM</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GMM.png" alt="GMM"></p>
<p>两组点分别通过两个不同的正态分布随机生成。</p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphCuts分割</title>
    <url>/2020/06/06/GraphCuts%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="GraphCuts分割"><a href="#GraphCuts分割" class="headerlink" title="GraphCuts分割"></a>GraphCuts分割</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GraphCuts.png" alt="GraphCuts"></p>
<ul>
<li>普通顶点对应于图像中的每个像素。每两个邻域顶点的连接为一条边。</li>
<li>两个终端顶点：S(source:前景)、T(sink:背景)。每个普通顶点和这2个终端顶点进行连接，称为第二种边。</li>
</ul>
<p>GraphCuts中的Cuts指这样一个边的集合，该集合中的所有边的断开，会导致残留S和T图的分开，被称为割。<br>如果一个割，它的边的所有权值之和最小，就称其为<strong>最小割</strong>，即GraphCuts的结果。</p>
<p>基于能量的算法：<br>    $E(A) = \lambda \cdot R(A) + B(A)$<br>    $R(A) = \sum_{p \in \mathcal{P}} R_p(A_p)$<br>    $B(A) = \sum_{ {p,q} \in \mathcal{N} } B_{ {p,q} } \cdot \delta(A_p,A_q)$<br>    <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GraphCuts%E8%83%BD%E9%87%8F.png" alt="GraphCuts能量"><br><em>区域项R(A)、边界项B(A)</em></p>
<p>R是为像素p分配标签$I_p$的惩罚：<br>    当像素p的灰度值属于目标的概率大于背景，$R_p(1) &lt; R_p(0)$，即像素p更有可能属于目标时，将p归为目标会使能量R(L)更小。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%9B%BE%E5%89%B2%E5%89%8D%E8%83%8C%E6%99%AF%E5%88%86%E5%89%B2%E5%85%AC%E5%BC%8F.png" alt="图割前背景分割公式"><br>B是像素p和q之间不连续的惩罚，一般来说，如果p和q越相似，B越大；若非常不同，B趋向于0。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GraphCuts%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="GraphCuts基本操作过程"></p>
<p>基本操作过程：</p>
<ol>
<li>先取两个种子点；</li>
<li>然后建立一个图，图中边的粗细表示对应权值大小；</li>
<li>找到权值和最小的边的组合；</li>
<li>完成图像分割。</li>
</ol>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客</title>
    <url>/2020/03/09/Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo-GitHub-Pages搭建个人博客"><a href="#Hexo-GitHub-Pages搭建个人博客" class="headerlink" title="Hexo + GitHub Pages搭建个人博客"></a>Hexo + GitHub Pages搭建个人博客</h1><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! </p>
<h2 id="创建Hexo"><a href="#创建Hexo" class="headerlink" title="创建Hexo"></a>创建Hexo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p><code>npm install</code> 报错，解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf ~&#x2F;.node-gyp</span><br><span class="line">sudo npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br><span class="line">sudo npm i --unsafe-perm</span><br></pre></td></tr></table></figure>
<p><em>配置后更新版本等会比较麻烦，不配置同样可以使用</em></p>
<h2 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h2><p>编辑 <code>_config.yml</code> 配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:***&#x2F;***.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p><code>ERROR Deployer not found: git</code> 报错，解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>遇到 <code>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</code> 问题，安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p><em>本人使用的是<a href="https://www.aliyun.com/?utm_content=se_1000301881&accounttraceid=52e2158134cd4376ab19089abd0757e9llgh" target="_blank" rel="noopener">阿里云</a>的域名</em></p>
<ol>
<li>在终端中 <code>ping ***.github.io</code> 得到一个ip地址，copy下来；</li>
<li>在阿里云域名设置中添加解析：<ul>
<li>主机记录–www，记录类型–A，解析线路–默认不修改，<br>  记录值为 <code>步骤1</code> 中ping到的ip，TTL–默认不修改；</li>
<li>主机记录–@，记录类型–A，解析线路–默认不修改，<br>  记录值为 <code>步骤1</code> 中ping到的ip，TTL–默认不修改；</li>
</ul>
</li>
<li>在GitHub中打开username.github.io仓库中的设置，找到 <code>Custom domain</code> 将自己的域名填入其中，点击保存；</li>
<li>在本地仓库中打开 <code>source</code> 文件夹，添加 <code>CNAME</code> 文件，内容为自己的域名；</li>
<li>重新部署，等待几分钟即可访问。</li>
</ol>
<h2 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h2><p>网上有大量主题可供使用，按照主题配置修改即可。<br>本博客基于<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next主题</a>进行配置。</p>
<h3 id="图标查询"><a href="#图标查询" class="headerlink" title="图标查询"></a><a href="https://fontawesome.dashgame.com" target="_blank" rel="noopener">图标查询</a></h3><p><a href="https://fontawesome.dashgame.com" target="_blank" rel="noopener">https://fontawesome.dashgame.com</a></p>
<h3 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><ol>
<li>在GitHub新建一个repositories用于存储图片；</li>
<li>在个人GitHub账户中的 <code>Settings</code> 中选择 <code>Developer settings</code> 创建 <code>Personal access tokens</code>，勾选 <code>repo</code> 一栏即可；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/picgo-token.png" alt="picgo-token"></li>
<li>安装PicGo；</li>
<li>配置PicGo（使用了cdn加速）；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/picgo-github.png" alt="picgo-github"></li>
<li>配置完成后即可上传图片了。</li>
</ol>
<h2 id="数学公式-最新版的直接在配置文件里的mathjax设为true即可"><a href="#数学公式-最新版的直接在配置文件里的mathjax设为true即可" class="headerlink" title="数学公式(最新版的直接在配置文件里的mathjax设为true即可)"></a>数学公式(最新版的直接在配置文件里的mathjax设为true即可)</h2><h3 id="安装插件：-1"><a href="#安装插件：-1" class="headerlink" title="安装插件："></a>安装插件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure>

<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p><a href="https://www.livere.com/login_form" target="_blank" rel="noopener">livere</a>，参考下面博客美化设置。</p>
<h3 id="设置文章阴影效果"><a href="#设置文章阴影效果" class="headerlink" title="设置文章阴影效果"></a>设置文章阴影效果</h3><p>因为在网上没有找到适合新版本7.7的方法，自己摸索尝试解决：<br>找到 <code>/themes/next/source/css/_common/components/post/post.styl</code> 中的 <code>.use-motion</code> 块，修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (hexo-config(&#39;motion.transition.post_block&#39;)) &#123;</span><br><span class="line">  .post-block &#123;</span><br><span class="line">      opacity: 0;</span><br><span class="line">      background: transparent; &#x2F;&#x2F;透明</span><br><span class="line">  &#125;</span><br><span class="line">  .pagination, .comments &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://shenzekun.cn/hexo的next主题个性化配置教程.html" target="_blank" rel="noopener">http://shenzekun.cn/hexo的next主题个性化配置教程.html</a><br><a href="https://zhuanlan.zhihu.com/p/30836436" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30836436</a><br><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a><br><a href="https://tieba.baidu.com/p/6440743671" target="_blank" rel="noopener">https://tieba.baidu.com/p/6440743671</a><br><a href="https://www.cnblogs.com/aoguai/p/11481253.html" target="_blank" rel="noopener">https://www.cnblogs.com/aoguai/p/11481253.html</a><br><a href="https://blog.uuk4.com/2019/05/09/hexo中插入数学公式/" target="_blank" rel="noopener">https://blog.uuk4.com/2019/05/09/hexo中插入数学公式/</a></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2020/07/10/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>基本数据类型：byte、short、int、long、float、double、boolean、char。<br>引用数据类型：类、接口、数组。<br>三大特性：封装、继承、多态(overload参数不同，override方法覆盖)。</p>
<p>Java不支持多继承：因为可能会产生多继承冲突(子类同时调用多个父类的同一方法等)问题。</p>
<h1 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h1><p>Java的JVM内存可分为3个区：堆heap、栈stack、方法区method。</p>
<ol>
<li>堆：提供所有类实例和数组对象存储区域；<ol>
<li>jvm只有一个堆区heap被所有线程共享；</li>
<li>堆中不存放基本数据类型和对象引用，只存放对象本身；</li>
</ol>
</li>
<li>栈：每个线程包含一个栈区；<ol>
<li>栈中只保存基础数据类型对象和自定义对象的引用(不是对象)，对象都存放在堆中；</li>
<li>每个栈中的数据(原始类型和对象引用)都是私有的，其它栈不能访问；</li>
</ol>
</li>
<li>方法区/静态区：被所有线程共享，包含所有的class和static变量；<ol>
<li>方法区中包含的都是在整个程序中永远唯一的元素，如class、static变量；</li>
<li>运行时常量池都分配在Java虚拟机的方法区中。</li>
</ol>
</li>
</ol>
<h1 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals 和 == 的区别"></a>equals 和 == 的区别</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>若没有对Object的equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址，反之，比较的是内容。</p>
<ul>
<li>类覆盖了equals()方法，<strong>一般都覆盖equals()方法来比较两个对象的内容是否相等</strong>，若相同返回true；</li>
<li>类没有覆盖equals()方法，通过equals()比较类的两个对象时，等价于“==”。</li>
</ul>
<p><em>equals()方法不能作用于基本数据类型的变量。</em></p>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>判断的是两个<strong>对象的地址</strong>，即两个对象是否为同一对象。</p>
<ul>
<li>对于基本数据类型，比较的是值；</li>
<li>对于引用数据类型，比较的是<strong>内存地址</strong>。</li>
</ul>
<h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h2><p>这两种类型的锁，是人们定义出来的概念/思想，主要是指看待<strong>并发同步</strong>的角度。</p>
<h3 id="乐观锁-Compare-and-Swap"><a href="#乐观锁-Compare-and-Swap" class="headerlink" title="乐观锁 Compare and Swap"></a>乐观锁 Compare and Swap</h3><p><em>通过CAS自旋实现原子操作的更新，典型例子就是原子类。</em></p>
<p>每次取拿数据的时候，都认为别人不会进行修改，所以不会上锁。<br>在更新的时候会判断在此期间有没有别人取更新该数据，一般使用<code>数据版本机制</code>或<code>CAS操作</code>实现。</p>
<ol>
<li>数据版本机制<ol>
<li>使用版本号：<code>update table set xxx=#{xxx}, version=version+1 where id=#{id} and version=#{version};</code><ol>
<li>一般在数据表中添加一个数据版本号version字段，表示数据被修改的次数。</li>
<li>在提交更新时，若读到的version值和当前数据库中的version值相等才更新，否则重试更新操作，直到更新成功为止。</li>
</ol>
</li>
<li>使用时间戳：和版本号类似。</li>
</ol>
</li>
<li>CAS操作<ul>
<li>CAS操作中包含三个操作数：读写内存位置V、进行比较的预期原值A、拟写入的新值B。</li>
<li>如果内存位置V的值与预期原值A相匹配，处理器会自动将该位置值更新为新值B，否则处理器不做处理。</li>
<li>当多个线程尝试使用CAS同时更新同一个变量时，<strong>只有其中一个线程能更新变量的值</strong>，失败的线程被告知竞争失败，重新尝试，不会挂起。</li>
</ul>
</li>
</ol>
<p>优点：</p>
<ul>
<li>CAS是CPU指令级的操作，只有一步原子操作，速度非常快。</li>
<li>CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了。</li>
<li>适用于多读的应用类型，可提高吞吐量。</li>
</ul>
<p><em>java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式。</em></p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最坏的情况，每次拿数据时都认为别人会修改，所以，每次在拿数据时都会上锁。<br>别人想拿数据时会被阻塞，直到它拿到锁。</p>
<p>在对任意记录进行修改前，先尝试为该记录<strong>添加排它锁 exclusive locking</strong>；<br>如果加锁失败，说明该记录正在被修改，当前查询可能要等待或抛出异常。<em>具体响应方式有开发者根据实际需要决定。</em><br>如果加锁成功，就对记录做修改，事务完成后就会解锁。</p>
<p>适用于写操作多的场景。</p>
<p><em>Java中的synchronized关键字修饰的都是悲观锁。</em></p>
<h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h2><p>独享锁和共享锁是通过AQS来实现的，通过不同的方法，来实现独享或共享。</p>
<ul>
<li>独享锁：锁一次只能被一个线程所持有；如Java中的<code>Synchronized</code>、<code>ReentrantLock</code>、<code>ReadWriteLock</code>的写锁。</li>
<li>共享锁：该锁可被多个线程持有；如Java中<code>ReadWriteLock</code>的读锁。</li>
</ul>
<p><code>ReadWriteLock</code>的读写、写读、写写的过程是互斥的。</p>
<p><strong>AbstractQueuedSynchronizer</strong><br>AQS维护一个代表共享资源(volatile int state)和一个FIFO线程等待队列(多线程争用资源被阻塞时会进入此队列)。<br>AQS定义两种资源共享方式：</p>
<ul>
<li>Exclusive：独占，只有一个线程能执行；</li>
<li>Share：共享，多个线程可同时执行。<br>自定义同步器在实现时只需实现state的获取和释放方式即可。</li>
</ul>
<h3 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h3><p>对<strong>独享锁/共享锁的具体实现</strong>。</p>
<ul>
<li>互斥锁：在Java中的具体实现<code>ReentrantLock</code>；</li>
<li>读写锁：在Java中的具体实现<code>ReadWriteLock</code>；</li>
</ul>
<p>读写锁的性能都会比排他锁要好，因为大多数场景读是多于写的。<br>在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。<br>Java并发包提供读写锁的实现是ReentrantReadWriteLock。</p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁/递归锁，指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p>
<p><strong>可重入锁可一定程度避免死锁。</strong></p>
<p>如<code>ReentrantLock</code>、<code>Synchronized</code>等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized void setA() throws Exception&#123;</span><br><span class="line">　　Thread.sleep(1000);</span><br><span class="line">　　setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized void setB() throws Exception&#123;</span><br><span class="line">　　Thread.sleep(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若没有可重入锁，setB可能不会被当前线程执行，可能造成死锁。</p>
<h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><ul>
<li>公平锁：指多个线程按照申请锁的顺序来获取锁。</li>
<li>非公平锁：指多个线程获取锁的顺序不一定按照申请锁的顺序，吞吐量比公平锁大。</li>
</ul>
<p><code>ReentrantLock</code>通过构造函数指定(通过AQS来实现调度)该锁是否为公平锁，默认是非公平锁。<br><code>synchronized</code>是一种非公平锁。</p>
<h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p><em>一种锁的设计，并非具体结构。</em></p>
<p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁。</p>
<p><strong>ConcurrentHashMap</strong></p>
<ul>
<li>其并发的实现就是通过分段锁的形式，来实现高效的并发操作；</li>
<li>分段锁称为Segment(继承自ReentrantLock)，类似于HashMap结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；</li>
</ul>
<p>当需要<strong>put</strong>元素的时候，并不是对整个hashmap进行加锁，而是</p>
<ol>
<li>先通过hashcode来确定要放到那个分段；</li>
<li>对该分段进行加锁；</li>
<li>当多线程put时，只要不放在一个分段中，即可实现真正的并行的插入。</li>
</ol>
<h2 id="偏向锁-轻量级锁-重量级锁：针对synchronized"><a href="#偏向锁-轻量级锁-重量级锁：针对synchronized" class="headerlink" title="偏向锁/轻量级锁/重量级锁：针对synchronized"></a>偏向锁/轻量级锁/重量级锁：针对<code>synchronized</code></h2><p>这3种锁的状态是通过<strong>对象监视器在对象头中的字段</strong>来表明。</p>
<ul>
<li>偏向锁：一段同步代码<strong>一直被一个线程访问</strong>，该线程会自动获取锁，降低获取锁的代价。</li>
<li>轻量级锁：当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，其它线程会通过自旋的形式尝试获取锁，不会阻塞。</li>
<li>重量级锁：当锁为轻量级锁时，另一个线程虽然自旋，但自旋不会一直持续下去，当自旋一定次数时，还未获取到锁，就会进入阻塞，该锁膨胀为重量级锁。</li>
</ul>
<p><strong>重量级锁会让它申请的线程进入阻塞，性能降低。</strong></p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>指尝试获取锁的线程不会立即阻塞，而是采用<strong>循环</strong>的方式去尝试获取锁。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%87%AA%E6%97%8B%E9%94%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC.png" alt="自旋锁优先级反转"></p>
<p>优点：减少线程上下文切换的消耗；<br>缺点：循环会消耗CPU。</p>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://www.cnblogs.com/hustzzl/p/9343797.html" target="_blank" rel="noopener">https://www.cnblogs.com/hustzzl/p/9343797.html</a></li>
<li><a href="https://www.jianshu.com/p/ab2c8fce878b" target="_blank" rel="noopener">https://www.jianshu.com/p/ab2c8fce878b</a></li>
<li><a href="https://www.jianshu.com/p/0fdf60ec73ae" target="_blank" rel="noopener">https://www.jianshu.com/p/0fdf60ec73ae</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java框架</title>
    <url>/2020/03/10/Java%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Java集合框架图"><a href="#Java集合框架图" class="headerlink" title="Java集合框架图"></a>Java集合框架图</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Java集合框架图"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE.jpg" alt="Java集合类图"></p>
<p>LinkedList类实现了Queue接口，因此可以将LinkedList当成Queue来用。</p>
<p>集合特点：</p>
<ul>
<li><p>List：有序、可重复；</p>
<ul>
<li><p>ArrayList：数组-查询快、增删慢；<br>扩容机制：</p>
<ol>
<li>先对传进来的初始化参数initalCapcity初始容量进行判断，若为0初始化为一个空数组；若非空，则初始化一个容量为10的数组；</li>
<li>扩容：当数组大小 &gt; 初始容量时，扩容为原来的1.5倍；</li>
<li>扩容方式：对原数组进行拷贝为新数组，原数组被GC回收。</li>
</ol>
</li>
<li><p>LinkedList：链表-查询慢、增删快；</p>
</li>
</ul>
</li>
<li><p>Set：有序、不可重复；</p>
<ul>
<li>TreeSet：遍历时必须在实现类实现Comparable接口，重写ComparaTo方法；</li>
<li>HashSet：使用成员对象来计算hashcode值，使用equals()判断对象是否相等。</li>
</ul>
</li>
<li><p>Map：键值对，键不重复；</p>
<ul>
<li>HashMap：基于哈希表实现，不保存对象的排列次序，允许键值为null、非Synchronized，但collection框架可保证Synchronized；为了优化HashMap空间的使用，可以调优初始容量和负载因子。</li>
<li>TreeMap：基于红黑树实现，保存对象的排列次序；TreeMap没有调优选项，因为该树总处于平衡状态。</li>
</ul>
</li>
</ul>
<h1 id="SSM-框架集"><a href="#SSM-框架集" class="headerlink" title="SSM 框架集"></a>SSM 框架集</h1><table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">框架</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">Spring</td>
<td align="center">一个轻量的控制反转和面向切面的容器框架。其中，IOC容器，可装载bean(类)，减少使用类时的初始化；aop；事务管理等。</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">SpringMVC</td>
<td align="center">用于web层，相当于controller，用来处理用户请求。</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">MyBatis</td>
<td align="center">自由控制sql，提升数据库访问效率；使用xml方式组织管理sql，易于修改。</td>
</tr>
</tbody></table>
<p><strong>一般目录结构为：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">    - main          &#x2F;&#x2F; 用于存放java代码和一些资源文件</span><br><span class="line">        - java          &#x2F;&#x2F; 存放Java代码，使用Build Path-&gt;Use as Source Folder，新建的包相当于在这里新建文件夹</span><br><span class="line">            - dao           &#x2F;&#x2F; 数据访问层(接口)，与数据打交道，可以是数据库操作、文件读写操作、redis缓存操作等</span><br><span class="line">            - entity        &#x2F;&#x2F; 实体类，与数据库表相对应，封装dao层取出来的数据为一个对象，一般只在dao层与service层传输，存放与业务相关实体类</span><br><span class="line">            - dto           &#x2F;&#x2F; 数据传输层，用于service层与web层间的传输，很多时候一个entity不能满足业务需求，也可存放与业务相关性小的数据实体类</span><br><span class="line">            - service       &#x2F;&#x2F; 业务逻辑(接口)</span><br><span class="line">            - serviceImpl   &#x2F;&#x2F; 业务逻辑(实现)，实现业务接口，一般事物控制在此处</span><br><span class="line">            - web           &#x2F;&#x2F; 控制器，SpringMVC在此处发挥作用</span><br><span class="line">        - resources     &#x2F;&#x2F; 存放资源文件，如Spring，mybatis，log配置文件</span><br><span class="line">            - mapper        &#x2F;&#x2F; 存放dao中每个方法对应的sql</span><br><span class="line">            - spring        &#x2F;&#x2F; 存放Spring相关的配置文件，包含dao、service、web三层</span><br><span class="line">                - spring-dao.xml        &#x2F;&#x2F; 配置数据库连接池、配置连接属性等</span><br><span class="line">                - spring-service.xml    &#x2F;&#x2F; 配置事物管理器等</span><br><span class="line">                - spring-web.xml        &#x2F;&#x2F; 开启SpringMVC注解模式、对静态资源处理、扫描web层等</span><br><span class="line">                - mybatis-config.xml    &#x2F;&#x2F; 连接数据库时的相关配置，如驼峰命名转换等</span><br><span class="line">            - sql</span><br><span class="line">            - jdbc.properties   &#x2F;&#x2F; 数据库配置相关参数</span><br><span class="line">        - webapp        &#x2F;&#x2F; 存放前端的静态资源</span><br><span class="line">            - resources     &#x2F;&#x2F; 项目的静态资源</span><br><span class="line">            - css</span><br><span class="line">            - images</span><br><span class="line">            - js</span><br><span class="line">        - WEB-INF       &#x2F;&#x2F; 外部浏览器无法访问</span><br><span class="line">            - jsp</span><br><span class="line">            - lib       &#x2F;&#x2F; 用于管理jar包</span><br><span class="line">            web.xml     &#x2F;&#x2F; 全局配置</span><br><span class="line">    - test          &#x2F;&#x2F; 测试分支</span><br><span class="line">        - java          &#x2F;&#x2F; 测试Java代码，应遵循包名相同的原则，使用Build Path-&gt;Use as Source Folder</span><br><span class="line">        - resources</span><br><span class="line">pom.xml     &#x2F;&#x2F; 使用maven进行管理jar包，在pom.xml添加相应依赖</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h1><table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">框架内容</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M</td>
<td align="center">model</td>
<td align="center">处理数据逻辑部分，负责在数据库中读取数据</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">view</td>
<td align="center">处理数据显示部分，依据模型数据创建</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">control</td>
<td align="center">处理用户交互部分，负责从试图读取数据，控制用户输入，并向模型发送数据</td>
</tr>
</tbody></table>
<p>典型的MVC框架为 <code>JSP + servlet + javabean</code> 模式。</p>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-collections.html</a></li>
<li><a href="https://www.cnblogs.com/williamjie/p/11458835.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/11458835.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java测试</title>
    <url>/2020/03/10/Java%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="开发者测试"><a href="#开发者测试" class="headerlink" title="开发者测试"></a>开发者测试</h1><p><em>插件 eclemma查询覆盖率，最新版eclipse已内置</em></p>
<h2 id="利用junit进行测试，使用assert断言进行变异测试"><a href="#利用junit进行测试，使用assert断言进行变异测试" class="headerlink" title="利用junit进行测试，使用assert断言进行变异测试"></a>利用junit进行测试，使用assert断言进行变异测试</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Junit%E6%B5%8B%E8%AF%95.png" alt="Junit测试"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testNextDay() &#123;</span><br><span class="line">	assertEquals(10&#x2F;15&#x2F;2019,10&#x2F;14,2019);</span><br><span class="line">	assertEquals(11&#x2F;1&#x2F;2019,10&#x2F;31,2019);</span><br><span class="line">	assertEquals(2&#x2F;29&#x2F;2000,2&#x2F;28,2000);</span><br><span class="line">	assertEquals(2&#x2F;29&#x2F;2004,2&#x2F;28,2004);</span><br><span class="line">	assertEquals(3&#x2F;1&#x2F;2001,2&#x2F;28,2001);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test(expected&#x3D;ArithmeticException.class)</span><br><span class="line">&#x2F;&#x2F;抛出异常</span><br><span class="line">@Test(timeout&#x3D;毫秒)</span><br><span class="line">&#x2F;&#x2F;针对死循环进行测试</span><br><span class="line"></span><br><span class="line">@BeforeClass</span><br><span class="line">@AfterClass</span><br><span class="line">&#x2F;&#x2F;最先执行，static修饰</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">@After</span><br><span class="line">&#x2F;&#x2F;每个方法单独运行</span><br><span class="line">@Ignore</span><br><span class="line">&#x2F;&#x2F;该测试方法会被忽略</span><br><span class="line"></span><br><span class="line">@RunWith</span><br><span class="line">&#x2F;&#x2F;更改测试运行器org.junit.runner.Runner</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="移动应用测试"><a href="#移动应用测试" class="headerlink" title="移动应用测试"></a>移动应用测试</h1><h2 id="配置appium"><a href="#配置appium" class="headerlink" title="配置appium"></a>配置appium</h2><p>终端打开，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb connect xxx.xxx.xxx.xxx:5555</span><br></pre></td></tr></table></figure>
<p>将app的环境配置复制到appium中进行启动会话；</p>
<h2 id="利用Android-SDK中的UI工具进行组建-控件的查询"><a href="#利用Android-SDK中的UI工具进行组建-控件的查询" class="headerlink" title="利用Android SDK中的UI工具进行组建/控件的查询"></a>利用Android SDK中的UI工具进行组建/控件的查询</h2><p><em>与appium兼容性很差，经常需要关闭appium后再打开</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过id获取组件</span><br><span class="line">driver.findElementById(&quot;cn.etouch.ecalendar:id&#x2F;rl_toutiao_img&quot;).click();</span><br><span class="line">&#x2F;&#x2F;通过XPath获取组件</span><br><span class="line">driver.findElementByXPath(&quot;&#x2F;&#x2F;android.widget.TextView[@text&#x3D;&#39;头条&#39;]&quot;).click();</span><br><span class="line">driver.findElementById(&quot;cn.etouch.ecalendar:id&#x2F;fl_refresh_icon&quot;).click();</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">driver.sendKeyEvent(AndroidKeyCode.BACK);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="自主可控测试"><a href="#自主可控测试" class="headerlink" title="自主可控测试"></a>自主可控测试</h1><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><ul>
<li>eclipse:<br>  driver.get(“url”);<br>  Thread.sleep(1000);</li>
<li>word:<br>  打开操作文档，按要求查找网页中对应的元素进行输入等操作；</li>
<li>chrome:<br>  F12 检索页面元素，获取元素xpath；</li>
<li>eclipse:<br>  driver.findElement(By.xpath(“//*[@id=&quot;username&quot;]”)).sendKeys(“username”);</li>
</ul>
<h2 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h2><ul>
<li>badboy录制脚本：<br>  输入网址，对测试部分进行录制，导出为jmeter文件</li>
<li>JMeter:<br>  打开录制好的文件，更改名称，更改线程组相关设置，左侧右键add-&gt;LogicController-&gt;TransactionController;将Step移动到Transaction下面，在最后一个操作右键add-&gt;Timer-&gt;SynchronizingTimer;修改组人数为10；在最后操作上进行参数化设置${name}；</li>
<li>创建csv文件：<br>  在文件右键add-&gt;ConfigElement-&gt;CSVDataSetConfig;修改VariableNames为对应的名称即可。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程</title>
    <url>/2020/03/10/Java%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h1><h2 id="websocket：持久化协议"><a href="#websocket：持久化协议" class="headerlink" title="websocket：持久化协议"></a>websocket：持久化协议</h2><p>实现服务器端主动向客户端推送信息，客户端也可主动向服务器发送请求，实现双向对话。<br>具体来讲，就是先通过客户端使用http协议向服务器发送请求，建立长链接；建立长链接之后，服务器即可主动向客户端发送消息；确定一个时间，经过该时间后，客户端向服务器发送请求确认，避免该🔗断开。</p>
<p><em>为了兼容浏览器，在握手阶段使用HTTP协议。</em></p>
<ul>
<li>websocket建立在TCP协议上，服务器端端实现较容易；</li>
<li>与HTTP协议兼容性较好，默认端口为80或443，可通过http代理的服务器；</li>
<li>数据格式轻量，性能开销较小，通信高效；</li>
<li>可以发送文本，也可以发送二进制数据；</li>
<li>没有同源限制，客户端可以与任意服务器通信；</li>
<li>协议表示符是ws，若需🔐，使用wss，服务器网址为url。</li>
</ul>
<h2 id="典型的websocket🤝"><a href="#典型的websocket🤝" class="headerlink" title="典型的websocket🤝"></a>典型的websocket🤝</h2><ul>
<li>浏览器请求：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket			&#x2F;&#x2F; websocket协议</span><br><span class="line">Connection: Upgrade			&#x2F;&#x2F; 告诉服务器，发起的请求为Upgrade对应的websocket协议</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;			&#x2F;&#x2F; Base64 encode值，由浏览器自动生成，用于验证是否使用websocket协议</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat			&#x2F;&#x2F; 用户定义的字符串，用于区分URL下不同服务所需要的协议</span><br><span class="line">Sec-WebSocket-Version: 13			&#x2F;&#x2F; websocket版本</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure></li>
<li>服务器返回：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p><em>参考：</em><br><a href="https://www.cnblogs.com/jieerma666/p/10342435.html" target="_blank" rel="noopener">用JAVA分别实现WebSocket客户端与服务端</a><br><a href="https://www.cnblogs.com/nnngu/p/9347635.html" target="_blank" rel="noopener">看完让你彻底理解 WebSocket 原理，附完整的实战代码</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac常用配置</title>
    <url>/2020/03/08/Mac%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Mac布局设置"><a href="#Mac布局设置" class="headerlink" title="Mac布局设置"></a>Mac布局设置</h1><h2 id="重置dock"><a href="#重置dock" class="headerlink" title="重置dock"></a>重置dock</h2><p>在使用过程中，dock可帮助我们更方便快捷的打开、查看打开的软件/程序/文稿等。<br>对于爱瞎折腾的我来说，经常不满意自己的dock图标的设置，所以可使用如下命令恢复初始布局。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults delete com.apple.dock; killall Dock</span><br></pre></td></tr></table></figure>
<p>Tip：此操作会使启动台及桌面4角的热键打乱，均需重新调整。</p>
<h2 id="启动台图标混乱"><a href="#启动台图标混乱" class="headerlink" title="启动台图标混乱"></a>启动台图标混乱</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm ~&#x2F;Library&#x2F;Application\ Support&#x2F;Dock&#x2F;*.db &amp;&amp; killall Dock</span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool true &amp;&amp; killall Dock</span><br></pre></td></tr></table></figure>

<h2 id="使Mac保持清醒（尝试过，但好像没用）"><a href="#使Mac保持清醒（尝试过，但好像没用）" class="headerlink" title="使Mac保持清醒（尝试过，但好像没用）"></a>使Mac保持清醒（尝试过，但好像没用）</h2><p>在<code>terminal</code>使用<code>caffeinate</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">caffeinate -i -t 3600</span><br></pre></td></tr></table></figure>
<p><em>3600代表秒数，3600s=1h</em></p>
<hr>
<h1 id="MAC终端个性化设置"><a href="#MAC终端个性化设置" class="headerlink" title="MAC终端个性化设置"></a>MAC终端个性化设置</h1><h2 id="在bash中省略前缀（现在基本使用zsh代替，配置方式基本相同）"><a href="#在bash中省略前缀（现在基本使用zsh代替，配置方式基本相同）" class="headerlink" title="在bash中省略前缀（现在基本使用zsh代替，配置方式基本相同）"></a>在bash中省略前缀（现在基本使用zsh代替，配置方式基本相同）</h2><p>打开终端，对bashrc进行编辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure>
<p>滑动至最底部，选择PS1行进行修改即可。</p>
<p>默认设置 <code>PS1=&quot;%n@%m %1~ %# &quot;</code></p>
<p><em>命令列表的参数：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\u 显示当前用户的用户名（user name）</span><br><span class="line">\h 显示主机名（host name）</span><br><span class="line">\W 显示当前工作目录的名字（work directory）</span><br><span class="line">\w 当前所在的完整路径</span><br><span class="line">\$ 显示$符作为提示符，如果用户是root的话，则显示#号</span><br><span class="line">\d 现在的系统日期</span><br><span class="line">\t 现在的系统时间</span><br></pre></td></tr></table></figure>

<p><strong>zshrc同理，配置文件为 <code>/etc/zshrc</code></strong></p>
<h2 id="使用zsh代替bash"><a href="#使用zsh代替bash" class="headerlink" title="使用zsh代替bash"></a>使用zsh代替bash</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure>
<ul>
<li>bash的环境变量为<code>.bash_profile</code>;</li>
<li>zsh的环境变量为<code>.zshrc</code>;<br>若要在zsh继续使用bash的环境变量，在zsh环境变量末尾添加<code>source ~/.bash_profile</code>，重启终端即可。</li>
</ul>
<p>若想切换回来，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Homebrew安装及常用命令"><a href="#Homebrew安装及常用命令" class="headerlink" title="Homebrew安装及常用命令"></a>Homebrew安装及常用命令</h1><h2 id="Homebrew安装"><a href="#Homebrew安装" class="headerlink" title="Homebrew安装"></a><a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew安装</a></h2><p>打开终端，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Homebrew常用命令"><a href="#Homebrew常用命令" class="headerlink" title="Homebrew常用命令"></a>Homebrew常用命令</h2><ul>
<li><p>安装软件：<code>brew install ***</code> 或 <code>brew cask install ***</code></p>
</li>
<li><p>搜索软件：<code>brew search ***</code></p>
</li>
<li><p>卸载软件：<code>brew uninstall ***</code> 或 <code>brew cask uninstall ***</code></p>
</li>
<li><p>彻底卸载指定软件，包括旧版本：<code>brew uninstall --force &lt;软件名&gt;</code></p>
</li>
<li><p>更新所有软件：<code>brew update</code> 或 <code>brew cask upgrade</code></p>
</li>
<li><p>更新具体软件：<code>brew upgrade ***</code></p>
</li>
<li><p>显示已安装软件：<code>brew list</code> 或 <code>brew cask list</code></p>
</li>
<li><p>查看软件信息：<code>brew info ***</code> 或 <code>brew home ***</code><br>  brew home指令是用浏览器打开官方网页查看软件信息</p>
</li>
<li><p>查看哪些已安装的程序需要更新： <code>brew outdated</code></p>
</li>
<li><p>清理指定软件的过时包：<code>brew cleanup &lt;软件名&gt;</code></p>
</li>
<li><p>清理所有的过时软件：<code>brew cleanup</code></p>
</li>
<li><p>列出需要清理的内容：<code>brew cleanup -n</code></p>
</li>
<li><p>显示包依赖：<code>brew deps &lt;软件名&gt;</code></p>
</li>
<li><p>查看已安装的包的依赖，树形显示：<code>brew deps --installed --tree</code></p>
</li>
<li><p>显示帮助：<code>brew help</code> 或 <code>brew -h</code></p>
</li>
<li><p>查看版本：<code>brew -v</code></p>
</li>
<li><p>查找历史版本：<code>brew tap homebrew/cask-versions</code></p>
<p>  homebrew安装jdk后，查看安装位置：<code>/usr/libexec/java_home -V</code></p>
</li>
</ul>
<h2 id="安装遇到问题"><a href="#安装遇到问题" class="headerlink" title="安装遇到问题"></a>安装遇到问题</h2><p><code>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</code><br>一般都是由于网络原因，可更换网络，执行如下命令，重新安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">sudo rm -rf Caskroom Cellar Homebrew Frameworks</span><br><span class="line">cd</span><br><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="VScode配置"><a href="#VScode配置" class="headerlink" title="VScode配置"></a>VScode配置</h1><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><ul>
<li>Remote Development</li>
<li>LaTeX Workshop</li>
<li>PicGo<br>  设置方法与 <a href="/2020/03/09/Hexo%E5%8D%9A%E5%AE%A2/" title="图床">图床</a> 基本相同。</li>
<li>python<br>  <em>配合miniconda使用：</em><br>  更改设置<code>shift + command + p</code>，输入<code>user setting</code>，选择<code>workspace</code>，下拉找到<code>Edit in settings.json</code>将文件改为：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;python.venvPath&quot;:&quot;&#x2F;opt&#x2F;miniconda3&#x2F;envs&quot;,</span><br><span class="line">    &quot;python.pythonPath&quot;:&quot;&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;pytorch&#x2F;bin&#x2F;python&quot;,</span><br><span class="line">    &quot;python.venvFolders&quot;:[</span><br><span class="line">        &quot;envs&quot;,</span><br><span class="line">        &quot;.pyenv&quot;,</span><br><span class="line">        &quot;.direnv&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;code-runner.runInTerminal&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="软件无法更新"><a href="#软件无法更新" class="headerlink" title="软件无法更新"></a>软件无法更新</h2><p>修改软件权限，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R $USER ~&#x2F;Library&#x2F;Caches&#x2F;com.microsoft.VSCode.ShipIt&#x2F;</span><br><span class="line">xattr -dr com.apple.quarantine &#x2F;Applications&#x2F;Visual\ Studio\ Code.app</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Homebrew安装，默认有3种方式，完全安装、无界面、基本安装(需要自行配置包)：</p>
<ul>
<li>Full installation:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install mactex</span><br></pre></td></tr></table></figure></li>
<li>Full installation without bundled applications:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install mactex-no-gui</span><br></pre></td></tr></table></figure></li>
<li>Minimal installation:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install basictex</span><br></pre></td></tr></table></figure>
推荐选择第1种方式，如果有较强的基础可选第3种，若使用其它替代工具，可选第2种。</li>
</ul>
<h2 id="数学符号汇总"><a href="#数学符号汇总" class="headerlink" title="数学符号汇总"></a>数学符号汇总</h2><p>这里引用一个别人做好的PDF吧，非常全面！<br><code>https://www.caam.rice.edu/~heinken/latex/symbols.pdf</code></p>
<hr>
<h1 id="将iPhone备份到外置硬盘"><a href="#将iPhone备份到外置硬盘" class="headerlink" title="将iPhone备份到外置硬盘"></a>将iPhone备份到外置硬盘</h1><ol>
<li>找到存储位置：打开Finder，同时按下<code>command+shift+G</code>，输入<code>~/Library/Application\ Support/MobileSync</code>；</li>
<li>将Backup文件夹copy到外置硬盘指定位置；</li>
<li>打开终端，输入<code>ln -s /Volumes/xiaofeiyu/iPhone.backup/Backup ~/Library/Application\ Support/MobileSync</code>，将存放备份位置软链接到备份位置即可。</li>
</ol>
<hr>
<h1 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h1><h2 id="aria2下载器"><a href="#aria2下载器" class="headerlink" title="aria2下载器"></a>aria2下载器</h2><ol>
<li>安装<a href="https://github.com/aria2/aria2" target="_blank" rel="noopener">aria2</a>：<code>brew install aria2</code></li>
<li>创建配置文件 <code>touch ~/.aria2/aria2.conf</code></li>
<li>创建会话保存文件 <code>touch ~/.aria2/aria2.session</code></li>
<li>配置<a href="http://aria2c.com/usage.html" target="_blank" rel="noopener">aria2.conf</a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## &#39;#&#39;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span><br><span class="line">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span><br><span class="line"></span><br><span class="line">## 文件保存相关 ##</span><br><span class="line"></span><br><span class="line"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span><br><span class="line">dir&#x3D;~&#x2F;downloads</span><br><span class="line"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span><br><span class="line">#disk-cache&#x3D;32M</span><br><span class="line"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span><br><span class="line"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span><br><span class="line"># falloc和trunc则需要文件系统和内核支持</span><br><span class="line"># NTFS建议使用falloc, EXT3&#x2F;4建议trunc, MAC 下需要注释此项</span><br><span class="line">#file-allocation&#x3D;none</span><br><span class="line"># 断点续传</span><br><span class="line">continue&#x3D;true</span><br><span class="line"></span><br><span class="line">## 下载连接相关 ##</span><br><span class="line"></span><br><span class="line"># 最大同时下载任务数, 运行时可修改, 默认:5</span><br><span class="line">#max-concurrent-downloads&#x3D;5</span><br><span class="line"># 同一服务器连接数, 添加时可指定, 默认:1</span><br><span class="line">max-connection-per-server&#x3D;5</span><br><span class="line"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span><br><span class="line"># 假定size&#x3D;10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span><br><span class="line">min-split-size&#x3D;10M</span><br><span class="line"># 单个任务最大线程数, 添加时可指定, 默认:5</span><br><span class="line">#split&#x3D;5</span><br><span class="line"># 整体下载速度限制, 运行时可修改, 默认:0</span><br><span class="line">#max-overall-download-limit&#x3D;0</span><br><span class="line"># 单个任务下载速度限制, 默认:0</span><br><span class="line">#max-download-limit&#x3D;0</span><br><span class="line"># 整体上传速度限制, 运行时可修改, 默认:0</span><br><span class="line">#max-overall-upload-limit&#x3D;0</span><br><span class="line"># 单个任务上传速度限制, 默认:0</span><br><span class="line">#max-upload-limit&#x3D;0</span><br><span class="line"># 禁用IPv6, 默认:false</span><br><span class="line">#disable-ipv6&#x3D;true</span><br><span class="line"># 连接超时时间, 默认:60</span><br><span class="line">#timeout&#x3D;60</span><br><span class="line"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span><br><span class="line">#max-tries&#x3D;5</span><br><span class="line"># 设置重试等待的秒数, 默认:0</span><br><span class="line">#retry-wait&#x3D;0</span><br><span class="line"></span><br><span class="line">## 进度保存相关 ##</span><br><span class="line"></span><br><span class="line"># 从会话文件中读取下载任务</span><br><span class="line">input-file&#x3D;&#x2F;Users&#x2F;zzy&#x2F;.aria2&#x2F;aria2.session</span><br><span class="line"># 在Aria2退出时保存&#96;错误&#x2F;未完成&#96;的下载任务到会话文件</span><br><span class="line">save-session&#x3D;&#x2F;Users&#x2F;zzy&#x2F;.aria2&#x2F;aria2.session</span><br><span class="line"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span><br><span class="line">#save-session-interval&#x3D;60</span><br><span class="line"></span><br><span class="line">## RPC相关设置 ##</span><br><span class="line"></span><br><span class="line"># 启用RPC, 默认:false</span><br><span class="line">enable-rpc&#x3D;true</span><br><span class="line"># 允许所有来源, 默认:false</span><br><span class="line">rpc-allow-origin-all&#x3D;true</span><br><span class="line"># 允许非外部访问, 默认:false</span><br><span class="line">rpc-listen-all&#x3D;true</span><br><span class="line"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span><br><span class="line">#event-poll&#x3D;select</span><br><span class="line"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span><br><span class="line">#rpc-listen-port&#x3D;6800</span><br><span class="line"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span><br><span class="line">#rpc-secret&#x3D;&lt;TOKEN&gt;</span><br><span class="line"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="line">#rpc-user&#x3D;&lt;USER&gt;</span><br><span class="line"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="line">#rpc-passwd&#x3D;&lt;PASSWD&gt;</span><br><span class="line"># 是否启用 RPC 服务的 SSL&#x2F;TLS 加密,</span><br><span class="line"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span><br><span class="line">#rpc-secure&#x3D;true</span><br><span class="line"># 在 RPC 服务中启用 SSL&#x2F;TLS 加密时的证书文件,</span><br><span class="line"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span><br><span class="line">#rpc-certificate&#x3D;&#x2F;path&#x2F;to&#x2F;certificate.pem</span><br><span class="line"># 在 RPC 服务中启用 SSL&#x2F;TLS 加密时的私钥文件</span><br><span class="line">#rpc-private-key&#x3D;&#x2F;path&#x2F;to&#x2F;certificate.key</span><br><span class="line"></span><br><span class="line">## BT&#x2F;PT下载相关 ##</span><br><span class="line"></span><br><span class="line"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span><br><span class="line">#follow-torrent&#x3D;true</span><br><span class="line"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span><br><span class="line">listen-port&#x3D;51413</span><br><span class="line"># 单个种子最大连接数, 默认:55</span><br><span class="line">#bt-max-peers&#x3D;55</span><br><span class="line"># 打开DHT功能, PT需要禁用, 默认:true</span><br><span class="line">enable-dht&#x3D;false</span><br><span class="line"># 打开IPv6 DHT功能, PT需要禁用</span><br><span class="line">#enable-dht6&#x3D;false</span><br><span class="line"># DHT网络监听端口, 默认:6881-6999</span><br><span class="line">#dht-listen-port&#x3D;6881-6999</span><br><span class="line"># 本地节点查找, PT需要禁用, 默认:false</span><br><span class="line">#bt-enable-lpd&#x3D;false</span><br><span class="line"># 种子交换, PT需要禁用, 默认:true</span><br><span class="line">enable-peer-exchange&#x3D;false</span><br><span class="line"># 每个种子限速, 对少种的PT很有用, 默认:50K</span><br><span class="line">#bt-request-peer-speed-limit&#x3D;50K</span><br><span class="line"># 客户端伪装, PT需要</span><br><span class="line">peer-id-prefix&#x3D;-TR2770-</span><br><span class="line">user-agent&#x3D;Transmission&#x2F;2.77</span><br><span class="line">peer-agent&#x3D;Transmission&#x2F;2.77</span><br><span class="line"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span><br><span class="line">seed-ratio&#x3D;0</span><br><span class="line"># 强制保存会话, 即使任务已经完成, 默认:false</span><br><span class="line"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span><br><span class="line">#force-save&#x3D;false</span><br><span class="line"># BT校验相关, 默认:true</span><br><span class="line">#bt-hash-check-seed&#x3D;true</span><br><span class="line"># 继续之前的BT任务时, 无需再次校验, 默认:false</span><br><span class="line">bt-seed-unverified&#x3D;true</span><br><span class="line"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span><br><span class="line">bt-save-metadata&#x3D;true</span><br></pre></td></tr></table></figure></li>
<li>运行aria2：<code>aria2c --conf-path=&quot;/Users/zzy/.aria2/aria2.conf&quot; -D</code></li>
<li>设置aria2开机自启<ul>
<li>在 <code>~/.aria2</code> 目录下 <code>touch com.aria2c.plist</code>：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;KeepAlive&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;true&#x2F;&gt;</span><br><span class="line">    &lt;key&gt;Label&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;com.aria2c&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;ProgramArguments&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;string&gt;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;aria2&#x2F;1.35.0&#x2F;bin&#x2F;aria2c&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;string&gt;--rpc-listen-all&#x3D;true&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;string&gt;--rpc-allow-origin-all&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;string&gt;--conf-path&#x3D;&#x2F;Users&#x2F;zzy&#x2F;.aria2&#x2F;aria2.conf&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;array&gt;</span><br><span class="line">    &lt;key&gt;RunAtLoad&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;true&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure></li>
<li>将该文件拷贝到 <code>~/Library/LaunchAgents</code> 启动项中，运行：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp com.aria2c.plist ~&#x2F;Library&#x2F;LaunchAgents&#x2F;com.aria2c.plist</span><br><span class="line">launchctl load -w ~&#x2F;Library&#x2F;LaunchAgents&#x2F;com.aria2c.plist</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="网盘助手（配合油猴，并修改🆔）"><a href="#网盘助手（配合油猴，并修改🆔）" class="headerlink" title="网盘助手（配合油猴，并修改🆔）"></a>网盘助手（配合油猴，并修改🆔）</h2><p>谷歌应用商店搜索 <code>Tampermonkey</code>，安装后点击查找新脚本，选择 <code>GreasyFork</code>，🔍“网盘助手”，安装。</p>
<h2 id="安装YAAW-for-Chrome插件"><a href="#安装YAAW-for-Chrome插件" class="headerlink" title="安装YAAW for Chrome插件"></a>安装YAAW for Chrome插件</h2><p>若出现 <code>Error: Internal server error</code> 错误，使用 <code>lsof -i tcp:6800</code> 查看端口占用情况，<code>kill PID</code> 即可。</p>
<hr>
<h1 id="Sublime设置（基本已被VSCode代替）"><a href="#Sublime设置（基本已被VSCode代替）" class="headerlink" title="Sublime设置（基本已被VSCode代替）"></a>Sublime设置（基本已被VSCode代替）</h1><h2 id="下载并安装Sublime-Text-3"><a href="#下载并安装Sublime-Text-3" class="headerlink" title="下载并安装Sublime Text 3"></a>下载并安装<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a></h2><h2 id="安装软件包管理器"><a href="#安装软件包管理器" class="headerlink" title="安装软件包管理器"></a>安装软件包管理器</h2><p>同时按下control + ` ，在底部控制台运行如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())</span><br></pre></td></tr></table></figure>

<h2 id="Package（最好用的地方）"><a href="#Package（最好用的地方）" class="headerlink" title="Package（最好用的地方）"></a>Package（最好用的地方）</h2><ul>
<li>安装包（建议使用科学上网）<br>同时按下<code>command + shift + p</code>，打开快速菜单，输入<code>pcip</code>，选择<code>Package Control: Install Package</code>，等待数据更新，完成后会显示软件列表。</li>
<li>使用包<br>同时按下<code>command + shift + p</code>，打开快速菜单，选择所需使用的软件包即可；</li>
<li>查看已安装列表<br>同时按下<code>command + shift + p</code>，打开快速菜单，输入<code>list</code>，选择<code>Package Control: List Package</code>；</li>
<li>卸载包<br>同时按下<code>command + shift + p</code>，打开快速菜单，输入<code>pcrp</code>，选择<code>Package Control: Remove Package</code>；</li>
</ul>
<h3 id="个性化配置安装的包"><a href="#个性化配置安装的包" class="headerlink" title="个性化配置安装的包"></a>个性化配置安装的包</h3><p>在菜单栏选择<code>Sublime Text</code>-&gt;<code>Preference</code>-&gt;<code>Package Settings</code>-&gt;<code>Package Control</code>。其下分为两类，一个是软件包默认配置，一般不改；一个是用户个性化设置，可自行设置。</p>
<p><em>推荐几个好用的包：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Markdown Preview：实现浏览器预览markdown文件</span><br><span class="line">- MarkdownEditing：对md文件使用更加友好设置</span><br><span class="line">- LiveReload：实现对md文件在浏览器中的实时刷新</span><br><span class="line">- SideBarEnhancements：在文本左侧添加文件管理列表</span><br><span class="line">- SublimeCodeIntel：代码自动补全</span><br><span class="line">- auto-save：实现md文档到html文件的自动更新</span><br><span class="line">- ConvertToUTF8：打开txt文件</span><br><span class="line">- Codecs33：配合打开txt文件</span><br></pre></td></tr></table></figure>
<ul>
<li>auto-save插件选择 <code>Toggle AutoSave:current file only</code></li>
<li><code>Markdown Preview</code> 在设置中添加配置 <code>&quot;enable_autoreload&quot;: true</code></li>
<li>实现 <code>Markdown Preview</code> 插件中markdown文件浏览器自动刷新：<br>在md文件最后一行添加 <code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5.0&quot;&gt;</code> 即可，或使用 <code>LiveReload</code> 进行配置。</li>
</ul>
<hr>
<h1 id="chrome个性化设置"><a href="#chrome个性化设置" class="headerlink" title="chrome个性化设置"></a>chrome个性化设置</h1><h2 id="为了使Chrome看起来更加干净清爽，去除启动页8个快捷方式："><a href="#为了使Chrome看起来更加干净清爽，去除启动页8个快捷方式：" class="headerlink" title="为了使Chrome看起来更加干净清爽，去除启动页8个快捷方式："></a>为了使Chrome看起来更加干净清爽，去除启动页8个快捷方式：</h2><ol>
<li>打开 <code>chrome://flags</code> ；</li>
<li>查找 <code>instant extended</code> ；</li>
<li>修改 <code>Disable the &#39;instant extended&#39; limit on search suggestions</code> 为 <code>Disable</code> ；</li>
<li>重启chrome；</li>
<li>在右下角找到 <code>自定义此页</code> ；</li>
<li>选择 <code>快捷键</code> ;</li>
<li>勾选 <code>隐藏快捷方式</code> ；</li>
<li>点击 <code>完成</code> 即可。</li>
</ol>
<p><a href="https://bz.zzzmh.cn/#index" target="_blank" rel="noopener">壁纸网站</a></p>
<h1 id="时钟屏保"><a href="#时钟屏保" class="headerlink" title="时钟屏保"></a><a href="https://fliqlo.com/#/screensaver" target="_blank" rel="noopener">时钟屏保</a></h1><p><a href="https://fliqlo.com/#/screensaver" target="_blank" rel="noopener">https://fliqlo.com/#/screensaver</a></p>
<h1 id="精美5K壁纸"><a href="#精美5K壁纸" class="headerlink" title="精美5K壁纸"></a><a href="https://dynamicwallpaper.club/gallery" target="_blank" rel="noopener">精美5K壁纸</a></h1><p><a href="https://dynamicwallpaper.club/gallery" target="_blank" rel="noopener">https://dynamicwallpaper.club/gallery</a><br>将下载好的文件移动至 <code>/Library/Desktop Pictures</code>，然后在系统管理工具中就可见了。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2020/03/09/Markdown/</url>
    <content><![CDATA[<h1 id="md基本标记符号"><a href="#md基本标记符号" class="headerlink" title="md基本标记符号"></a>md基本标记符号</h1><ol>
<li><p>标题<br>支持六级标题，一般在#后跟个空格再写标题内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码</p>
</li>
</ol>
<ul>
<li>单行代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure></li>
<li>多行代码，代码之间分别用三个反引号包起来，且两边的反引号单独占一行。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>
注：为了防止转译，前后三个反引号处加了小括号</li>
</ul>
<ol start="3">
<li><p>字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*倾斜*</span><br><span class="line">**加粗**</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~加删除线~~</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>图片alt就是显示在图片下面的文字，相当于对图片内容的解释；</li>
<li>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可不加；</li>
<li>github和md文件关联的图片地址是有一定的格式的，不显示可将blob改为raw。</li>
</ul>
<ol start="5">
<li>表格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|--:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>第二行分割表头和内容；</li>
<li>- 有一个就行，为了对齐，多加了几个；</li>
<li>文字默认居左，-两边加：表示文字居中，-右边加：表示文字居右；</li>
<li>原生的语法两边都要用 <code>|</code> 包起来。</li>
</ul>
<ol start="6">
<li><p>引用<br>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p>
</li>
<li><p>分割线<br>三个或者三个以上的 - 或者 * 均可。</p>
</li>
<li><p>超链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br></pre></td></tr></table></figure>
<p>Markdown本身语法不支持链接在新页面中打开，可用html的a标签代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表</p>
</li>
</ol>
<ul>
<li>无序列表<br>无序列表用 <code>- + *</code> 任何一种均可，但与内容之间都要有一个空格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure></li>
<li>有序列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure></li>
<li>列表嵌套<br>上一级与下一级间加3个空格即可。</li>
</ul>
<ol start="10">
<li>流程图（GitHub貌似不支持）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>统一建模语言Unified Modeling Language</title>
    <url>/2020/07/12/UML/</url>
    <content><![CDATA[<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>特点：简单、统一、图形化、可表达软件设计中的动态和静态信息。</p>
<p>UML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图。</p>
<p><em>业界使用较多的为<code>Rational Rose</code>和轻量级的开源<code>Umlet</code>。</em></p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><h2 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h2><p>类指<strong>具有相同属性、方法、关系的对象的抽象</strong>，封装了数据和行为，是面向对象程序设计OOP的基础，具有<strong>封装性、继承性、多态性</strong>。</p>
<p>在UML中，类使用包含<strong>类名、属性、操作，并带有分隔线的矩形</strong>表示。</p>
<ul>
<li>类名Name：一个字符串；</li>
<li>属性Attribute，类的特性/成员变量：[可见性]属性名:类型[=默认值]<ul>
<li>可见性表示该属性对类外的元素是否可见；</li>
<li>公有Public对应<code>+</code>；</li>
<li>私有Private对应<code>-</code>；</li>
<li>受保护Protected对应<code>#</code>；</li>
<li>朋友Friendly对应<code>~</code>；</li>
</ul>
</li>
<li>操作Operations，类的任一实例对象都可使用的行为，类的成员方法：[可见性]名称(参数列表)[:返回类型]。</li>
</ul>
<h2 id="接口Interface"><a href="#接口Interface" class="headerlink" title="接口Interface"></a>接口Interface</h2><p>接口，具有类的结构，但<strong>不可被实例化</strong>，只能<strong>被子类实现</strong>。包含抽象操作，但不包含属性。</p>
<p>UML中，接口使用一个<strong>带有名称的小圆圈</strong>来表示。</p>
<h2 id="类图ClassDiagram"><a href="#类图ClassDiagram" class="headerlink" title="类图ClassDiagram"></a>类图ClassDiagram</h2><p>类图，用来<strong>显示系统中的类、接口、协作，及它们之间的静态结构和关系</strong>的一种<strong>静态结构</strong>。<br>主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。</p>
<p>类图在<strong>软件系统开发的整个生命周期</strong>都有效，是OOP建模中最常见的图。</p>
<h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><p>根据类与类之间的耦合度从弱到强排列： 依赖关系、关联关系、聚合关系、组合关系、泛化关系==实现关系。</p>
<ol>
<li><p>依赖关系Dependency：<strong>带箭头的虚线</strong>，箭头指向被依赖的类。<br>一种使用关系，<strong>临时性关联</strong>，某个类的方法通过局部变量、方法的参数、对静态方法的调用，来访问另一个类(被依赖类)中的某些方法来完成一些职责。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="依赖关系"></p>
</li>
<li><p>关联关系Association：</p>
<ol>
<li>双向关联：用<strong>带两个箭头或没有箭头的实线</strong>表示；</li>
<li>单向关联：用<strong>带一个箭头的实线</strong>来表示；<br>对象间的一种<strong>引用关系</strong>，用于表示一类对象对另一类对象间的联系，通常将一个类的对象作为另一个类的成员变量来实现。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.png" alt="关联关系"></li>
</ol>
</li>
<li><p>聚合关系Aggregation：用<strong>带空心菱形的实线</strong>表示，菱形指向整体。<br>关联关系的一种，是<strong>强关联关系</strong>，是<strong>整体和部分</strong>间的关系。<br>聚合关系<strong>通过成员对象实现</strong>，其中，成员对象是整体对象的一部分，但<strong>成员对象可以脱离整体对象独立存在</strong>。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="聚合关系"></p>
</li>
<li><p>组合关系Composition：用<strong>带实心菱形的实线</strong>表示，菱形指向整体。<br>关联关系的一种，表示<strong>类间整体与部分</strong>的关系，是一种<strong>更强烈的聚合关系</strong>。<br>组合关系中，<strong>整体对象可以控制部分对象的生命周期</strong>，一旦整体对象不存在，部分对象也不存在了，<strong>部分对象不能脱离整体对象存在</strong>。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="组合关系"></p>
</li>
<li><p>泛化关系Generalization：用<strong>带空心三角箭头的实线</strong>表示，箭头从子类指向父类。<br><strong>对象间耦合度最大</strong>的一种关系，表示<strong>一般与特殊的关系</strong>，是<strong>父类与子类</strong>的关系，是一种<strong>继承</strong>关系。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB.png" alt="泛化关系"></p>
</li>
<li><p>实现关系Realization：用<strong>带空心三角箭头的虚线</strong>表示，箭头从实现类指向接口。<br>实线关系是<strong>接口与实现类</strong>间的关系，类实现了接口，类中的操作<strong>实现了接口中声明的所有的抽象操作</strong>。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.png" alt="实现关系"></p>
</li>
</ol>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="http://c.biancheng.net/view/1319.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1319.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Swift设计模式框架集</title>
    <url>/2020/06/23/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/mvc.png" alt="mvc"></p>
<p>所有的对象都可以被归类为一个model，一个view，或一个controller。–Apple</p>
<ul>
<li>M：模型model的对象通常比较简单。<ul>
<li>根据Apple的文档，model应包括数据和操作数据的业务逻辑；</li>
<li>在实际中，model层往往非常薄；</li>
<li>model层的业务逻辑不应被拖入到controller；</li>
</ul>
</li>
<li>V：视图view通常是UIKit控件或编码定义的UIKit控件的集合。<ul>
<li>View的构建可不告诉controller，也不应该直接引用model；</li>
<li>View仅仅通过IBAction事件引用controller；</li>
<li>视图本身不包含任何业务；</li>
</ul>
</li>
<li>C：控制器controller用于协调model和view间的所有交互，是app的“胶水代码”。<ul>
<li>controller负责管理所拥有的view的视图层次结构，并且响应view的loading、appearing、disappearing等；</li>
<li>包括不愿暴露给view的业务逻辑；</li>
<li>网络数据的请求及后续操作，本地数据库操作，及一些带有工具性质辅助方法等都加大了<code>Massive View Controller</code>的产生。</li>
</ul>
</li>
</ul>
<p><em>部分代码没有合适的存放位置，如网络逻辑。</em></p>
<p>弊端：</p>
<ul>
<li>大量的代码被放到controller，臃肿；</li>
<li>controller规模庞大，难以维护；</li>
<li>属性较多，难以管理；</li>
<li>遵循较多协议，protocol的响应代码和controller的逻辑代码混杂；</li>
<li>View Controller混合类视图处理逻辑和业务逻辑，分离这些成分的单元测试成为艰巨的任务。</li>
</ul>
<h1 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/MVVM.png" alt="MVVM"></p>
<p>MVVM是对MVC的一种演进，促进了UI代码和业务逻辑的分离。<br>MVVM正式规范了视图和控制器紧耦合的性质，并引入新的组件ViewModel。<br>项目中的请求数据，统一交给ViewModel管理，每个控制器对应一个专属ViewModel。</p>
<ul>
<li><p>特点：</p>
<ul>
<li>view和<code>view controller</code>正式联系在一起，将其视为一个组件；</li>
<li>view和<code>view controller</code>不能直接引用model，而是引用viewModel；</li>
<li>viewModel放置用户输入验证逻辑、视图显示逻辑、发起网络请求、数据解析等；</li>
<li>使用MVVM会增加少量代码量，但总体上减少了代码的复杂性。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>view引用viewModel，但viewModel不能引用view；</li>
<li>viewModel引用model，但model不能引用ViewModel；</li>
<li>MVVM可兼容MVC架构；</li>
<li>MVVM配合一个绑定机制(如ReactiveCocoa)效果最好；</li>
<li>尽量使用viewModel处理业务逻辑；</li>
<li>viewController尽量不涉及业务逻辑，只接收view的事件、调用viewModel的方法、响应viewModel的变化；</li>
<li>viewModel间可以有依赖，但要避免过于臃肿。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>低耦合：View可以独立于Model变化和修改，一个viewModel可以绑定到不同的View上；</li>
<li>可重用性：可将一些视图逻辑放到一个viewModel中，让view重用该视图逻辑；</li>
<li>独立开发：开发人员可专注于业务逻辑和数据的开发viewModel，设计人员可专注于页面设计View；</li>
<li>可测试：通常界面是比较难测试，MVVM模式可针对viewModel进行测试。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>数据绑定使得一个位置的Bug被快速传递到别的位置，难定位到原始位置；</li>
<li>对于过大的项目，数据绑定和数据转化需要花费更多的内存：<ul>
<li>数组内容的转化成本较高，数组中每项都要转化成Item对象，Item对象中可能还有类似数组；</li>
<li>转化后的数据大部分情况下不能直接被展示，还需二次转化；</li>
<li>只有在API返回的数据高度标准化时，Item的可复用程度才高，否则容易出现类型爆炸，提高维护成本；</li>
</ul>
</li>
<li>调试时通过Item查看数据内容，不如直接通过NSDictionary/NSArray直观；</li>
<li>同一API的数据被不同View展示时，难以控制数据转化的代码，可能散落在任何需要的地方。</li>
</ul>
</li>
</ul>
<hr>
<p>个人实战使用总结：</p>
<ul>
<li>Model：存放所需要用到的变量、定义字典等，用于转换数据；</li>
<li>View：控件相关，用于定义控件属性Cell、UI界面的设置等；</li>
<li>Controller：用于传递数据信息等，如给UIView内容赋值；</li>
<li>ViewModel：用于解析数据等。</li>
</ul>
<h1 id="MVP模式"><a href="#MVP模式" class="headerlink" title="MVP模式"></a>MVP模式</h1><p>MVP由MVC演变，与MVC思想类似，由Presenter/Controller负责业务逻辑。</p>
<ul>
<li>M：数据层，数据库、网络、文件；</li>
<li>V：UI层，UIView、UIViewController；</li>
<li>P：中介Presenter，将M和V进行关联。</li>
</ul>
<p>根据<code></code>可将其划分为四种角色：</p>
<ul>
<li>抽象中介者：P层，定义需要遵守的协议MVPPresenterProtocol；</li>
<li>具体中介者：P层，具体实现抽象中介者中定义的抽象类LoginPresenter；</li>
<li>抽象同事：M+V层，ModelProtocol、MVPViewProtocol；</li>
<li>具体同事：LoginModel、LoginView。</li>
</ul>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://www.jianshu.com/p/d0bc12a63ccf" target="_blank" rel="noopener">https://www.jianshu.com/p/d0bc12a63ccf</a></li>
<li><a href="https://www.jianshu.com/p/5196b9bf277d" target="_blank" rel="noopener">https://www.jianshu.com/p/5196b9bf277d</a></li>
</ul>
]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu安装Matlab</title>
    <url>/2020/06/03/Ubuntu%E5%AE%89%E8%A3%85Matlab/</url>
    <content><![CDATA[<h1 id="Ubuntu-18-04安装Matlab2018b"><a href="#Ubuntu-18-04安装Matlab2018b" class="headerlink" title="Ubuntu 18.04安装Matlab2018b"></a>Ubuntu 18.04安装Matlab2018b</h1><h2 id="Matlab安装"><a href="#Matlab安装" class="headerlink" title="Matlab安装"></a>Matlab安装</h2><ol>
<li>进入下载文件存储路径，装载光盘1 <code>sudo mount -o loop R2018b_glnxa64_dvd1.iso matlab</code>；</li>
<li>启动程序 <code>sudo matlab/install</code>；</li>
<li>选择不联网激活，然后输入license<br>在”Use a File Installation Key”输入license <code>09806-07443-53955-64350-21751-41297</code>。</li>
<li>当弹出弹框时<code>Eject DVD1 and insert DVD 2 to continue</code>加载第2个光盘<br><code>ctrl+alt+t</code> 打开一个新的terminal:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mount -o loop R2018b_glnxa64_dvd2.iso matlab</span><br></pre></td></tr></table></figure>
在弹框点击ok继续安装，待加载完成unmount文件即可。</li>
</ol>
<h2 id="破解Matlab"><a href="#破解Matlab" class="headerlink" title="破解Matlab"></a>破解Matlab</h2><ol>
<li>替换 <code>libmwlmgrimpl.so</code> 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp -f &#x2F;home&#x2F;***&#x2F;Downloads&#x2F;Matlab&#x2F;MATLAB_R2018b_Linux64_Crack&#x2F;MATLAB\ R2018b\ Linux64\ Crack&#x2F;R2018b&#x2F;bin&#x2F;glnxa64&#x2F;matlab_startup_plugins&#x2F;lmgrimpl&#x2F;libmwlmgrimpl.so &#x2F;usr&#x2F;local&#x2F;MATLAB&#x2F;R2018b&#x2F;bin&#x2F;glnxa64&#x2F;matlab_startup_plugins&#x2F;lmgrimpl&#x2F;</span><br><span class="line">sudo &#x2F;usr&#x2F;local&#x2F;MATLAB&#x2F;R2018b&#x2F;bin&#x2F;matlab</span><br></pre></td></tr></table></figure></li>
<li>选择离线激活，选择破解文件license_standalone.lic，<br><code>/home/***/Downloads/Matlab/MATLAB_R2018b_Linux64_Crack/MATLAB R2018b Linux64 Crack/license_standalone.lic</code></li>
</ol>
<ul>
<li>如果不喜欢在terminal中看到 <code>Failed to load module &#39;canberra-gtk-module&#39;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libcanberra-gtk-module</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="创建Matlab快捷方式"><a href="#创建Matlab快捷方式" class="headerlink" title="创建Matlab快捷方式"></a>创建Matlab快捷方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;usr&#x2F;share&#x2F;applications&#x2F;Matlab2018b.desktop</span><br></pre></td></tr></table></figure>
<p>在文件中拷贝如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Categories&#x3D;Application;Development;</span><br><span class="line">Comment&#x3D;Matlab</span><br><span class="line">Encoding&#x3D;UTF-8</span><br><span class="line">Exec&#x3D;&#x2F;usr&#x2F;local&#x2F;MATLAB&#x2F;R2018b&#x2F;bin&#x2F;matlab -desktop -prefersoftwareopengl</span><br><span class="line">Icon&#x3D;&#x2F;usr&#x2F;local&#x2F;MATLAB&#x2F;R2018b&#x2F;toolbox&#x2F;shared&#x2F;dastudio&#x2F;resources&#x2F;MatlabIcon.png</span><br><span class="line">Name&#x3D;MATLAB R2018b</span><br><span class="line">StartupNotify&#x3D;true</span><br><span class="line">Terminal&#x3D;false</span><br><span class="line">Type&#x3D;Application</span><br></pre></td></tr></table></figure>
<p>如果打开Matlab提示”The desktop configuration was not saved successfully”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod a+w -R ~&#x2F;.matlab</span><br><span class="line">sudo chmod 777 &#x2F;home&#x2F;***&#x2F;.matlab</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置CUDA</title>
    <url>/2020/06/03/Ubuntu%E9%85%8D%E7%BD%AECUDA/</url>
    <content><![CDATA[<h1 id="Ubuntu-18-04安装cuda-10-1版本deb"><a href="#Ubuntu-18-04安装cuda-10-1版本deb" class="headerlink" title="Ubuntu 18.04安装cuda 10.1版本deb"></a>Ubuntu 18.04安装cuda 10.1版本deb</h1><ol>
<li>进入存储路径 <code>cd Downloads/cuda</code>；</li>
<li>安装库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg --install cuda-repo-ubuntu1804-10-1-local-10.1.168-418.67_1.0-1_amd64.deb</span><br><span class="line">sudo apt-key add &#x2F;var&#x2F;cuda-repo-10-1-local-10.1.168-418.67</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cuda</span><br></pre></td></tr></table></figure></li>
<li>重启Reboot；</li>
<li>配置环境变量 <code>sudo gedit ~/.bashrc</code><br>在bashrc末尾添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启环境变量 <code>source ~/.bashrc</code>；</li>
<li>验证。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cuda-install-samples-10.1.sh ~</span><br><span class="line">cd ~&#x2F;NVIDIA_CUDA-10.1_Samples&#x2F;5_Simulations&#x2F;nbody</span><br><span class="line">make</span><br><span class="line">.&#x2F;nbody</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="Ubuntu-18-04安装cudnn7-6-2版本deb"><a href="#Ubuntu-18-04安装cudnn7-6-2版本deb" class="headerlink" title="Ubuntu 18.04安装cudnn7.6.2版本deb"></a>Ubuntu 18.04安装cudnn7.6.2版本deb</h1><ol>
<li>安装库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i libcudnn7_7.6.2.24-1+cuda10.1_amd64.deb </span><br><span class="line">sudo dpkg -i libcudnn7-dev_7.6.2.24-1+cuda10.1_amd64.deb</span><br><span class="line">sudo dpkg -i libcudnn7-doc_7.6.2.24-1+cuda10.1_amd64.deb</span><br></pre></td></tr></table></figure></li>
<li>验证（”Test passed!”）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r &#x2F;usr&#x2F;src&#x2F;cudnn_samples_v7&#x2F; $HOME</span><br><span class="line">cd  $HOME&#x2F;cudnn_samples_v7&#x2F;mnistCUDNN</span><br><span class="line">make clean &amp;&amp; make</span><br><span class="line">.&#x2F;mnistCUDNN</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>VS-Code配置</title>
    <url>/2020/06/06/VSCode%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>配置C环境<br><a href="https://www.jianshu.com/p/83879b4aa3fe" target="_blank" rel="noopener">https://www.jianshu.com/p/83879b4aa3fe</a></p>
<p>Latex学习<br><a href="https://www.cnblogs.com/zyg123/category/1415008.html" target="_blank" rel="noopener">https://www.cnblogs.com/zyg123/category/1415008.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>brief特征</title>
    <url>/2020/06/04/brief%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="BRIEF"><a href="#BRIEF" class="headerlink" title="BRIEF"></a>BRIEF</h1><ol>
<li>平滑图像；</li>
<li>在特征点周围选择一个Patch，在这个Patch内通过一定方法挑选$n_d$个点对；</li>
<li>比较点对中两个像素的大小，并进行赋值：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/BRIEF%E8%B5%8B%E5%80%BC.png" alt="BRIEF赋值"></li>
<li>对所有$n_d$个点对，进行比较，生成一个长$n_d$的二进制串。</li>
</ol>
<h2 id="点对的生成方式："><a href="#点对的生成方式：" class="headerlink" title="点对的生成方式："></a>点对的生成方式：</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%82%B9%E5%AF%B9%E7%94%9F%E6%88%90.png" alt="点对生成"></p>
<ul>
<li>X和Y都服从在[-S/2,S/2]范围内的均匀分布，且相互独立；</li>
<li>X和Y都服从均值为0，方差为$\frac{S^2}{25}$的高斯分布，且相互独立。</li>
</ul>
<p><strong>点对的位置一旦随机选定，就不再更改。</strong></p>
<hr>
<h1 id="ORB特征描述"><a href="#ORB特征描述" class="headerlink" title="ORB特征描述"></a>ORB特征描述</h1><p>基于Fast角点的特征点检测和BRIEF特征描述技术。</p>
<ul>
<li><p>Fast角点检测缺点：</p>
<ul>
<li>缺乏尺度不变性；</li>
<li>通过构建高斯金字塔，在每一层金字塔图像上检测角点，来实现尺度不变性。</li>
</ul>
</li>
<li><p>BRIEF缺点：</p>
<ul>
<li>缺乏旋转不变性；</li>
<li>给Brief添加旋转不变性。</li>
</ul>
</li>
</ul>
<h2 id="ORB对BRIEF的改进"><a href="#ORB对BRIEF的改进" class="headerlink" title="ORB对BRIEF的改进"></a>ORB对BRIEF的改进</h2><ul>
<li><p>在计算描述子时建立的坐标系，以关键点为圆心，以关键点和取点区域的形心(圆心)的连线为X轴建立坐标系；</p>
</li>
<li><p>计算形心时，圆形区域上每个点的质量是其对应的像素值。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>conda</title>
    <url>/2020/03/09/conda/</url>
    <content><![CDATA[<h1 id="Anaconda-miniconda-个性化设置"><a href="#Anaconda-miniconda-个性化设置" class="headerlink" title="Anaconda/miniconda 个性化设置"></a>Anaconda/miniconda 个性化设置</h1><h2 id="更换国内镜像源"><a href="#更换国内镜像源" class="headerlink" title="更换国内镜像源"></a>更换国内镜像源</h2><p>具体替换方式在官方网站中均有提示，<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华镜像源网站</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阿里云 https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line">中国科技大学 https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;</span><br><span class="line">豆瓣(douban) http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br><span class="line">清华大学 https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;</span><br><span class="line">中国科学技术大学 http:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="jupyter个性化设置"><a href="#jupyter个性化设置" class="headerlink" title="jupyter个性化设置"></a>jupyter个性化设置</h2><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><ul>
<li>下载主题文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure></li>
<li>查看主题列表 <code>jt -l</code></li>
<li>设置主题 <code>jt -t * -f * -fs 14 -cellw 90% -ofs 12 -T -N</code></li>
<li>t：字体；-fs：字体大小；-cellw：屏占比；-ofs：输出段字号；-T：显示工具栏；-N：显示主机名</li>
<li>查看帮助 <code>jt -h</code></li>
<li>还原默认主题 <code>jt -r</code></li>
</ul>
<h3 id="快速切换环境"><a href="#快速切换环境" class="headerlink" title="快速切换环境"></a>快速切换环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --name ***</span><br></pre></td></tr></table></figure>

<p>当出现 <code>kernel error</code> 时：</p>
<ol>
<li>使用<code>jupyter kernelspec list</code>查看内核是否正确；</li>
<li>删除掉不正确的内核<code>jupyter kernelspec remove 内核名</code>，重新安装内核即可。</li>
</ol>
<h2 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h2><p>在安装anaconda/miniconda后，终端默认会显示当前环境名称，<br>若感觉影响美观，可设置忽略(base)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.condarc</span><br></pre></td></tr></table></figure>
<p>在文末添加 <code>changeps1: False</code> 即可。</p>
<hr>
<h1 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h1><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><ol>
<li>创建虚拟环境<br><code>conda create -n xxxx python=版本号</code></li>
<li>移除该虚拟环境<br><code>conda remove -n xxxx --all</code></li>
<li>开启xxxx环境/激活虚拟环境<br><code>conda activate xxxx</code> 或 <code>source activate xxxx</code></li>
<li>关闭虚拟环境<br><code>conda deactivate</code></li>
<li>查看所创建的虚拟环境列表<br><code>conda env list</code></li>
<li>克隆环境<br><code>conda create -n *** --clone ***</code></li>
<li>导出环境，进入到要导出的环境（激活）<br><code>conda env export --file ***.yml</code></li>
<li>导入环境<br><code>conda env create -f ***.yml</code></li>
</ol>
<h2 id="更新conda"><a href="#更新conda" class="headerlink" title="更新conda"></a>更新conda</h2><p><code>conda update conda</code><br><code>conda update anaconda</code><br><code>conda update anaconda-navigator</code></p>
<h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><ol>
<li>查看安装的包<br><code>conda list</code></li>
<li>卸载安装的包<br><code>conda uninstall xxx</code></li>
<li>删除无用的包（自动清理）<br><code>conda clean -p</code></li>
<li>tar打包<br><code>conda clean -t</code></li>
</ol>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/03/09/git/</url>
    <content><![CDATA[<h1 id="基本配置："><a href="#基本配置：" class="headerlink" title="基本配置："></a>基本配置：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;***@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<p>确保已经有生成有SSH公钥：<br>进入 <code>~/.ssh</code> 可看到有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> ，其中 <code>id_rsa.pub</code> 为公钥。<br>若没有，运行：<code>ssh-keygen -t rsa -C “***@gmail.com&quot;</code> 或 <code>ssh-keygen</code>。<br>将公钥添加到GitHub等远程仓库设置中。</p>
<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><ul>
<li>初始化仓库 <code>git init</code></li>
<li>添加文件到仓库 <code>git add ***</code></li>
<li>提交文件到仓库 <code>git commit -m &quot;comments&quot;</code><br>若不想添加备注信息，可直接<code>git commit</code></li>
<li>将本地仓库与远程仓库进行关联 <code>git remote add origin *URL*</code></li>
<li>提交更改到远程仓库 <code>git push -u origin master</code></li>
<li>克隆远程仓库 <code>git clone *URL*</code></li>
<li>查看提交日志 <code>git log</code><br>简洁版本：<code>git log --pretty=oneline</code></li>
<li>查看当前文件状态 <code>git status</code></li>
<li>回退至上一版本 <code>git reset --hard HEAD^</code></li>
<li>放弃对工作区的修改 <code>git checkout -- ***</code><br>回退至版本库文件替换工作区文件（就是 <code>git add</code>）之前</li>
<li>查看记录版本号 <code>git reflog</code></li>
<li>回退至具体某一版本 <code>git reset --hard *版本号*</code></li>
<li>从版本库删除文件 <code>git rm ***</code></li>
</ul>
<p><em>对于git相关内容，以上对于个人自用足够了，若要团队使用，需要对分支进行设置管理，暂不概述。</em></p>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>haar特征</title>
    <url>/2020/06/04/haar%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="Haar-like特征"><a href="#Haar-like特征" class="headerlink" title="Haar-like特征"></a>Haar-like特征</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Haar%E7%89%B9%E5%BE%81.png" alt="Haar特征"></p>
<p>Haar-like模版可以表示出人脸的某些特征，如中间图表示眼睛区域的颜色比脸颊区域的颜色要深；<br>右图表示鼻梁两侧比鼻梁的颜色要深。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/haar-like%E4%BA%BA%E8%84%B8.png" alt="haar-like人脸"></p>
<h1 id="特征模版"><a href="#特征模版" class="headerlink" title="特征模版"></a>特征模版</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/haar-like.png" alt="haar-like"></p>
<p>Haar-like特征模版：</p>
<ul>
<li>边缘特征；</li>
<li>线性特征；</li>
<li>中心特征；</li>
<li>对角线特征。</li>
</ul>
<p>该模版的特征值为：白色矩形像素和 - 黑色矩形像素和。</p>
<p>特征数量：要考虑模版、位置、缩放 etc.</p>
<h2 id="快速计算-积分图"><a href="#快速计算-积分图" class="headerlink" title="快速计算-积分图"></a>快速计算-积分图</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%A7%AF%E5%88%86%E5%9B%BE.png" alt="积分图"></p>
<p>根据四个角点计算区域内像素和：$A_{ABCD} = A_C - (A_B + A_D - A_A)$。</p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>hog特征</title>
    <url>/2020/06/04/hog%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h1><ul>
<li><p>梯度计算</p>
<ul>
<li>分别计算水平、垂直梯度（将二维卷积转换为两个一维卷积）的幅值、方向；</li>
<li>对于彩色图，选取梯度幅值最大的通道。</li>
</ul>
</li>
<li><p>Block拆分</p>
<ul>
<li><p>16*16的Block，步长为8，50%的重合；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/block.png" alt="block"></p>
</li>
<li><p>包含2*2个Cell；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/cell.png" alt="cell"></p>
</li>
<li><p>每个Cell为8*8大小。</p>
</li>
</ul>
</li>
<li><p>计算每个Cell的梯度方向直方图</p>
<ul>
<li><p>9个方向bin(0-180)；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/bin.png" alt="bin"></p>
</li>
<li><p>积累梯度幅值；<br>  <em>易受前景/背景对比度及局部光照影响</em>，需对局部细胞单元进行对比度归一化处理：将各Cell组合成大的、空间上连通的区间block，再进行归一化。</p>
<p>  <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/hog%E5%BD%92%E4%B8%80%E5%8C%96%E5%A4%84%E7%90%86.png" alt="hog归一化处理"></p>
</li>
<li><p>使用位置高斯加权；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BD%8D%E7%BD%AE%E9%AB%98%E6%96%AF%E5%8A%A0%E6%9D%83.png" alt="位置高斯加权"></p>
</li>
<li><p>相邻bin使用线性插值。</p>
</li>
</ul>
</li>
<li><p>串联所有Block直方图</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%B8%B2%E8%81%94Block.png" alt="串联Block"></p>
<ul>
<li>64*128大小图片；</li>
<li>7*15=105个Block；</li>
<li>105<em>(2</em>2)*9=3780维。</li>
</ul>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/HOG%E6%AD%A5%E9%AA%A4.png" alt="HOG步骤"></p>
<ol>
<li>将整个图像进行Gamma空间、颜色归一化；</li>
<li>计算图像梯度；</li>
<li>构建方向的直方图；</li>
<li>将细胞单元组成大的区间；</li>
<li>收集HOG特征。</li>
</ol>
<p><em>行人HOG特征：</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%A1%8C%E4%BA%BAHOG%E7%89%B9%E5%BE%81.png" alt="行人HOG特征"></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>kmeans聚类</title>
    <url>/2020/06/06/kmeans%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/K-means.png" alt="K-means"></p>
<p>算法流程：</p>
<ol>
<li>选取k个类中心（首次随机选取）；</li>
<li>计算每个点到k个类中心的距离；</li>
<li>将数据点分配给距离最近的一个类中心；</li>
<li>计算新的类中心（对该类中所有点取均值）；</li>
<li>重复2-4，直到满足终止条件：<ul>
<li>不再有重新分配；</li>
<li>最大迭代数；</li>
<li>所有类中心移动小于某一个值。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>image</category>
      </categories>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/03/09/mysql/</url>
    <content><![CDATA[<h1 id="mysql常用命令"><a href="#mysql常用命令" class="headerlink" title="mysql常用命令"></a>mysql常用命令</h1><h2 id="进入mysql："><a href="#进入mysql：" class="headerlink" title="进入mysql："></a>进入mysql：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>输入密码登录。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>显示已存在数据库：<br><code>show databases;</code></li>
<li>创建新数据库：<br><code>create database 数据库名称;</code></li>
<li>切换到某数据库：<br><code>use 数据库名称;</code></li>
<li>删除数据库：<br><code>drop database 数据库名称;</code></li>
<li>退出数据库：<br><code>use mysql;</code></li>
</ol>
<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><ol>
<li>显示数据库中所有表：<br><code>show tables;</code></li>
<li>创建新数据库表：<br><code>create table</code>数据库名称<code>(</code>列名<code>类型 ... , ...);</code></li>
<li>查看某表结构：<br><code>show columns from 表名;</code> 或 <code>DESCRIBE 表名;</code></li>
<li>删除数据库表：<br><code>drop tables 表名;</code></li>
</ol>
<hr>
<h1 id="导入txt格式文件到MySQL8-0"><a href="#导入txt格式文件到MySQL8-0" class="headerlink" title="导入txt格式文件到MySQL8.0"></a>导入txt格式文件到MySQL8.0</h1><h2 id="命令行方式导入："><a href="#命令行方式导入：" class="headerlink" title="命令行方式导入："></a>命令行方式导入：</h2><p><strong>利用navicat中的查询语句进行命令操作</strong></p>
<ol>
<li>新建一个car_operation数据库：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;car_operation&#96; (</span><br><span class="line">  &#96;car_id&#96; varchar(6) NOT NULL COMMENT &#39;车辆标识&#39;,</span><br><span class="line">  &#96;clicking&#96; int(2) NOT NULL COMMENT &#39;触发事件：0&#x3D;变空车，1&#x3D;变载客，2&#x3D;设防，3&#x3D;撤防，4&#x3D;其它&#39;,</span><br><span class="line">  &#96;operation_status&#96; int(2) NOT NULL COMMENT &#39;运营状态：0&#x3D;空车，1&#x3D;载客，2&#x3D;驻车，3&#x3D;停运，4&#x3D;其它&#39;,</span><br><span class="line">  &#96;gps_time&#96; date NOT NULL COMMENT &#39;GPS时间：格式yyyymmddhhnnss，北京时间&#39;,</span><br><span class="line">  &#96;gps_longitude&#96; float(12, 8) NOT NULL COMMENT &#39;GPS经度：格式ddd.ddddddd，以度为单位&#39;,</span><br><span class="line">  &#96;gps_latitude&#96; float(12, 8) NOT NULL COMMENT &#39;GPS纬度：格式dd.ddddddd，以度为单位&#39;,</span><br><span class="line">  &#96;gps_speed&#96; int(4) NOT NULL COMMENT &#39;GPS速度：格式ddd，取值000-255内整数，以公里&#x2F;小时为单位&#39;,</span><br><span class="line">  &#96;gps_direction&#96; int(4) NOT NULL COMMENT &#39;GPS方位：格式ddd，取值000-360内整数，以度为单位&#39;,</span><br><span class="line">  &#96;gps_status&#96; int(2) NOT NULL COMMENT &#39;GPS状态：0&#x3D;无效，1&#x3D;有效&#39;</span><br><span class="line">) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>因使用MySQL8.0，需要修改my.ini配置文件:</strong><br>在[mysqld]下添加一行 <code>secure_file_priv=&#39;&#39;</code>，重启MySQL服务器。</p>
<ol start="2">
<li><p>使用样例数据导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA INFILE &#39;F:&#x2F;CQUPT&#x2F;Y81201&#x2F;SuperDatabase&#x2F;ADB&#x2F;20121130000001.txt&#39; REPLACE </span><br><span class="line">INTO TABLE car_operation </span><br><span class="line">FIELDS TERMINATED by&#39;,&#39; </span><br><span class="line">ENCLOSED by&#39;&quot;&#39;</span><br><span class="line">LINES TERMINATED by &#39;\r\n&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用全部数据导入：（因数据有重复，删除car_id主键中的主键设置）</p>
</li>
</ol>
<h2 id="通过GUI方式导入（速度超级慢）"><a href="#通过GUI方式导入（速度超级慢）" class="headerlink" title="通过GUI方式导入（速度超级慢）"></a>通过GUI方式导入（速度超级慢）</h2><ol>
<li><p>创建<code>car_op_gui</code>数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;car_op_gui&#96;(</span><br><span class="line">	&#96;car_id&#96; varchar(6) NOT NULL COMMENT &#39;车辆标识&#39;,</span><br><span class="line">  &#96;clicking&#96; int(2) NOT NULL COMMENT &#39;触发事件：0&#x3D;变空车，1&#x3D;变载客，2&#x3D;设防，3&#x3D;撤防，4&#x3D;其它&#39;,</span><br><span class="line">  &#96;operation_status&#96; int(2) NOT NULL COMMENT &#39;运营状态：0&#x3D;空车，1&#x3D;载客，2&#x3D;驻车，3&#x3D;停运，4&#x3D;其它&#39;,</span><br><span class="line">  &#96;gps_time&#96; date NOT NULL COMMENT &#39;GPS时间：格式yyyymmddhhnnss，北京时间&#39;,</span><br><span class="line">  &#96;gps_longitude&#96; float(12, 8) NOT NULL COMMENT &#39;GPS经度：格式ddd.ddddddd，以度为单位&#39;,</span><br><span class="line">  &#96;gps_latitude&#96; float(12, 8) NOT NULL COMMENT &#39;GPS纬度：格式dd.ddddddd，以度为单位&#39;,</span><br><span class="line">  &#96;gps_speed&#96; int(4) NOT NULL COMMENT &#39;GPS速度：格式ddd，取值000-255内整数，以公里&#x2F;小时为单位&#39;,</span><br><span class="line">  &#96;gps_direction&#96; int(4) NOT NULL COMMENT &#39;GPS方位：格式ddd，取值000-360内整数，以度为单位&#39;,</span><br><span class="line">  &#96;gps_status&#96; int(2) NOT NULL COMMENT &#39;GPS状态：0&#x3D;无效，1&#x3D;有效&#39;</span><br><span class="line">)ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该数据库右键选择导入向导<br> -&gt;选择txt格式<br> -&gt;选择数据源<br> -&gt;更改字段分隔符为“逗号，”<br> -&gt;下一步<br> -&gt;下一步<br> -&gt;更改目标字段<br> -&gt;追加，下一步<br> -&gt;开始</p>
</li>
<li><p>导入全部数据：（采用追加方式，目的删除之前样例数据）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化机制</title>
    <url>/2020/07/28/redis/</url>
    <content><![CDATA[<h1 id="Remote-Dictionary-Server-远程字典服务"><a href="#Remote-Dictionary-Server-远程字典服务" class="headerlink" title="Remote Dictionary Server 远程字典服务"></a>Remote Dictionary Server 远程字典服务</h1><p>由意大利人<code>Salvatore Sanfilippo</code>开发的一款<strong>内存高速缓冲数据库</strong>，基于内存运行并支持持久化的NoSQL数据库，遵守BSD协议。</p>
<p>优点：</p>
<ul>
<li>速度快，因为数据存在内存中，类似于HashMap；</li>
<li>支持丰富数据类型，支持String，List，Set，Sorted Set，Hash；</li>
<li>支持事务，操作都是<strong>原子性</strong>(对数据的更改要么全部执行，要么全部不执行)；</li>
<li>丰富的特性，可用于缓存，消息，按key设置过期时间，过期后将会自动删除。</li>
</ul>
<p>Redis单点吞吐量：</p>
<ul>
<li>单点TPS(每秒钟最大能处理的请求数)达到8万/秒；</li>
<li>QPS(应用系统每秒钟最大能接受的用户访问量)达到10万/秒。</li>
</ul>
<h1 id="持久化的流程"><a href="#持久化的流程" class="headerlink" title="持久化的流程"></a>持久化的流程</h1><ol>
<li>客户端向服务端发送写操作，数据在客户端的内存中；</li>
<li>数据库服务端接收到写请求的数据，数据在服务端的内存中；</li>
<li>服务端调用write系统调用，将数据往磁盘上写，数据在系统内存的缓冲区中；</li>
<li>操作系统将缓冲区中的数据转移到磁盘控制器上，数据在磁盘缓存中；</li>
<li>磁盘控制器将数据写到磁盘的物理介质中，数据保存到磁盘上。</li>
</ol>
<h2 id="RDB机制"><a href="#RDB机制" class="headerlink" title="RDB机制"></a>RDB机制</h2><p><code>Redis DataBase</code>，主要是将数据以<strong>快照</strong>的形式保存到磁盘上。</p>
<p>RDB持久化，指在指定的时间间隔内将内存中的数据集快照写入磁盘，<strong>默认的持久化方式</strong>。即将内存中的数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。</p>
<p>RDB提供了三种触发机制来实现快照过程：</p>
<ol>
<li>save触发方式：<ol>
<li>该命令会阻塞当前Redis服务器；</li>
<li>执行save命令期间，Redis不能处理其它命令，直到RDB过程完成为止。</li>
<li>执行完成时，新的RDB文件会将old覆盖掉。</li>
</ol>
</li>
<li>bgsave触发方式：执行该命令时，Redis会在<strong>后台异步</strong>进行快照操作，快照同时仍可响应客户端请求；<ol>
<li>Redis进程执行fork操作创建子进程，RDB持久化操作由子进程负责，完成后自动结束；</li>
<li>阻塞只发生在fork阶段，一般时间很短；</li>
<li>基本上Redis内部所有的RDB操作都是采用bgsave命令。</li>
</ol>
</li>
<li>自动触发：在<code>redis.conf</code>配置文件中设置；<ol>
<li>save：配置触发Redis的RDB持久化条件，即何时将内存中的数据保存到硬盘，如<code>save m n</code>表示m秒内数据集存在n次修改时自动触发bgsave；</li>
<li>stop-writes-on-bgsave-error：默认yes，当启用RDB且最后一次后台保存数据失败，Redis是否停止接收数据；</li>
<li>rdbcompression：默认yes，对存储到磁盘中的快照，设置是否进行压缩存储；</li>
<li>rdbchecksum：默认yes，在存储快照后，让redis使用CRC64算法来进行数据校验，会增加约10%的性能消耗；</li>
<li>dbfilename：设置快照的文件名，默认dump.rdb</li>
<li>dir：设置快照文件的存放路径，该配置项一定是个目录。</li>
</ol>
</li>
</ol>
<ul>
<li>优点：<ul>
<li>RDB文件紧凑，全量备份，适合用于进行备份和灾难恢复；</li>
<li>生成RDB文件时，redis祝进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作；</li>
<li>RDB在恢复大数据集时的速度比AOF的恢复速度快；</li>
</ul>
</li>
<li>缺点：<ul>
<li>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑；</li>
<li>当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</li>
</ul>
</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><code>Append Only File</code>，redis会将每一个收到的写命令通过write函数追加到文件中，即<code>日志记录</code>，更加高效且工作机制简单。</p>
<ul>
<li>持久化的原理：每当有一个写命令传递过来，就直接保存到AOF文件中。</li>
<li>文件重写原理：redis提供了bgrewriteaof命令，将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来重写文件。<ul>
<li>重写aof文件时，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件。</li>
</ul>
</li>
</ul>
<p>AOF的三种触发机制：</p>
<ol>
<li>每修改同步always：同步持久化；<ol>
<li>每次发生数据变更会被立即记录到磁盘；</li>
<li>性能较差但数据完整性较好；</li>
</ol>
</li>
<li>每秒同步everysec：异步操作；<ol>
<li>每秒进行记录；</li>
<li>如果一秒内宕机，会丢失数据；</li>
</ol>
</li>
<li>不同步no：从不同步。</li>
</ol>
<ul>
<li>优点：<ul>
<li>aof可以更好的保护数据不丢失，一般aof会每隔1s，通过一个后台线程执行一次fsync操作，最多丢失1s的数据；</li>
<li>aof日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损；</li>
<li>aof日志文件即使过大时，出现后台重写操作，也不会影响客户端的读写；</li>
<li>aof日志文件的命令通过非常可读的方式进行记录，该特性非常适合做灾难性的误删除的紧急恢复。</li>
</ul>
</li>
<li>缺点：<ul>
<li>对同一份数据，AOF日志文件通常比RDB睡觉快照文件更大；</li>
<li>AOF开启时，支持的写QPS会比RDB低，因为AOF一般会配置成每秒fsync一次日志文件；</li>
<li>之前AOF发生过bug，当通过AOF记录的日志进行数据恢复时，不能恢复出一模一样的数据。</li>
</ul>
</li>
</ul>
<h1 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="redis线程模型"></p>
<p>Redis基于Reactor模式开发了网络事件处理器，被称为文件事件处理器，包括<code>多个套接字socket、IO多路复用程序、文件事件分派器、事件处理器</code>。<br>因为文件事件分派器队列的消费是单线程的，所以Redis被称为<strong>单线程模型</strong>。</p>
<h2 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h2><ul>
<li>文件事件处理器使<strong>用I/O多路复用程序</strong>来<strong>同时监听多个套接字</strong>，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答accept、读取read、写入write、关闭close等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理事件。</li>
<li>多个文件事件可能会并发地出现，但I/O多路复用程序总会将所有产生事件的套接字推到一个队列里面，然后通过队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字；</li>
<li>当一个套接字产生的事件被处理完毕后，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。</li>
</ul>
<h3 id="I-O-多路复用程序的实现"><a href="#I-O-多路复用程序的实现" class="headerlink" title="I/O 多路复用程序的实现"></a>I/O 多路复用程序的实现</h3><p>Redis的<code>I/O多路复用程序</code>的所有功能是通过包装<code>select、epoll、evport、kqueue</code>这些<code>**I/O多路复用函数库**</code>来实现的，每个<code>I/O多路复用函数库</code>在Redis源码中都对应一个单独的文件，比如<code>ae_select.c、ae_epoll.c、ae_kqueue.c</code>等。</p>
<p>因为Redis为每个<code>I/O多路复用函数库</code>都实现了相同的<code>API</code>，所以<code>I/O多路复用程序</code>的底层实现是可以互换的。Redis在<code>I/O多路复用程序</code>的实现源码中用<code>#include</code>宏定义了相应的规则，程序会在编译时<strong>自动选择系统中性能最好</strong>的<code>I/O多路复用函数库</code>来作为Redis的<code>I/O多路复用程序</code>的<strong>底层实现</strong>。</p>
<h3 id="文件事件的类型"><a href="#文件事件的类型" class="headerlink" title="文件事件的类型"></a>文件事件的类型</h3><p><code>I/O多路复用程序</code>可以监听多个套接字的<code>ae.h/AE_READABLE</code>事件和<code>ae.h/AE_WRITABLE</code>事件：</p>
<ul>
<li>当套接字变得可读时(<em>客户端对套接字执行write操作，或者执行close操作</em>)，或者有新的可应答(acceptable)套接字出现时，客户端对服务器的监听套接字执行connect操作，套接字产生<code>AE_READABLE</code>事件；</li>
<li>当套接字变得可写时(客户端对套接字执行read操作)，套接字产生<code>AE_WRITABLE</code>事件；</li>
<li>I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE 事件。</li>
</ul>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc</a></li>
<li><a href="https://blog.csdn.net/qq_25827845/article/details/90321396" target="_blank" rel="noopener">https://blog.csdn.net/qq_25827845/article/details/90321396</a></li>
<li><a href="https://www.jianshu.com/p/6264fa82ac33" target="_blank" rel="noopener">https://www.jianshu.com/p/6264fa82ac33</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>runloop</title>
    <url>/2020/07/29/runloop/</url>
    <content><![CDATA[<h1 id="运行循环"><a href="#运行循环" class="headerlink" title="运行循环"></a>运行循环</h1><p>Runloop就是运行循环,每个线程内部都有一个运行循环，只有主线程的运行循环默认是开启的。<br>运行循环是一个<strong>死循环</strong>,只有满足一定条件才会结束循环。</p>
<p>运行循环的作用：</p>
<ol>
<li>保证程序不退出，iOS的应用程序启动之后，之所以不会退出，就是因为有Runloop(运行循环)；</li>
<li>负责处理输入事件；</li>
<li>如果没有事件发生，会让程序进入休眠状态。</li>
</ol>
<p>Runloop接收的事件来自两种不同的来源：</p>
<ul>
<li>输入源(Input sources)：输入源传递异步事件，通常消息来自于其他线程或程序；</li>
<li>定时源(Timer sounces)定时源则传递同步事件，发生在特定时间或者重复的时间间隔。</li>
<li>两种源都使用程序的某一特定的处理例程来处理到达的事件。</li>
</ul>
<h2 id="runloop中的模式"><a href="#runloop中的模式" class="headerlink" title="runloop中的模式"></a>runloop中的模式</h2><p>model，是runloop里面的模式，不同的模式下的runloop处理的事件和消息有一定的差别。</p>
<p>系统默认注册了5个Mode:</p>
<ul>
<li>kCFRunLoopDefaultMode: App的默认Mode，通常主线程是在这个Mode下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动App时第进入的第一个Mode，启动完成后就不再使用。</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部Mode，通常用不到。</li>
<li>kCFRunLoopCommonModes: 这是一个占位的Mode，没有实际作用。</li>
</ul>
<p>ios对以上5中model进行了封装：NSDefaultRunLoopMode、NSRunLoopCommonModes。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/damowangseven/p/5273319.html" target="_blank" rel="noopener">https://www.cnblogs.com/damowangseven/p/5273319.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>runtime</title>
    <url>/2020/07/13/runtime/</url>
    <content><![CDATA[<h1 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h1><p>将源代码转换为可执行的程序，通常需要经过三个步骤：<strong>编译、链接、运行</strong>。</p>
<p><em>C语言-静态类语言，在编译阶段就已经确定了所有变量的数据类型，同时确定好了要调用的函数，及函数的实现。</em></p>
<p>Objective-C语言，是一门<strong>动态语言</strong>，在编译阶段并不知道变量的具体数据类型，也不知道真正调用的是哪个函数。<br>只有在运行时才检查变量的数据类型，同时在运行时才会根据函数名查找要调用的具体函数。<br><a href="https://juejin.im/post/5e130ba05188253a5d560155#heading-0" target="_blank" rel="noopener">load &amp; initialize</a></p>
<p>Objective-C语言把一些决定性的工作从编译阶段、链接阶段推迟到运行时阶段的机制，使得Objective-C更加灵活。<br>在程序运行的时候，动态的去修改一个方法的实现，为“热更新”提供了可能性。</p>
<p>Objective-C语言<strong>运行时机制的一切基础</strong>：Runtime。</p>
<p>Runtime，实际是一个库，这个库使我们可以在程序运行时动态的创建对象、检查对象、修改类和对象的方法。</p>
<p>Runtime的作用：<em>不得已才使用</em></p>
<ul>
<li>调用已知私有方法，如调用没有在.h文件中声明，但在.m文件实现了的方法；</li>
<li>用runtime调用私有方法，方法编号后面开始，依次为传入给方法的参数。</li>
</ul>
<p>Runtime的具体应用：</p>
<ul>
<li>利用关联对象AssociatedObject给分类添加属性；</li>
<li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）；</li>
<li>交换方法实现（交换系统的方法）；</li>
<li>利用消息转发机制解决方法找不到的异常。</li>
</ul>
<h1 id="消息机制的基本原理"><a href="#消息机制的基本原理" class="headerlink" title="消息机制的基本原理"></a>消息机制的基本原理</h1><p>Objective-C语言中，对象方法调用都是类似<code>[receiver selector];</code>的形式，其本质就是让<strong>对象在运行时发送消息</strong>的过程。</p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><code>[receiver selector];</code>方法被编译器转换为：</p>
<ol>
<li>不带参数：<code>objc_msgSend(receiver,selector)</code></li>
<li>带参数：<code>objc_msgSend(receiver, selector, org1, org2)</code></li>
</ol>
<h2 id="运行时阶段"><a href="#运行时阶段" class="headerlink" title="运行时阶段"></a>运行时阶段</h2><p><strong>消息接受者receiver寻找对应的selector。</strong></p>
<ol>
<li>通过receiver的isa指针找到receiver的Class；</li>
<li>在Class的方法缓存cache的散列表中寻找对应的实现方法IMP；</li>
<li>若在cache中未找到对应的IMP，就继续在Class的方法列表<code>method list</code>中寻找对应的selector，找到后填充到cache中，并返回selector；</li>
<li>若在Class中没有找到该selector，就继续在其父类superClass中寻找；</li>
<li>一旦找到对应的selector，直接执行receiver对应的selector方法实现的IMP；</li>
<li>若找不到对应的selector，消息被转发或临时向receiver添加这个selector对应的实现方法，否则就会发生崩溃。</li>
</ol>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>所有Objective-C方法调用在编译时都会转化为对C函数objc_msgSend的调用。<br><code>objc_msgSend(receiver,selector)</code>是<code>[receiver selector];</code>对应的C函数。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>在<code>objc/runtime.h</code>中，Class被定义为指向<code>objc_class结构体</code>的指针。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_class结构体</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa;                                          &#x2F;&#x2F; objc_class 结构体的实例指针</span><br><span class="line"></span><br><span class="line">    #if !__OBJC2__</span><br><span class="line">        Class _Nullable super_class;                                 &#x2F;&#x2F; 指向父类的指针</span><br><span class="line">        const char * _Nonnull name;                                  &#x2F;&#x2F; 类的名字</span><br><span class="line">        long version;                                                &#x2F;&#x2F; 类的版本信息，默认为 0</span><br><span class="line">        long info;                                                   &#x2F;&#x2F; 类的信息，供运行期使用的一些位标识</span><br><span class="line">        long instance_size;                                          &#x2F;&#x2F; 该类的实例变量大小;</span><br><span class="line">        struct objc_ivar_list * _Nullable ivars;                     &#x2F;&#x2F; 该类的实例变量列表</span><br><span class="line">        struct objc_method_list * _Nullable * _Nullable methodLists; &#x2F;&#x2F; 方法定义的列表</span><br><span class="line">        struct objc_cache * _Nonnull cache;                          &#x2F;&#x2F; 方法缓存</span><br><span class="line">        struct objc_protocol_list * _Nullable protocols;             &#x2F;&#x2F; 遵守的协议列表</span><br><span class="line">    #endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>objc_class结构体</code>存放的数据称为元数据metadata。<br><code>objc_class结构体</code>的第一个成员变量是isa指针，isa指针保存的是所属类的结构体的实例/对象的指针。<br>Class的本质其实就是一个对象，称为类对象。</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>在<code>objc_objc.h</code>中关于Object的定义：Object被定义为<code>objc_object结构体</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; objc_object结构体</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa;       &#x2F;&#x2F; objc_object结构体的实例指针 或称 Class类型的isa指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 指向&#96;objc_object结构体&#96;的指针</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>

<p>一个对象Object唯一保存的就是所属类Class的地址，当对一个对象Object进行方法调用，如<code>[reveiver selector];</code>，将通过<code>objc_object结构体</code>的<code>isa指针</code>去寻找对应的<code>object_class结构体</code>，然后在<code>object_class结构体</code>的方法列表methodLists中找到要调用的方法，然后执行。</p>
<h3 id="Meta-Class（元类）"><a href="#Meta-Class（元类）" class="headerlink" title="Meta Class（元类）"></a>Meta Class（元类）</h3><p><code>object_class结构体</code>的isa指针指向的是对应的类对象<code>object_class结构体</code>，而<code>object_class结构体</code>的isa指针实际指向的是类对象自身的元类<code>Meta Class</code>。</p>
<p><code>Meta Class</code>就是一个类对象所属的类，一个对象所属的类叫做类对象，一个类对象所属的类称为元类。</p>
<p>Runtime中把类对象所属类型叫做<code>Meta Class</code>，用于描述类对象本身所具有的特征，类对象本身指向的就是元类。<br><strong>每个类对象有且仅有一个与之相关的元类</strong>。在元类的methodLists中，保存了类的方法链表/类方法。</p>
<p><strong>类方法的调用过程</strong>：</p>
<ol>
<li>通过类对象的isa指针找到所属的元类<code>Meta Class</code>;</li>
<li>在<code>Meta Class</code>的方法列表methodLists中找到对应的selector；</li>
<li>执行对应的selector。</li>
</ol>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *testString &#x3D; [NSString stringWithFormat:@&quot;%d,%s&quot;,3, &quot;test&quot;];</span><br></pre></td></tr></table></figure>
<p><code>stringWithFormat</code>被发送给了NSString类，NSString类通过isa指针找到NSString元类，然后在该元类的方法列表中找到对应的<code>stringWithFormat</code>方法，执行。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%AF%B9%E8%B1%A1_%E7%B1%BB_%E5%85%83%E7%B1%BB.png" alt="对象_类_元类"></p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><code>object_class结构体</code>的方法列表methodLists只存放的元素就是方法Method。</p>
<p>在<code>objc/runtime.h</code>中，表示Method的<code>object_class结构体</code>的数据结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 代表类定义中一个方法的不透明类型</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name;                    &#x2F;&#x2F; 方法名，SEL只是一个保存方法名的字符串</span><br><span class="line">    char * _Nullable method_types;               &#x2F;&#x2F; 方法类型，方法类型method_types是个字符串，存储方法的参数类型和返回值类型</span><br><span class="line">    IMP _Nonnull method_imp;                     &#x2F;&#x2F; 方法实现，用来找到函数地址，实质是函数指针，指向的为方法的实现</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Method将方法名SEL和函数指针IMP关联，当对一个对象发送消息时，会通过给出的SEL去找到IMP，然后执行。</p>
<h1 id="Runtime消息转发"><a href="#Runtime消息转发" class="headerlink" title="Runtime消息转发"></a>Runtime消息转发</h1><p>当找不到对应的方法selector时，Runtime提供了<strong>消息动态解析、消息接受者重定向、消息重定向</strong>等三步处理消息。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Runtime%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="Runtime消息转发"></p>
<h2 id="消息动态解析"><a href="#消息动态解析" class="headerlink" title="消息动态解析"></a>消息动态解析</h2><p>Objective-C运行时会调用<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>提供一个函数实现。<br>前者在对象方法未找到时调用，后者在类方法未找到时调用。<br>可通过重写这两个方法，添加其它函数实现，并返回YES，运行时系统就会重新启动一次消息发送的过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类方法未找到时调起，可以在此添加方法实现</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel;</span><br><span class="line">&#x2F;&#x2F; 对象方法未找到时调起，可以在此添加方法实现</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * class_addMethod    向具有给定名称和实现的类中添加新方法</span><br><span class="line"> * @param cls         被添加方法的类</span><br><span class="line"> * @param name        selector 方法名</span><br><span class="line"> * @param imp         实现方法的函数指针</span><br><span class="line"> * @param types imp   指向函数的返回值与参数类型</span><br><span class="line"> * @return            如果添加方法成功返回 YES，否则返回 NO</span><br><span class="line"> *&#x2F;</span><br><span class="line">BOOL class_addMethod(Class cls, SEL name, IMP imp, </span><br><span class="line">                const char * _Nullable types);</span><br></pre></td></tr></table></figure>

<h2 id="消息接受者重定向"><a href="#消息接受者重定向" class="headerlink" title="消息接受者重定向"></a>消息接受者重定向</h2><p>如果消息动态解析<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>中没有添加其它函数实现，运行时就会进行下一步：消息接受者重定向。<br>如果当前对象实现了<code>-forwardingTargetForSeletor:</code>或<code>+forwardingTargetForSeletor:</code>方法，Runtime就会调用该方法，运行将消息的接受者转发给其它对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 重定向类方法的消息接收者，返回一个类或实例对象</span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">&#x2F;&#x2F; 重定向方法的消息接收者，返回一个类或实例对象</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>

<p>通过<code>forwardingTargetForSeletor</code>可以修改消息的接受者，该方法返回参数是一个对象，<br>如果这个对象不是nil，也不是self，系统会将运行的消息转发给该对象执行。<br>否则，继续进行消息重定向。</p>
<h2 id="消息重定向"><a href="#消息重定向" class="headerlink" title="消息重定向"></a>消息重定向</h2><p>Runtime会利用<code>-methodSignatureForSelector:</code>或<code>+methodSignatureForSelector:</code>方法获取函数的参数和返回值类型。</p>
<ul>
<li>如果<code>methodSignatureForSelector:</code>返回了一个<code>NSMethodSignature</code>对象/函数签名，Runtime会创建一个<code>NSInvocation</code>对象，并通过<code>forwardInvocation:</code>消息通知当前对象，给此次消息发送最后一次寻找IMP的机会。</li>
<li>如果<code>methodSignatureForSelector:</code>返回nil，Runtime发出<code>doesNotRecognizeSelector:</code>消息，程序崩溃。</li>
</ul>
<p><code>forwardInvocation:</code>方法中对消息进行转发：</p>
<ol>
<li>类方法调用：<ol>
<li><code>+methodSignatureForSelector:</code></li>
<li><code>+forwardInvocation:</code></li>
<li><code>+doesNotRecognizeSelector:</code></li>
</ol>
</li>
<li>对象方法调用：<ol>
<li><code>-methodSignatureForSelector:</code></li>
<li><code>-forwardInvocation:</code></li>
<li><code>-doesNotRecognizeSelector:</code></li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取类方法函数的参数和返回值类型，返回签名</span><br><span class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类方法消息重定向</span><br><span class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation；</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取对象方法函数的参数和返回值类型，返回签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象方法消息重定向</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation；</span><br></pre></td></tr></table></figure>

<h1 id="method-swizzling"><a href="#method-swizzling" class="headerlink" title="method swizzling"></a>method swizzling</h1><p>俗称黑魔法，其实就是进行方法交换。</p>
<p>在OC中调用一个方法，其实就是向一个对象发送消息，<strong>查找消息的唯一依据就是selector的名字</strong>。<br>利用OC的动态特性，可在<strong>运行时偷换selector对应的方法</strong>，达到给方法挂钩的目的。</p>
<p>交换方法的实现：</p>
<ul>
<li>利用<code>method_exchangeImplementations</code>交换两个方法的实现；</li>
<li>利用<code>class_replaceMethod</code>替换方法的实现；</li>
<li>利用<code>method_setImplementation</code>直接设置某个方法的IMP。</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Swift和OC一样，都是采用基于引用计数的ARC内存管理方案(针对堆空间的内存管理)。</p>
<p>Swift中ARC有3中引用：</p>
<ul>
<li>强引用<code>strong reference</code>：默认使用的都是强引用；</li>
<li>弱引用<code>weak reference</code>：通过weak定义的引用，必须是可选类型的var；<ul>
<li>实例销毁后，ARC会自动将弱引用设置为nil；</li>
<li>ARC自动给弱引用设置nil时，不会触发属性观察；</li>
<li>weak引用添加了<strong>附加层</strong>，<code>间接地将unowned引用包裹到一个可选容器</code>，附加的机制需要正确的处理可选值。</li>
</ul>
</li>
<li>无主引用<code>unowned reference</code>：通过unowned定义的无主引用；<ul>
<li>不会产生强引用，实例销毁后仍存储着实例的内存地址，类似于OC中的<code>unsafe_unretained</code>；</li>
<li>试图在实例销毁后访问无主引用会产生运行时错误-野指针；</li>
<li>不会去验证引用对象的有效性，若无效，指向已经释放垃圾内存，“unowned(unsafe)”；</li>
<li>当一个unwoned引用被释放后，如果没有其它强引用/unowned引用指向该对象，最终将该对象将被<strong>析构</strong>，否则，对象将会保持未解析可访问状态。</li>
</ul>
</li>
</ul>
<p>循环引用问题：<br>weak、unowned都能解决循环引用的问题，unowned要比weak少一些性能消耗；</p>
<ul>
<li>在生命周期中可能会变成nil的使用weak；</li>
<li>初始化赋值后不会再变成nil的使用unowned，原始实例永远不会为nil，闭包可直接定义为显式解包可选值；</li>
</ul>
<p><em>闭包默认会对用到的外层对象(retain操作)产生额外的强引用，并且只有lazy修饰的闭包才能引用self。</em></p>
<h2 id="内存访问冲突"><a href="#内存访问冲突" class="headerlink" title="内存访问冲突"></a>内存访问冲突</h2><p>在swift中的内存访问冲突主要在两个访问满足下列条件时发生：</p>
<ul>
<li>至少一个是写入操作；</li>
<li>访问的是同一块内存；</li>
<li>访问时间重叠，如在同一函数内；若满足下条件，则安全：<ul>
<li>访问的是实例存储属性，而非计算属性或属性类；</li>
<li>结构体是局部变量，而非全局变量；</li>
<li>结构体没有被闭包捕获，或只被非逃逸闭包捕获。</li>
</ul>
</li>
</ul>
<h2 id="内存泄漏检测"><a href="#内存泄漏检测" class="headerlink" title="内存泄漏检测"></a>内存泄漏检测</h2><p>设计一种机制检测UIViewController内存泄漏：单例对象ping看是否能ping通。</p>
<hr>
<p>Swiftc编译过程：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/swiftc.png" alt="swiftc"></p>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/e709fde38de3" target="_blank" rel="noopener">https://www.jianshu.com/p/e709fde38de3</a></li>
<li><a href="https://www.jianshu.com/p/75849d7ea832" target="_blank" rel="noopener">https://www.jianshu.com/p/75849d7ea832</a></li>
<li><a href="https://www.jianshu.com/p/de4ef8d027ac" target="_blank" rel="noopener">https://www.jianshu.com/p/de4ef8d027ac</a></li>
<li><a href="https://www.jianshu.com/p/b46aae5bb1d0" target="_blank" rel="noopener">https://www.jianshu.com/p/b46aae5bb1d0</a></li>
<li><a href="https://www.jianshu.com/p/b18af4edd9b6" target="_blank" rel="noopener">https://www.jianshu.com/p/b18af4edd9b6</a></li>
</ul>
]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title>svm</title>
    <url>/2020/06/02/svm/</url>
    <content><![CDATA[<h1 id="basic-linear-SVM"><a href="#basic-linear-SVM" class="headerlink" title="basic linear SVM"></a>basic linear SVM</h1><p>最优分界面条件：</p>
<ul>
<li>支持向量机基本模型，是针对<strong>线性可分</strong>的情况下的<strong>最优分界面</strong>提出的；</li>
<li>正类与反类训练样本<strong>可用超平面完全正确分开</strong>。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/svm%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B.png" alt="svm基本模型"></p>
<p>支持向量：经过两类样本中距离最优分类面最近的点，且平行于最优分界面H1、H2(边界超平面)上的训练样本，即图中带圈的点。</p>
<p>带约束的极值问题：<br>$$ min_{w,b} \frac{1}{2} {\Vert w \Vert}^2 $$<br>$$ s.t. y_i(w \cdot x_i + b) \geq 1 $$</p>
<p><em>可通过拉格朗日乘数法并引入拉格朗日乘数，将该约束转化为一个对偶问题，通过寻求该对偶问题的最优解，可得原问题的最优解。</em></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="松弛变量"><a href="#松弛变量" class="headerlink" title="松弛变量"></a>松弛变量</h3><p>由于噪声或其它因素影响，两类数据可能有较少的融合或交叉。<br>引入松弛变量X使得分类器在训练后仍可存在一些错分样本，但要使两类样本间的间隔尽量大，使错分样本的松弛变量之和尽可能小。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.png" alt="松弛变量"></p>
<p>$$ min_{w,b} \frac{1}{2} {\Vert w \Vert}^2 + C \sum_i \xi_i $$<br>$$ s.t. y_i (w \cdot x_i + b) \geq 1 - \xi_i $$</p>
<p>其中，x为松弛变量，满足$x_i \geq 0$；C为大于0的折衷因子，调和来间隔距离和错分样本数之间的关系。</p>
<h3 id="映射到高维空间"><a href="#映射到高维空间" class="headerlink" title="映射到高维空间"></a>映射到高维空间</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%AB%98%E7%BB%B4%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%841.png" alt="高维空间映射1"></p>
<p>为解决线性不可分数据问题，将低维空间的线性不可分数据映射到高维的线性可分空间中。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%AB%98%E7%BB%B4%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%842.png" alt="高维空间映射2"></p>
<p>SVM通过非线性映射f(x)把数据由低维空间向高维空间映射，在高维空间为低维数据构造线性分离超平面。</p>
<p>该分离超平面对应原特征空间上的一个分割超曲面。</p>
<h2 id="用SVM区分行人与非行人HOG特征"><a href="#用SVM区分行人与非行人HOG特征" class="headerlink" title="用SVM区分行人与非行人HOG特征"></a>用SVM区分行人与非行人HOG特征</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/svm_hog.png" alt="svm_hog"></p>
<h1 id="Multiple-instance-SVM"><a href="#Multiple-instance-SVM" class="headerlink" title="Multiple-instance SVM"></a>Multiple-instance SVM</h1><p>将标准SVM的最大化样本间距扩展为最大化样本集间距，即选取<strong>正样本集中最像正样本</strong>的样本用作训练，<strong>负样本中离分界面最近</strong>的负样本作为负样本。</p>
<p>$$ min_{w,b,\xi} \frac{1}{2} {\Vert w \Vert}^2 + C \sum_I {\xi_I} $$<br>$$ s.t. \forall I : Y_I max_{i \in I}(&lt;w,x_i&gt;+b) \geq 1-\xi_I, \xi_I \geq 0 $$</p>
<h1 id="Latent-SVM"><a href="#Latent-SVM" class="headerlink" title="Latent-SVM"></a>Latent-SVM</h1><p><em>Latent-SVM实质上与MI-SVM是一样的，只是扩展了Latent变量。</em></p>
<p>Latent变量：MI-SVM决定正样本集中哪一个样本作为正样本，即一个latent变量，但这个变量的取值是正样本集中的序号。</p>
<p>参考：<br><a href="https://blog.csdn.net/loadstar_kun/article/details/41145665" target="_blank" rel="noopener">https://blog.csdn.net/loadstar_kun/article/details/41145665</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>分类器</tag>
      </tags>
  </entry>
  <entry>
    <title>swift</title>
    <url>/2020/06/30/swift/</url>
    <content><![CDATA[<h1 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h1><p><em>所见及所得，可快速查看语法更改</em></p>
<h1 id="Cocoa框架"><a href="#Cocoa框架" class="headerlink" title="Cocoa框架"></a>Cocoa框架</h1><p>Cocoa是<code>OS X</code>和<code>ios</code>操作系统的程序的运行环境。</p>
<p>Cocoa拥有众多框架：Application、<strong>UIKit</strong>、Cocoa Touch、Media、Core Services/<strong>Foundation</strong>、Core OS。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Cocoa.png" alt="Cocoa"></p>
<p>Foundation框架：</p>
<h1 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h1><p>数据存储的核心就是写文件，主要有4中持久化方式：属性列表、对象序列化、SQLite数据库、CoreData(对象关系映射)。<br>plist文件可以存储的7种数据类型：array，dictory，string，bool，data，date，number。</p>
<h2 id="SandBox"><a href="#SandBox" class="headerlink" title="SandBox"></a>SandBox</h2><p>ios中的沙盒机制是一种安全体系机制。每个app都有一个单独的文件系统/存储空间，而且只能在对应的文件系统中进行操作，即沙盒。所有的非代码文件（资源文件等）都保存在此。</p>
<p>沙盒包含的目录：</p>
<ul>
<li>/AppName.app<ul>
<li>应用程序的程序包目录；</li>
<li>由于应用程序必须经过<strong>签名</strong>，所以不能在运行时对这个目录中的内容进行修改，否则会导致应用程序无法启动。</li>
</ul>
</li>
<li>/Documents/<ul>
<li>保存<strong>应用程序的重要数据文件和用户数据文件</strong>等；</li>
<li>iTunes<strong>同步</strong>时会<strong>备份</strong>该目录。</li>
</ul>
</li>
<li>/Library/Caches<ul>
<li>保存应用程序使用时产生的支持文件和缓存文件，还有日志文件最好也放在这个目录；</li>
<li>iTunes同步时<strong>不备份</strong>该目录。</li>
</ul>
</li>
<li>/Library/Preferences<ul>
<li>保存应用程序的偏好设置文件；</li>
<li>使用<code>NSUserDefaults</code>类设置时创建，不应手动创建。</li>
</ul>
</li>
<li>/tmp/<ul>
<li>保存应用运行时所需要的临时数据；</li>
<li>iphone<strong>重启时会清空</strong>该目录下所有文件。</li>
</ul>
</li>
</ul>
<p>查询app沙盒路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在项目中执行代码打印获取</span><br><span class="line">let homeDir &#x3D; NSHomeDirectory() as Stringprintln(homeDir)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1、获取沙盒根目录</span><br><span class="line">let homeDir &#x3D; NSHomeDirectory() as String</span><br><span class="line">&#x2F;&#x2F; 2、获取 Documents 目录</span><br><span class="line">let docDirs &#x3D; NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true) as NSArraylet docDir &#x3D; docDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 3、获取 Caches 目录</span><br><span class="line">let cachesDirs &#x3D; NSSearchPathForDirectoriesInDomains(.CachesDirectory, .UserDomainMask, true) as NSArraylet cachesDir &#x3D; cachesDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 4、获取 Library 目录</span><br><span class="line">let libDirs &#x3D; NSSearchPathForDirectoriesInDomains(.LibraryDirectory, .UserDomainMask, true) as NSArraylet libDir &#x3D; libDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 5、获取 tmp 目录</span><br><span class="line">let tmpDir &#x3D; NSTemporaryDirectory() as String</span><br></pre></td></tr></table></figure>

<h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><p>通过<code>fileManager</code>对沙盒中的目录/文件进行操作。</p>
<h3 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h3><p>app都是通过<code>bundle</code>进行封装的，可以将<code>bundle</code>理解为上述沙盒中的<code>AppName.app</code>文件。</p>
<p>在<code>Finder</code>中，会把<code>bundle</code>当做文件显示，防止用户误操作，但其内部是一个目录，包含图像、媒体资源、编译的代码、nib文件等，这个目录称为<code>main bundle</code>。</p>
<p><code>Cocaoa</code>提供了<code>NSBundle类</code>封装了<code>bundle</code>操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取应用程序的 main bundle</span><br><span class="line">var mainBundle &#x3D; NSBundle.mainBundle()</span><br><span class="line">&#x2F;&#x2F; 使用 main bundle 获取资源路径</span><br><span class="line">var testFilePath &#x3D; mainBundle.pathForResource(&quot;logo&quot;, ofType: &quot;png&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><h2 id="KVC设值"><a href="#KVC设值" class="headerlink" title="KVC设值"></a>KVC设值</h2><p>通过对象中对应的key，KVC在内部寻找key，并调用<code>setValue:属性值forKey:@&quot;name&quot;</code>，底层执行机制为：</p>
<ol>
<li>程序优先调用<code>set&lt;Key&gt;:属性值</code>方法，代码通过setter方法完成设置。*<key>指成员变量名，首字母大小写要符合KVC命名规则。*</li>
<li>若没有找到<code>setName:</code>方法，<ol>
<li>KVC机制会检查<code>+(BOOL)accessInstanceVariablesDirectly</code>方法有没有返回YES，默认返回YES；</li>
<li>若重写该方法返回NO，会执行<code>setValue:forUndefinedKey</code>方法，一般不会这么做，当找不到时，会直接执行第4步。</li>
<li>KVC机制会搜索该类中名为<key>的成员变量，无论该变量是在类接口处定义，还是在类实现处定义，无论使用怎样的访问修饰符，只要存在以<key>命名的变量，KVC都可对该成员变量赋值。</li>
</ol>
</li>
<li>若该类既没有<code>set&lt;key&gt;:</code>方法，也没有<code>_&lt;key&gt;</code>和<code>_is&lt;key&gt;</code>成员变量，KVC机制会搜索<code>&lt;key&gt;</code>和<code>is&lt;key&gt;</code>的成员变量，并赋值。</li>
<li>如果方法或成员变量都不存在，系统将会执行该对象的<code>setValue:forUndefinedKey:</code>方法，默认为抛出异常。</li>
</ol>
<h2 id="KVC取值"><a href="#KVC取值" class="headerlink" title="KVC取值"></a>KVC取值</h2><p>当调用<code>valueForKey:@&quot;name&quot;</code>时，KVC对key的搜索方式不同于<code>setValue:属性值forKey:@&quot;name&quot;</code>，其搜索方式为：</p>
<ol>
<li>首先，按<code>get&lt;key&gt;,&lt;key&gt;,is&lt;key&gt;</code>的顺序方法查找getter方法，找到就直接调用；如果是BOOL或Int等值类型，会将其包装成一个NSNumber对象。</li>
<li>如果getter没有找到，KVC会查找<code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes</code>格式的方法；<ol>
<li>如果<code>countOf&lt;Key&gt;</code>和另外两个方法中的一个，那么就会返回一个可以响应NSArray所有方法的代理集合(NSkeyValueArray，是NSArray的子类)；</li>
<li>调用该代理集合的方法，或给该代理发送属于NSArray的方法，就会以<code>countOf&lt;Key&gt;, objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes</code>方法组合的形式调用；</li>
<li>可选方法<code>get&lt;Key&gt;:range:</code>。</li>
</ol>
</li>
<li>若没有找到，会同时查找<code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;, memberOf&lt;Key&gt;</code>格式的方法；<ol>
<li>如果找到这三个方法，则返回一个可响应NSSet所有方法的代理集合；</li>
<li>给该代理集合发送NSSet的消息，就会以<code>countOf&lt;Key&gt;, enumeratorOf&lt;Key&gt;, memberOf&lt;Key&gt;</code>组合的形式调用。</li>
</ol>
</li>
<li>若还没找到，检查类方法<code>+(BOOL)accessInstanceVariablesDirectly</code>；<ol>
<li>若返回YES（默认），按照<code>_&lt;Key&gt;, _is&lt;Key&gt;, &lt;Key&gt;, is&lt;Key&gt;</code>的顺序搜索成员变量名；</li>
<li>如重写了类方法<code>+(BOOL)accessInstanceVariablesDirectly</code>，返回NO，便直接调用<code>valueForUndefinedKey:</code>方法，默认抛出异常。</li>
</ol>
</li>
</ol>
<p>iOS开发中使用@property声明属性时，经常用到atomic与nonatomic两个关键字：</p>
<ul>
<li>atomic系统自动生成的getter/setter方法会进行加锁操作，只保证了getter和setter存取方法的线程安全,但<strong>不能保证整个对象线程安全</strong>；</li>
<li>nonatomic系统自动生成的getter/setter方法不会进行加锁操作。</li>
</ul>
<h2 id="KVC处理数值和结构体类型属性"><a href="#KVC处理数值和结构体类型属性" class="headerlink" title="KVC处理数值和结构体类型属性"></a>KVC处理数值和结构体类型属性</h2><p><code>valueForKey:</code>总是返回一个🆔对象，若原本变量类型为值类型或结构体，返回值会封装成NSNumber或NSValue对象。<br><code>setValue:forKey:</code>需要手动将值类型转换为NSNumber或NSValue类型。</p>
<p>因为传递进去和取出来的都是id类型，所以需要开发者自己担保类型的正确性，运行时Objective-C在发送消息时会检查类型，如果错误会直接抛出异常。</p>
<h2 id="KVC处理集合"><a href="#KVC处理集合" class="headerlink" title="KVC处理集合"></a>KVC处理集合</h2><p>简单集合运算符：@avg，@count，@max，@min，@sum。<br>对象运算符：能以数组的方式返回指定的内容。</p>
<ul>
<li><code>@distinctUnionOfObjects</code>：返回元素唯一，类似Set；</li>
<li><code>@unionOfObjects</code>：返回全部元素。</li>
</ul>
<h2 id="KVC处理字典"><a href="#KVC处理字典" class="headerlink" title="KVC处理字典"></a>KVC处理字典</h2><p>当对NSDictionary对象使用KVC时，<code>valueForKey:</code>表现行为和<code>objectForKey:</code>一样，常使用<code>valueForKeyPath:</code>来访问多层嵌套的字典。</p>
<p><code>dictionaryWithValuesForKeys:</code>指输入一组key，返回这组key对应的属性，再组成一个字典。<br><code>setValuesForKeysWithDictionary</code>用来修改Model中对应key的属性。</p>
<h2 id="KVC处理异常"><a href="#KVC处理异常" class="headerlink" title="KVC处理异常"></a>KVC处理异常</h2><p>KVC处理nil异常：重写<code>setNilValueForKey:</code>方法。</p>
<p>KVC处理UndefinedKey异常：重写<code>forUndefinedKey</code>方法。</p>
<h2 id="KVC使用场景"><a href="#KVC使用场景" class="headerlink" title="KVC使用场景"></a>KVC使用场景</h2><ul>
<li>动态地取值和设值；</li>
<li>访问和修改私有变量；</li>
<li>Model和字典转换：通常和runtime组合使用；</li>
<li>修改部分控件的内部属性；</li>
<li>操作集合：<code>valueForKey:</code>方法的特殊实现，如NSArray和NSSet容器类；</li>
<li>实现高阶消息传递<code>valueForKey:</code>传递给容器的每一个对象，结果添加到返回的容器中；</li>
</ul>
<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p><code>Key-Value Observing</code>，键值观察，是基于KVC实现的，是一种<strong>观察者模式的衍生</strong>。</p>
<p><strong>基本思想：</strong>对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的KVO接口方法，自动的通知观察者。</p>
<p>KVO可以通过监听key，来获得value的变化，用来在对象之间监听状态变化。<br>KVO的原理是修改被观察者的setter方法。<br>KVO的定义都是对NSObject的扩展来实现的，OC中有个显式的NSKeyValueObserving类别名，对于所有继承NSObject的类型，都可使用KVO。</p>
<p>KVO中，观察者和被观察者的改变发生在<strong>同一线程</strong>上，需要确保线程安全。</p>
<h2 id="注册与解除注册"><a href="#注册与解除注册" class="headerlink" title="注册与解除注册"></a>注册与解除注册</h2><p>若已经拥有可供键值观察属性的类，即可通过在该类的对象(被观察对象)上调用名为NSKeyValueObserverRegistration的category方法将观察者对象与被观察者对象注册与解除注册。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>observer:观察者，也就是KVO通知的订阅者；</li>
<li>observeValueForKeyPath:ofObject:change:context:方法；</li>
<li>keyPath：描述将要观察的属性，相对于被观察者；</li>
<li>options：KVO的一些属性配置；<ul>
<li>NSKeyValueObservingOptionNew：change字典包括改变后的值；</li>
<li>NSKeyValueObservingOptionOld:change字典包括改变前的值；</li>
<li>NSKeyValueObservingOptionInitial:注册后立刻触发KVO通知；</li>
<li>NSKeyValueObservingOptionPrior:值改变前是否也要通知（这个key决定了是否在改变前改变后通知两次）</li>
</ul>
</li>
<li>context: 上下文，传递到订阅者的函数中，用来区分消息。</li>
</ul>
<p>系统通过重写dealloc方法来<strong>释放资源</strong>。</p>
<h2 id="KVO实现"><a href="#KVO实现" class="headerlink" title="KVO实现"></a>KVO实现</h2><p>KVO是通过<code>isa-swizzling</code>实现的，基本流程为：</p>
<ul>
<li>编译器自动为被观察者对象创造一个派生类，并将被观察对象的isa指向该派生类；</li>
<li>若用户注册了对此目标对象的某一个属性的观察，派生类会重写该方法(只重写注册观察者的属性方法)，并在其中添加通知对象；</li>
<li>OC在发送消息时，通过isa指针找到当前对象所属的类对象，类对象中保存着当前对象的实例方法，因此向此对象发送消息，实际上是发送到了派生类对象的方法；</li>
<li>由于编译器对派生类的方法进行了override，并添加了通知对象，因此会向注册的对象发送通知。</li>
</ul>
<h2 id="手动KVO"><a href="#手动KVO" class="headerlink" title="手动KVO"></a>手动KVO</h2><ul>
<li><code>- (void)willChangeValueForKey:(NSString *)key;</code>：将要发生改变；</li>
<li><code>- (void)didChangeValueForKey:(NSString *)key;</code>：已经发生改变；<br>在不用的时候，一定要<strong>解除注册</strong>，否则会导致内存泄漏。</li>
</ul>
<p>每当监听的keyPath发生变化，就会在<code>-(void)observeValueForKeyPath:</code>函数中进行回调：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context</span><br></pre></td></tr></table></figure>

<p><em>键值观察依赖键</em></p>
<h2 id="禁用KVO"><a href="#禁用KVO" class="headerlink" title="禁用KVO"></a>禁用KVO</h2><p>实现类方法<code>automaticallyNotifiesObserversForKey</code>返回NO，实现属性的setter方法，不调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>在swift中有专门的指针类型，均被定义为<strong>unsafe</strong>：</p>
<ul>
<li><code>UnsafePointer&lt;Pointee&gt;</code>：类似于C语言中的<code>const Pointee *</code>，只能访问内存，不能修改内存；</li>
<li><code>UnsafeMutablePointer&lt;Pointee&gt;</code>：类似于C语言中的<code>Pointee *</code>，可访问和修改内存；</li>
<li><code>UnsafeRawPointer</code>：类似于<code>const void *</code>，只读，不支持泛型；</li>
<li><code>UnsafeMutableRawPointer</code>：类似于void，可读可写，不支持泛型。</li>
</ul>
<p>获取变量的指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取可变的变量指针, value参数接受变量地址，取决于body闭包的返回值</span><br><span class="line">@inlinable public func withUnsafeMutablePointer&lt;T, Result&gt;(to value: inout T, _ body: (UnsafeMutablePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</span><br><span class="line">&#x2F;&#x2F; 获取不可变的变量指针, value参数接受变量，取决于body闭包的返回值</span><br><span class="line">@inlinable public func withUnsafePointer&lt;T, Result&gt;(to value: T, _ body: (UnsafePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</span><br><span class="line">&#x2F;&#x2F; 获取不可变的变量指针, value参数接受变量地址，取决于body闭包的返回值</span><br><span class="line">@inlinable public func withUnsafePointer&lt;T, Result&gt;(to value: inout T, _ body: (UnsafePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result</span><br></pre></td></tr></table></figure>

<p>分配内存创建指针：</p>
<ul>
<li>malloc</li>
<li>allocate：只有<code>UnsafeMutableRawPointer</code>和<code>UnsafeMutablePointer&lt;T&gt;</code>才有此分配方法。</li>
</ul>
<h1 id="通知-消息推送"><a href="#通知-消息推送" class="headerlink" title="通知/消息推送"></a>通知/消息推送</h1><h2 id="Apple提供的通知服务"><a href="#Apple提供的通知服务" class="headerlink" title="Apple提供的通知服务"></a>Apple提供的通知服务</h2><ol>
<li>应用服务提供商从<strong>服务器端</strong>将要发送的消息和<strong>设备令牌(device token)</strong>发送给apple的<strong>消息推送服务器APNs</strong>；</li>
<li>APNs根据设备令牌在已注册的设备中查找对应的设备，将消息发送给相应的设备；</li>
<li>客户端设备将接收到的消息<strong>传递给相应的应用程序</strong>，应用程序根据<strong>用户设置</strong>弹出通知消息。</li>
</ol>
<ul>
<li>优点：<ul>
<li>不论应用是否开启，都会发送到手机端；</li>
</ul>
</li>
<li>缺点：<ul>
<li>消息推送机制是苹果服务端控制，个别时候可能会有延迟，因为苹果服务器也需要队列来处理所有的消息请求。</li>
</ul>
</li>
</ul>
<h2 id="第三方推送机制"><a href="#第三方推送机制" class="headerlink" title="第三方推送机制"></a>第三方推送机制</h2><p>普遍使用<strong>Socket机制</strong>来实现，几乎可以达到<strong>即时</strong>的发送到目标用户手机端，适用于即时通讯类应用。</p>
<ul>
<li>优点：<ul>
<li>实时的，取决于心跳包的节奏；</li>
</ul>
</li>
<li>缺点：<ul>
<li>iOS系统的限制，应用不能长时间的后台运行，应用关闭时不可用。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/" target="_blank" rel="noopener">https://numbbbbb.gitbooks.io/-the-swift-programming-language-/</a></li>
<li><a href="https://www.cnblogs.com/zjoch/p/4702873.html" target="_blank" rel="noopener">https://www.cnblogs.com/zjoch/p/4702873.html</a></li>
<li><a href="https://blog.csdn.net/Listron/article/details/80197347" target="_blank" rel="noopener">https://blog.csdn.net/Listron/article/details/80197347</a></li>
<li><a href="https://www.jianshu.com/p/2cef1e80042c" target="_blank" rel="noopener">https://www.jianshu.com/p/2cef1e80042c</a></li>
<li><a href="https://www.jianshu.com/p/b9f020a8b4c9" target="_blank" rel="noopener">https://www.jianshu.com/p/b9f020a8b4c9</a></li>
<li><a href="https://www.jianshu.com/p/fa982b71ca1f" target="_blank" rel="noopener">https://www.jianshu.com/p/fa982b71ca1f</a></li>
<li><a href="https://juejin.im/post/5a31dc76f265da430c11d3ab" target="_blank" rel="noopener">https://juejin.im/post/5a31dc76f265da430c11d3ab</a></li>
<li><a href="https://www.jianshu.com/p/74a84a696140" target="_blank" rel="noopener">https://www.jianshu.com/p/74a84a696140</a></li>
<li><a href="https://www.jianshu.com/p/d7df139b0f15" target="_blank" rel="noopener">https://www.jianshu.com/p/d7df139b0f15</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>swift中的图片管理</title>
    <url>/2020/07/22/swift%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h1><p>使用ImageNamed方法生成的UIImage对象，会在应用的bundle中寻找，找到则Cache到系统缓存，作为内存的Cache(只能系统自动处理)；<br>当加载很多很大的图片时，内存消耗过大，会遇到<code>memory warnings</code>，从而强制释放内存。</p>
<h1 id="xcassets"><a href="#xcassets" class="headerlink" title="xcassets"></a>xcassets</h1><p>注意事项：</p>
<ul>
<li>图片的大小要准确，不能出现图片太大的情况；</li>
<li>不要存放大图，会产生缓存；</li>
<li>不要存放JPEG格式的图片，会导致图片变大。</li>
</ul>
<p>Bundle和xcassets的主要区别：</p>
<ul>
<li>xcassets中的图片，只能通过imageNamed加载；Bundle还可通过imageWithContentsOfFile等方式加载；</li>
<li>xcassets中的2x和3x，会根据具体设备分发，不会同时包含；Bundle则同时都包含；</li>
<li>xcassets内可对图片进行剪裁和拉伸，Bundle不支持；</li>
<li>Bundle支持多语言，而xcassets不支持；</li>
</ul>
<h1 id="释放图片内存"><a href="#释放图片内存" class="headerlink" title="释放图片内存"></a>释放图片内存</h1><p><code>[[UIImageView alloc] init]</code>返回的都是一些<strong>autorelease对象</strong>，当引用计数为0时不一定立即释放，但会在<strong>autoreleasepool</strong>结尾时释放。</p>
<h1 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h1><p>SDWebImage具有缓存支持的异步映像下载程序。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://www.jianshu.com/p/ca130b97446b" target="_blank" rel="noopener">https://www.jianshu.com/p/ca130b97446b</a></li>
<li><a href="https://www.jianshu.com/p/efe8565c4218" target="_blank" rel="noopener">https://www.jianshu.com/p/efe8565c4218</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>二进制运算</title>
    <url>/2020/07/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">名称</th>
<th align="center">表示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">按位与</td>
<td align="center">对应位均为1，才为1；否则为0</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">按位或</td>
<td align="center">对应位有1，即为1；否则为0</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">按位异或</td>
<td align="center">相同异或为1；不同异或为1</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">按位取反</td>
<td align="center">1变0，0变1</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">按位左移</td>
<td align="center">左移，右边补0，相当*2</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">有符号的右移</td>
<td align="center">右移，左边补符号位，负数以原码形式参与运算</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt;</td>
<td align="center">无符号的右移</td>
<td align="center">右移，左边补0，所有数据以无符号方式计算</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/2020/06/08/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="CNN基本组件"><a href="#CNN基本组件" class="headerlink" title="CNN基本组件"></a>CNN基本组件</h1><h2 id="卷积层-Convolutional-layer"><a href="#卷积层-Convolutional-layer" class="headerlink" title="卷积层 Convolutional_layer"></a>卷积层 Convolutional_layer</h2><p>用一个采样器从输入数据中采集关键数据内容；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CNN%E5%8D%B7%E7%A7%AF%E5%8E%9F%E7%90%86.png" alt="CNN卷积原理"></p>
<p>3D滤波器/卷积核：</p>
<ul>
<li>以扫描窗的方式，对图像做卷积；</li>
<li><strong>每层包含多个卷积核，每个核对应一个输出通道</strong>；</li>
<li>用于提取局部特征；</li>
<li>权重参数根据训练学习获得。</li>
</ul>
<p>通过代码看卷积核的超参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nn.Conv2d(self, in_channels, out_channels, kernel_size, stride&#x3D;1, padding&#x3D;0, dilation&#x3D;1, groups&#x3D;1, bias&#x3D;True))</span><br></pre></td></tr></table></figure>
<ul>
<li>in_channel：输入数据的通道数;</li>
<li>out_channel：输出数据的通道数，根据模型调整，对应<strong>滤波器/卷积核的数量</strong>；</li>
<li>kennel_size：卷积核大小；</li>
<li>Stride：步长，默认为1；</li>
<li>padding：zero padding。</li>
</ul>
<p><em>卷积操作一般要把卷积核旋转$180^\circ$再相乘的(反向传播)。</em></p>
<a href="/2020/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" title="激活函数">激活函数</a>

<h2 id="池化层-Pooling-layer"><a href="#池化层-Pooling-layer" class="headerlink" title="池化层 Pooling_layer"></a>池化层 Pooling_layer</h2><p>对卷积层结果进行压缩，得到更加重要的特征，并有效控制过拟合。</p>
<p>计算类别：</p>
<ul>
<li>平均池化</li>
<li>最大池化</li>
</ul>
<p>通过代码查看最大池化层的超参数设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nn.MaxPool2d(kernel_size, stride&#x3D;None, padding&#x3D;0, dilation&#x3D;1, return_indices&#x3D;False, ceil_mode&#x3D;False)</span><br></pre></td></tr></table></figure>
<ul>
<li>kernel_size(int or tuple)：max pooling的窗口大小；</li>
<li>stride(int or tuple, optional)：max pooling的窗口移动的步长，默认kernel_size；</li>
<li>padding(int or tuple, optional)：输入的每一条边补充0的层数；</li>
<li>dilation(int or tuple, optional)：一个控制窗口中元素步幅的参数；</li>
<li>return_indices：若为True，返回输出最大值的序号，对于上采样操作有帮助；</li>
<li>ceil_mode：若为True，计算输出信号大小时，会使用向上取整，默认向下取整。</li>
</ul>
<h3 id="池化层的误差反向传播"><a href="#池化层的误差反向传播" class="headerlink" title="池化层的误差反向传播"></a>池化层的误差反向传播</h3><p>对pooling进行填充后，将卷积核旋转$180^\circ$，进行反向传播计算。</p>
<ol>
<li>mean-pooling</li>
</ol>
<ul>
<li>使用等值复制方式，将[[1,2],[3,4]]变为[[1,1,2,2],[1,1,2,2],[3,3,4,4],[3,3,4,4]];</li>
<li>需要满足反向传播时各层间残差总和不变，所以对卷积层对应的每个值需要平摊。</li>
</ul>
<ol start="2">
<li>max-pooling</li>
</ol>
<ul>
<li>前向传播过程中<strong>需要记录pooling区域中最大值的位置</strong>；</li>
<li>将[[1,2],[3,4]]放入对应的最大值位置，如[[1,0,0,2],[0,0,0,0],[0,0,0,0],[3,0,0,4]];</li>
</ul>
<h2 id="全连接层-Fully-Connected-layer"><a href="#全连接层-Fully-Connected-layer" class="headerlink" title="全连接层 Fully-Connected_layer"></a>全连接层 Fully-Connected_layer</h2><p>对卷积后高度抽象化的特征进行整合，然后归一化，对各种分类情况输出一个概率，之后的分类器Classifier根据全连接得到的概率进行分类。</p>
<a href="/2020/06/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="SoftMax">SoftMax</a>

<p>FCL对接n维的software层，得到n类标签的概率，用于构建loss。</p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分割</title>
    <url>/2020/05/28/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><p>图像分割：根据灰度、颜色、纹理、形状等特征，将图像划分为若干互不交叠的区域，并使这些特征在同一区域内呈现出相似性，在不同区域间呈现出明显的差异。</p>
<p>经典数字图像分割算法一般基于灰度值的两个基本特性：</p>
<ul>
<li>不连续性；</li>
<li>相似性。</li>
</ul>
<p>前景/背景分割：</p>
<ul>
<li>前景一般包含物体；</li>
<li>需要交互提供初始标记。</li>
</ul>
<h2 id="基于阈值的分割方法"><a href="#基于阈值的分割方法" class="headerlink" title="基于阈值的分割方法"></a>基于阈值的分割方法</h2><p>基本思想：基于图像的灰度特征来计算一个或多个灰度阈值，并将图像中每个像素的灰度值与阈值相比较，最后将像素根据比较结果分到合适的类别中。</p>
<p>设定某一灰度阈值T，将图像分为两部分：大于T的像素群和小于T的像素群，选定一个<strong>合适的阈值</strong>即可将图像准确地分割开。</p>
<h2 id="基于边缘的分割方法"><a href="#基于边缘的分割方法" class="headerlink" title="基于边缘的分割方法"></a>基于边缘的分割方法</h2><p>边缘，是指图像中两个不同区域的边界线上连续的像素点的集合，是图像局部特征不连续性的反映，体现了灰度、颜色、纹理等图像特性的<strong>突变</strong>。</p>
<p>基本思路：先确定图像中的边缘像素，然后再把这些像素连接在一起构成所需的区域边界。</p>
<hr>
<h1 id="传统图像分割方法"><a href="#传统图像分割方法" class="headerlink" title="传统图像分割方法"></a>传统图像分割方法</h1><h2 id="基于区域的分割方法"><a href="#基于区域的分割方法" class="headerlink" title="基于区域的分割方法"></a>基于区域的分割方法</h2><p>将图像按照相似性准则分成不同的区域。</p>
<h3 id="区域生长法"><a href="#区域生长法" class="headerlink" title="区域生长法"></a>区域生长法</h3><p>根据一种事先定义的准则，将像素或子区域聚合成更大区域的过程，并且要充分保证分割后的区域满足以下条件：</p>
<ul>
<li>内部连通、互斥；</li>
<li>各子集的并集能构成全集。</li>
</ul>
<p>区域生长的条件：根据像素灰度间的连续性定义的一些相似性准则；<br>区域生长停止的条件：一个终止规则。</p>
<p>区域生长法定义了最大像素灰度值距离，当待加入像素点的灰度值和已分割好的区域所有像素点的平均灰度的差的绝对值不大于最大像素灰度值距离时，该像素点加入到该分割区域；相反，则区域生长算法停止。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF.png" alt="区域生长"></p>
<h3 id="分水岭方法"><a href="#分水岭方法" class="headerlink" title="分水岭方法"></a>分水岭方法</h3><p>将图像中的<strong>边缘</strong>转化为<strong>山脉</strong>，将<strong>均匀区域</strong>转化为<strong>山谷</strong>。</p>
<p>在分割过程中，该方法会将临近像素间的相似性作为重要的参考依据，从而将在<strong>空间位置上相近</strong>，并且<strong>灰度值相近</strong>的像素点互相连接起来，构成一个封闭的轮廓。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%88%86%E6%B0%B4%E5%B2%AD.png" alt="分水岭"></p>
<p>操作步骤：</p>
<ol>
<li>彩色图像灰度化；</li>
<li>求梯度图；</li>
<li>进行分水岭算法，求得分段图像的边缘线。</li>
</ol>
<h2 id="基于图论的分割方法"><a href="#基于图论的分割方法" class="headerlink" title="基于图论的分割方法"></a>基于图论的分割方法</h2><p>将图像分割问题与图的最小割mincut问题联系。将图像映射为带权无向图，图中每个节点对应于图像中的每个像素，每条边的权值对应相邻像素间在灰度、颜色、纹理等方面的非负相似度。</p>
<a href="/2020/06/06/GraphCuts%E5%88%86%E5%89%B2/" title="GraphCuts分割">GraphCuts分割</a>

<a href="/2020/06/06/GrabCut%E5%88%86%E5%89%B2/" title="GrabCut分割">GrabCut分割</a>]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分类问题</title>
    <url>/2020/07/05/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="CNN网络进化-结构演化"><a href="#CNN网络进化-结构演化" class="headerlink" title="CNN网络进化/结构演化"></a>CNN网络进化/结构演化</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CNN%E7%BB%93%E6%9E%84%E6%BC%94%E5%8C%96.png" alt="CNN结构演化"></p>
<p>AlexNet -&gt; VGG -&gt; GoogleNet -&gt; ResNet;</p>
<h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p><em>ImageNet-2012竞赛No.1，标志着DNN深度学习革命的开始。</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/AlexNet.png" alt="AlexNet"></p>
<ul>
<li>使用了5个卷积层，3个全连接层；</li>
<li>使用了ReLu非线性激活；</li>
<li>进行<code>Max pooling</code>池化；</li>
<li>使用了Dropout regularization；</li>
<li>局部响应归一化LRN（被抛弃）；</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Alexnet%E7%BB%93%E6%9E%84.png" alt="Alexnet结构"></p>
<p>结构分解：</p>
<ol>
<li>输入层：224<em>224</em>3；</li>
<li>卷积层1：96<em>11<em>11</em>3，ReLU-&gt;MP-&gt;LRN；<em>tip：2个GPU\</em>48个卷积核，卷积核大小11*11，3通道。</em></li>
<li>卷积层2：256<em>5</em>5*48，ReLU-&gt;MP-&gt;LRN；</li>
<li>卷积层3：384<em>3</em>3*256，ReLU；</li>
<li>卷积层4：384<em>3</em>3*192，ReLU-&gt;MP；</li>
<li>卷积层5：256<em>3</em>3*192，ReLU；</li>
<li>全连接层1：4096，ReLu；</li>
<li>全连接层2：4096，ReLu；</li>
<li>全连接层3：1000，ReLu-&gt;MP；</li>
<li>Softmax层：1000；</li>
<li>Loss：$arg max_w{ \frac{1}{N} \sum -log(p(f(x,w)=y(x))) }$标签概率的log值的和。</li>
</ol>
<h2 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h2><p>优点：</p>
<ul>
<li>结构简单；</li>
<li>容易修改，迁移到其他任务中；</li>
<li>高层任务的基础网络；</li>
</ul>
<h2 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h2><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><h2 id="ImageNet数据集"><a href="#ImageNet数据集" class="headerlink" title="ImageNet数据集"></a><a href="http://image-net.org/" target="_blank" rel="noopener">ImageNet数据集</a></h2><p>根据WordNet组织的图片集，为一个名词提供平均1000张图片。</p>
<h2 id="MIT的数据集"><a href="#MIT的数据集" class="headerlink" title="MIT的数据集"></a>MIT的数据集</h2><p>Places2数据集</p>
<h2 id="CIFAR-10数据集"><a href="#CIFAR-10数据集" class="headerlink" title="CIFAR-10数据集"></a>CIFAR-10数据集</h2><p>共有6w张彩色图像，分辨率为32*32，分为10类，每类6k张图。</p>
<p>其中，</p>
<ul>
<li>5w张用于训练，构成5个epoch，每个epoch1w张；</li>
<li>1w张用于测试，单独为1批；</li>
<li>测试批中的数据，每类中抽取1k张。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://image-net.org/challenges/LSVRC/2017/" target="_blank" rel="noopener">http://image-net.org/challenges/LSVRC/2017/</a></li>
<li><a href="https://www.pianshen.com/article/2717286724/" target="_blank" rel="noopener">https://www.pianshen.com/article/2717286724/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>图像格式</title>
    <url>/2020/06/05/%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="图片存储格式"><a href="#图片存储格式" class="headerlink" title="图片存储格式"></a>图片存储格式</h1><p>常用存储格式：<br>  bmp,jpg,png,tiff,gif,<br>  pcx,tga,exif,fpx,svg,<br>  psd,cdr,pcd,dxf,ufo,<br>  eps,ai,raw,WMF,webp等。</p>
<ul>
<li>BMP：采用位映射存储，占用空间大。</li>
<li>JPG：常用有损压缩格式，压缩比例可达10:1-40:1。</li>
<li>PNG：无损压缩图像文件格式，比GIF小30%。</li>
<li>GIF：基于LZW算法的连续色调的无损压缩格式，压缩率一般在50%左右。</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
  </entry>
  <entry>
    <title>图像增强</title>
    <url>/2020/04/13/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h1 id="图像增强目标"><a href="#图像增强目标" class="headerlink" title="图像增强目标"></a>图像增强目标</h1><ul>
<li>改善图像视觉效果；</li>
<li>抑制无用信息，提高图像的使用价值；</li>
<li>转换为更适合人或机器分析处理的形式。</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>图像增强</tag>
      </tags>
  </entry>
  <entry>
    <title>图像特征</title>
    <url>/2020/05/25/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="颜色特征"><a href="#颜色特征" class="headerlink" title="颜色特征"></a>颜色特征</h1><p>RGB图像3通道分解：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/3Dtensor.png" alt="3Dtensor"></p>
<h2 id="量化颜色直方图"><a href="#量化颜色直方图" class="headerlink" title="量化颜色直方图"></a>量化颜色直方图</h2><p>RGB、HSV等颜色空间适用。</p>
<h2 id="聚类颜色直方图"><a href="#聚类颜色直方图" class="headerlink" title="聚类颜色直方图"></a>聚类颜色直方图</h2><p>Lab等颜色空间适用。</p>
<hr>
<h1 id="几何特征"><a href="#几何特征" class="headerlink" title="几何特征"></a>几何特征</h1><h2 id="边缘Edge"><a href="#边缘Edge" class="headerlink" title="边缘Edge"></a>边缘Edge</h2><p>像素明显变化的区域 -&gt; 一阶导数的极值区域。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BE%B9%E7%BC%98%E7%89%B9%E5%BE%81.png" alt="边缘特征"></p>
<h3 id="边缘提取"><a href="#边缘提取" class="headerlink" title="边缘提取"></a>边缘提取</h3><p>导数对噪声敏感 -&gt; 先高斯去噪，再使用一阶导数获取极值。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96.png" alt="边缘提取"></p>
<ul>
<li>高斯滤波一阶导：<br>  $$ h_x(x,y) = \frac{\partial h(x,y)}{\partial x} = \frac{-x}{2\Pi \sigma^4} e^{-\frac{x^2+y^2}{2\sigma^2}} $$<br>  $$ h_y(x,y) = \frac{\partial h(x,y)}{\partial y} = \frac{-y}{2\Pi \sigma^4} e^{-\frac{x^2+y^2}{2\sigma^2}} $$</li>
<li>梯度幅值/强度：<br>  $$ h_x(x,y)^2 + h_y(x,y)^2 $$</li>
<li>梯度增加最快的方向：<br>  $$ \arctan(\frac{h_y(x,y)}{h_x(x,y)}) $$</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BE%B9%E7%BC%98%E6%A2%AF%E5%BA%A6%E8%A7%A3%E6%9E%90.png" alt="边缘梯度解析"></p>
<h3 id="Gabor"><a href="#Gabor" class="headerlink" title="Gabor"></a>Gabor</h3><p>Gabor是一个<strong>用于边缘提取的线性滤波器</strong>，其频率和方向表达与人类视觉系统类似，能够提供<strong>良好的方向选择和尺度选择特性，而且对光照变化不敏感</strong>，适用于纹理分析。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Gabor.png" alt="Gabor"></p>
<p>使用一个三角函数与一个高斯函数叠加即可得到一个Gabor滤波器。</p>
<p>Gabor滤波器组：多频域/尺度、多方向<br>  <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/3%E5%B0%BA%E5%BA%A68%E6%96%B9%E5%90%91.png" alt="3尺度8方向"></p>
<ul>
<li><p>频域：属于加窗傅立叶变换</p>
</li>
<li><p>空域：一个高斯核函数和正弦平面波的乘积</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/gabor%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%BB%84.png" alt="gabor滤波器组"></p>
</li>
</ul>
<h2 id="角点"><a href="#角点" class="headerlink" title="角点"></a>角点</h2><h3 id="Harris角点"><a href="#Harris角点" class="headerlink" title="Harris角点"></a>Harris角点</h3><p>在任何方向上移动小观察窗，导致大的像素变动。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Harris%E8%A7%92%E7%82%B9.png" alt="Harris角点"><br>$ E(u,v) = \sum_{x,y} w(x,y)[I(x+u,y+v)-I(x,y)]^2 $</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Harris%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B.png" alt="Harris角点检测"></p>
<p>$$ E(u,v) \cong [u,v] M [u,v]^T<br>M = \sum_{x,y} w(x,y)[I(x+u,y+v)-I(x,y)]^2<br>M \rightarrow \lambda_{max},\lambda_{min} $$</p>
<ul>
<li>图像中直线：一个特征值大，一个特征值小；</li>
<li>图像中平面：两个特征值都小，且近似相等；</li>
<li>图像中角点：两个特征值都大，且近似相等。</li>
</ul>
<h3 id="Fast角点（快速角点特征检测）"><a href="#Fast角点（快速角点特征检测）" class="headerlink" title="Fast角点（快速角点特征检测）"></a>Fast角点（快速角点特征检测）</h3><p>对兴趣点所在圆上的16个像素点进行判断，若判断后的当前中心像素点为暗或亮，将决定其是否为角点。</p>
<ul>
<li>确定一个阈值t，观察某像素点为中心的一个半径为3像素的离散化的圆，该圆边界上有16个像素；</li>
<li>若在这个圆的边界上有n（一般取12）个连续的像素点，它们的像素值比$ I_p + t $大/小，则p就是一个角点。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/fast%E8%A7%92%E7%82%B9.png" alt="fast角点"></p>
<p>特点：</p>
<ul>
<li>时间复杂度小，检测效果好；</li>
<li>不产生多尺度特征，没有方向信息，失去旋转不变性。</li>
</ul>
<h2 id="斑点（二阶导）"><a href="#斑点（二阶导）" class="headerlink" title="斑点（二阶导）"></a>斑点（二阶导）</h2><p>Laplace梯度：<br>    一阶导极值点-&gt;二阶导零点，对噪声敏感</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Laplace%E6%A2%AF%E5%BA%A6.png" alt="Laplace梯度"></p>
<h3 id="高斯拉普拉斯LoG"><a href="#高斯拉普拉斯LoG" class="headerlink" title="高斯拉普拉斯LoG"></a>高斯拉普拉斯LoG</h3><p>Laplacian of Gaussian：先对图像进行高斯卷积滤波($\sigma$小)降噪，再采用Laplace蒜子进行边缘检测(细节)。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/LoG.png" alt="LoG"></p>
<p>LoG -&gt; 极值点 -&gt; 斑点</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/blob.png" alt="blob"></p>
<p>参考：<br><a href="https://blog.csdn.net/Zachary_Co/article/details/78831806" target="_blank" rel="noopener">https://blog.csdn.net/Zachary_Co/article/details/78831806</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>图像特征表示</title>
    <url>/2020/04/13/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="基于关键点的特征描述子"><a href="#基于关键点的特征描述子" class="headerlink" title="基于关键点的特征描述子"></a>基于关键点的特征描述子</h1><h2 id="特征点-关键点-兴趣点"><a href="#特征点-关键点-兴趣点" class="headerlink" title="特征点/关键点/兴趣点"></a>特征点/关键点/兴趣点</h2><p>不同视角图片之间的映射；<br>稳定局部特征点：</p>
<ul>
<li>显著性、可重复性(同一特征有足够相似描述子)；</li>
<li>抗图片变换（外貌：亮度、光照、几何：平移、尺度）</li>
</ul>
<h2 id="SIFT特征：局部特征"><a href="#SIFT特征：局部特征" class="headerlink" title="SIFT特征：局部特征"></a>SIFT特征：局部特征</h2><p>SIFT算法在不同尺度空间(高斯模糊获取)上查找关键点；高斯卷积核是实现尺度变换的唯一变换核，且是唯一的线性核。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>通过对关键点周围图像区域分块，计算块内梯度直方图，生成具有独特性的向量，这个向量是该区域图像信息的一种抽象，具有唯一性。</p>
<ol>
<li><p>在高斯差分DoG空间进行极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于<strong>尺度和旋转不变</strong>的兴趣点。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%9E%81%E5%80%BC%E6%A3%80%E6%B5%8B.png" alt="极值检测"></p>
<ul>
<li>关键点是由DoG空间的局部极值点组成的，关键点的初步探查是通过同一组内各DoG相邻两层图像之间比较完成的。为了寻找DoG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。</li>
<li>中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。最上下两层需在不同组中进行比较。</li>
<li>为了在每组中检测S个尺度的极值点，则DoG金字塔每组需S+2层图像，而DoG金字塔由高斯金字塔相邻两层相减得到，则高斯金字塔每组需S+3层图像，实际计算时S在3到5之间。</li>
<li>在最开始建立高斯金字塔时，要预先模糊输入图像来作为第0个组的第0层的图像，这时相当于丢弃了最高的空域的采样率。因此通常的做法是先将图像的尺度扩大一倍来生成第-1组。</li>
</ul>
</li>
<li><p>关键点定位：在每个候选的位置上，通过一个拟合精细的模型(三维二次函数)来确定位置和尺度。关键点的选择依据于它们的稳定程度。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%85%B3%E9%94%AE%E7%82%B9%E5%AE%9A%E4%BD%8D.png" alt="关键点定位"></p>
<p>为了提高关键点的稳定性，需要对尺度空间DoG函数进行曲线拟合。（泰勒展开式）</p>
<ul>
<li>在新的位置上反复插值直到收敛；也有可能超出所设定的迭代次数或者超出图像边界的范围，删除该点。</li>
<li>距离过小的点易受噪声的干扰而变得不稳定，这样的极值点也应删除。<br>一个定义不好的DoG的极值在横跨边缘的地方有较大的主曲率，而在垂直边缘的方向有较小的主曲率。DoG算子会产生较强的边缘响应，需要剔除不稳定的边缘响应点。主曲率可通过一个$2*2$的Hessian矩阵求出。主曲率值越大，说明两个特征值的比值越大，即在某一个方向的梯度值越大，而在另一个方向的梯度值越小，而边缘恰恰就是这种情况。所以为了剔除边缘响应点，需要让该比值小于一定的阈值。</li>
</ul>
</li>
<li><p>方向确定：<br>基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。最大值方向为主方向，超过最大值80%的方向称为辅方向。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%B8%BB%E6%96%B9%E5%90%91.png" alt="主方向"><br>使用直方图统计邻域内像素的梯度和方向。梯度直方图将$0\thicksim360^{\circ}$的方向范围分为36个柱(bins)，其中每柱10度。直方图的峰值方向代表了关键点的主方向。<br><em>离散的梯度方向直方图要进行插值拟合处理，来求得更精确的方向角度值。</em></p>
<p>所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些<strong>变换的不变性</strong>。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%96%B9%E5%90%91%E4%B8%8D%E5%8F%98%E6%80%A7.png" alt="方向不变性"></p>
</li>
<li><p>关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%85%B3%E9%94%AE%E7%82%B9%E6%8F%8F%E8%BF%B0.png" alt="关键点描述"><br>以特征点为中心取16×16的邻域作为采样窗口，将采样点与特征点的相对方向通过高斯加权后归入包含8个bin的方向直方图，最后获得4×4×8的128维特征描述子。</p>
</li>
</ol>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol>
<li>确定计算描述子所需的图像区域；</li>
<li>将坐标轴旋转为关键点的方向，以确保旋转不变性；</li>
<li>将邻域内的采样点分配到对应的子区域内，将子区域内的梯度值分配到8个方向上，计算其权值；</li>
<li>插值计算每个种子点八个方向的梯度（统计的4*4*8=128个梯度信息即为该关键点的特征向量）；</li>
<li>特征向量形成后，为了去除光照变化的影响，需要对它们进行归一化处理，对于图像灰度值整体漂移，图像各点的梯度是邻域像素相减得到，可去除；</li>
<li>描述子向量门限：非线性光照，相机饱和度变化对造成某些方向的梯度值过大，而对方向的影响微弱。因此设置门限值(向量归一化后，一般取0.2)截断较大的梯度值。然后，再进行一次归一化处理，提高特征的鉴别性。</li>
<li>按特征点的尺度对特征描述向量进行排序。</li>
</ol>
<h3 id="SIFT特征向量的匹配"><a href="#SIFT特征向量的匹配" class="headerlink" title="SIFT特征向量的匹配"></a>SIFT特征向量的匹配</h3><p>当两幅图像的SIFT特征向量生成以后，通过采用关键点特征向量的欧式距离来作为两幅图像中关键点的相似性判定度量。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>具有良好的不变性，其对旋转、尺度缩放、亮度变化保持不变性，对视角变化、仿射变换、噪声也保持一定程度的稳定性；</li>
<li>区分性（Distinctiveness）好，信息量丰富，适用于在海量特征数据库中进行快速、准确的匹配；</li>
<li>多量性，即使少数的几个物体也可以产生大量的SIFT特征向量；</li>
<li>高速性，经优化的SIFT匹配算法甚至可以达到实时的要求；</li>
<li>可扩展性，可以很方便的与其他形式的特征向量进行联合。<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>计算量大；</li>
<li>特征点有时较少；</li>
<li>对边缘光滑的目标无法准确提取特征点。</li>
</ul>
<h2 id="SURF：局部特征"><a href="#SURF：局部特征" class="headerlink" title="SURF：局部特征"></a>SURF：局部特征</h2><p>Herbert等2006年提出的，对SIFT的改进，速度快3倍。</p>
<p>改进：</p>
<ul>
<li>对高斯二阶微分模版进行简化，使卷积平滑操作转换为加减运算；</li>
<li>确定方向时，在圆形区域计算x，y方向的haar小波响应，找到模最大的扇形方向；</li>
</ul>
<ol>
<li>对原图进行变换，使原图每个像素的Hessian矩阵行列式的近似值构成；</li>
<li>高斯平滑-&gt;求二阶导-&gt;求Hessian矩阵；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/haar.png" alt="haar"><br>对于离散像素点，使用haar模版进行卷积。</li>
<li>统计特征点领域内的haar小波特征，以保证旋转不变性；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/surf%E4%B8%BB%E6%96%B9%E5%90%91.png" alt="surf主方向"><br>以特征点为中心，计算半径为6s(s为特征点所在的尺度值)的领域内，<br>统计60度扇形内所有点在x和y方向的haar小波响应总和；<br>该扇形以一定间隔进行旋转，将最大值那个扇形的方向作为该特征点的主方向。</li>
<li>在特征点周围去一个变长为20s的正方形框，该框方向即为检测出来的主方向；</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/surf64d.png" alt="surf64d"><br>SURF特征点特征向量维度为64D，将该框分为16个子区域，每个子区域统计25个像素的水平方向和垂直方向的haar小波特征。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>速度快3倍；</li>
<li>亮度变化效果好；</li>
<li>模糊方面优于SIFT；</li>
<li>尺度不变不及SIFT；</li>
<li>旋转不变与SIFT近似。</li>
</ul>
<p>参考：</p>
<p><a href="https://baike.baidu.com/item/SIFT/1396275?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/SIFT/1396275?fr=aladdin</a><br><a href="https://blog.csdn.net/u010440456/article/details/81483145" target="_blank" rel="noopener">https://blog.csdn.net/u010440456/article/details/81483145</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>图像颜色空间</title>
    <url>/2020/04/25/%E5%9B%BE%E5%83%8F%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h1><h2 id="RGB颜色空间"><a href="#RGB颜色空间" class="headerlink" title="RGB颜色空间"></a>RGB颜色空间</h2><p>三颜色通道：</p>
<ul>
<li>Red通道；</li>
<li>Green通道；</li>
<li>Blue通道。<br>一个像素颜色值为(b,g,r)，取值范围[0,255]或[0.0,1.0]<br>加法混色，用于彩色显示器。</li>
</ul>
<h2 id="CMY-K-颜色空间"><a href="#CMY-K-颜色空间" class="headerlink" title="CMY(K)颜色空间"></a>CMY(K)颜色空间</h2><p>四通道：</p>
<ul>
<li>Cyan通道；</li>
<li>Magenta通道；</li>
<li>Yellow通道；</li>
<li>Key通道。<br>一个像素颜色值为(c,m,y,k)，取值范围[0,255]或[0.0,1.0]<br>减法混色，用于印刷。</li>
</ul>
<h2 id="HSV颜色空间"><a href="#HSV颜色空间" class="headerlink" title="HSV颜色空间"></a>HSV颜色空间</h2><p>三要素：</p>
<ul>
<li>H/Hue：色调，颜色种类；</li>
<li>S/Saturation：饱和度，颜色纯度；</li>
<li>V/Value：明亮度，颜色明亮度。<br>一个像素颜色值为(h,s,v)，取值范围[0,255]或[0.0,1.0]<br>符合人类视觉概念，用于画家调色。</li>
</ul>
<h2 id="CIE-XYZ颜色空间"><a href="#CIE-XYZ颜色空间" class="headerlink" title="CIE-XYZ颜色空间"></a>CIE-XYZ颜色空间</h2><p>基于人类颜色视觉的直接测定，是其他颜色空间的基础。于1931年由国际照明协会定义。</p>
<p>3颜色刺激值通道：</p>
<ul>
<li>X，Y，Z：基本对应R，G，B；</li>
<li>一种波的刺激等于几种波的刺激整合。</li>
</ul>
<p>人类视觉系统（视锥细胞）：</p>
<ul>
<li>短波（S,420-440nm）；</li>
<li>中波（M,530-540nm）；</li>
<li>长波（L,560-580nm）。</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
  </entry>
  <entry>
    <title>多尺度变换</title>
    <url>/2020/04/09/%E5%A4%9A%E5%B0%BA%E5%BA%A6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="空间域处理：卷积"><a href="#空间域处理：卷积" class="headerlink" title="空间域处理：卷积"></a>空间域处理：卷积</h1><h2 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h2><h3 id="直方图（特征提取方法）"><a href="#直方图（特征提取方法）" class="headerlink" title="直方图（特征提取方法）"></a>直方图（特征提取方法）</h3><p>是对图片数据/特征分布的一种统计，对数据区间/空间进行量化。<br><em>全黑为0</em></p>
<a href="/2020/06/06/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/" title="直方图均衡化">直方图均衡化</a>

<h2 id="形态学运算"><a href="#形态学运算" class="headerlink" title="形态学运算"></a>形态学运算</h2><ul>
<li><p>膨胀：图像中高亮部分进行膨胀，类似于领域扩展；</p>
</li>
<li><p>腐蚀：源图像高亮部分被腐蚀，类似于被蚕食。</p>
</li>
<li><p>开运算：先腐蚀再膨胀，可去除目标外的孤立点；</p>
</li>
<li><p>闭运算：先膨胀再腐蚀，可去除目标内的孔。</p>
</li>
</ul>
<h2 id="临域运算"><a href="#临域运算" class="headerlink" title="临域运算"></a>临域运算</h2><h3 id="滤波-卷积"><a href="#滤波-卷积" class="headerlink" title="滤波/卷积"></a>滤波/卷积</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8D%B7%E7%A7%AF.gif" alt="卷积"><br>使用模版，对源图像中的每个位置进行卷积计算，按照一定步长进行滑动，可进行padding填充。</p>
<p>padding边界填充策略：</p>
<ul>
<li>zero-padding补零；</li>
<li>replication边界复制；</li>
<li>reflection镜像；</li>
<li>wraparound块复制。</li>
</ul>
<h4 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h4><ul>
<li>计算卷积内的像素值</li>
<li>取平均值作为卷积输出。</li>
</ul>
<p>既没有很好的去除噪声点，也破坏了图像的细节，使图像变得模糊。</p>
<h4 id="平滑中值滤波"><a href="#平滑中值滤波" class="headerlink" title="平滑中值滤波"></a>平滑中值滤波</h4><ul>
<li>卷积内的像素值从小到达排序；</li>
<li>取中间值作为卷积输出。</li>
</ul>
<p>可有效去除椒盐噪声(黑白点)。</p>
<h4 id="平滑高斯滤波"><a href="#平滑高斯滤波" class="headerlink" title="平滑高斯滤波"></a>平滑高斯滤波</h4><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2.png" alt="高斯滤波"><br>$$ G_{\sigma}=\frac{1}{2\Pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}} $$<br>$ \sigma $ 越小，关注区域越集中。</p>
<p>可有效去除高斯噪声，模拟人眼，关注于中心区域。</p>
<p><strong>分解特性/级联高斯</strong><br>将2D卷积拆分成两个1D卷积，可提高计算效率。</p>
<h4 id="梯度Prewitt滤波-卷积"><a href="#梯度Prewitt滤波-卷积" class="headerlink" title="梯度Prewitt滤波/卷积"></a>梯度Prewitt滤波/卷积</h4><ul>
<li>水平梯度/垂直边缘：$ [-1,0,1] * {[1,1,1]}^T $</li>
<li>垂直梯度/水平边缘：$ [1,1,1] * {[-1,0,1]}^T $</li>
</ul>
<h4 id="梯度Sobel滤波-卷积"><a href="#梯度Sobel滤波-卷积" class="headerlink" title="梯度Sobel滤波/卷积"></a>梯度Sobel滤波/卷积</h4><ul>
<li>水平梯度/垂直边缘：$ [-1,0,1] * {[1,2,1]}^T $</li>
<li>垂直梯度/水平边缘：$ [1,2,1] * {[-1,0,1]}^T $</li>
</ul>
<h4 id="梯度Laplacian滤波-卷积"><a href="#梯度Laplacian滤波-卷积" class="headerlink" title="梯度Laplacian滤波/卷积"></a>梯度Laplacian滤波/卷积</h4><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A2%AF%E5%BA%A6Laplacian%E6%BB%A4%E6%B3%A2.png" alt="梯度Laplacian滤波"></p>
<ul>
<li>使用二阶微分蒜子；</li>
<li>团块检测：周边高于/低于中心点；</li>
<li>边缘检测：像素值快速变化的区域。</li>
</ul>
<h3 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h3><a href="/2020/05/14/%E9%87%91%E5%AD%97%E5%A1%94%E5%8F%98%E6%8D%A2/" title="金字塔变换">金字塔变换</a>

<hr>
<h1 id="频率域处理-提高卷积效率-：乘法"><a href="#频率域处理-提高卷积效率-：乘法" class="headerlink" title="频率域处理(提高卷积效率)：乘法"></a>频率域处理(提高卷积效率)：乘法</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2.png" alt="傅立叶变换"></p>
<p>一个信号可由足够多个不同频率和幅值的正余弦波组成。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BF%A1%E5%8F%B7%E5%88%86%E8%A7%A3.png" alt="信号分解"></p>
<h2 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a>傅立叶变换</h2><p>一系列符合欧拉公式$e^{ix} = \cos{x} + i\sin{x}$的点的运动叠加。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E6%AC%A7%E6%8B%89%E5%8F%A0%E5%8A%A0.png" alt="傅立叶变换欧拉叠加"></p>
<p>矩形波/傅立叶逆变换：$f(t)=\frac{1}{2\Pi} \int_{-\infty}^{\infty} F(\omega)e^{i \omega t}d{\omega}$</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%9F%A9%E5%BD%A2%E6%B3%A2.png" alt="矩形波"></p>
<table>
<thead>
<tr>
<th align="center">傅立叶</th>
<th align="center">公式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">连续傅立叶变换</td>
<td align="center">$$H(\omega)= \int_{-\infty}^{\infty} h(x)e^{-j \omega x} d{x} = \int_{-\infty}^{\infty} h(x)[\cos{x} - {j\omega}\sin{x}] d{x}$$</td>
</tr>
<tr>
<td align="center">离散傅立叶变换</td>
<td align="center">$$X(\omega)=\sum_{-\infty}^{\infty}x_n e^{-i \omega n}$$</td>
</tr>
<tr>
<td align="center">二维离散傅立叶变换</td>
<td align="center">$$F(u,v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x,y)e^{-j2\Pi(\frac{ux}{M} = \frac{vy}{N})}$$</td>
</tr>
</tbody></table>
<p><strong>低通滤波器获取图像的概貌</strong>，去除了图像的高频部分/细节信息，如中值滤波。<br><strong>高通滤波获取图像的边缘信息</strong>，如拉普拉斯滤波。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%BB%A4%E6%B3%A2.png" alt="滤波"></p>
<h3 id="基于傅立叶变换的滤波"><a href="#基于傅立叶变换的滤波" class="headerlink" title="基于傅立叶变换的滤波"></a>基于傅立叶变换的滤波</h3><p>傅里叶变换处理非平稳信号有天生缺陷，它只能获取一段信号总体上包含哪些频率的成分，但是对各成分出现的时刻并无所知。因此时域相差很大的两个信号，可能频谱图一样。</p>
<h4 id="相位滤波"><a href="#相位滤波" class="headerlink" title="相位滤波"></a>相位滤波</h4><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%9B%B8%E4%BD%8D%E6%BB%A4%E6%B3%A2.png" alt="相位滤波"></p>
<h4 id="频谱滤波"><a href="#频谱滤波" class="headerlink" title="频谱滤波"></a>频谱滤波</h4><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%A2%91%E8%B0%B1%E6%BB%A4%E6%B3%A2.png" alt="频谱滤波"></p>
<h3 id="短时傅立叶变换STFT"><a href="#短时傅立叶变换STFT" class="headerlink" title="短时傅立叶变换STFT"></a>短时傅立叶变换STFT</h3><p>对傅立叶变换添加窗格（添加时域信息），默认窗格内的信号是平稳的。<br>对窗格内的信号分段进行傅立叶变换，但窗格大小难以设置。</p>
<p>特点：</p>
<ul>
<li>窄窗口时间分辨率高、频率分辨率低；</li>
<li>宽窗口时间分辨率低、频率分辨率高；</li>
<li>对时变的非稳态信号，高频适合小窗口，低频适合大窗口；</li>
<li>STFT窗口固定。</li>
</ul>
<p><em>绝对意义的瞬时频率其实是不存在的，只是时间分辨率有限的近似分析结果。</em></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a href="/2020/06/06/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/" title="小波变换">小波变换</a></h2><p>reference:<br><a href="https://blog.csdn.net/asd20172016/article/details/80904634" target="_blank" rel="noopener">https://blog.csdn.net/asd20172016/article/details/80904634</a><br><a href="https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html</a><br><a href="https://zhuanlan.zhihu.com/p/23607336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23607336</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>多尺度变换</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2020/07/01/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="深度优先遍历DFS"><a href="#深度优先遍历DFS" class="headerlink" title="深度优先遍历DFS"></a>深度优先遍历DFS</h1><p>思想：</p>
<ol>
<li>找一个未被访问过的顶点作为起始顶点，沿着当前顶点的边走到未访问过的顶点；</li>
<li>当没有找到未访问过的结点时，回到上一个顶点，继续寻找未访问结点；</li>
<li>直到所有顶点都被访问。</li>
</ol>
<h1 id="广度优先遍历BFS"><a href="#广度优先遍历BFS" class="headerlink" title="广度优先遍历BFS"></a>广度优先遍历BFS</h1><p>思想：类似于树的层次遍历</p>
<ol>
<li>找一个未被访问过的顶点作为起始顶点；</li>
<li>找到顶点的所有的邻接点，放入队列中；</li>
<li>从队列中依次取出结点，查找该结点的所有未被访问过的邻接点，存放到队列中；</li>
<li>直到队列为空。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>小波变换</title>
    <url>/2020/06/06/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="连续小波变换CWT"><a href="#连续小波变换CWT" class="headerlink" title="连续小波变换CWT"></a>连续小波变换CWT</h1><p>将无限长的三角函数基转换为有限长的会衰减的小波基，不仅能获取频率，还可定位到时间。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2.png" alt="小波变换"></p>
<p>思路：</p>
<ol>
<li>取一个小波，将其与原始信号的开始一节进行比较；</li>
<li>计算数值F，F表示小波与所取一节信号的相似程度，计算结果取决于所选小波的形状；</li>
<li>向右移动小波，重复步骤1和步骤2，直至覆盖整个信号；</li>
<li>伸展小波，重复步骤1-3，对齐；</li>
<li>对于所有缩放，重复步骤1-4，进行压缩。</li>
</ol>
<h1 id="离散小波变换DWT"><a href="#离散小波变换DWT" class="headerlink" title="离散小波变换DWT"></a>离散小波变换DWT</h1><p>离散小波变换的有效方法是使用滤波器，由Mallat于1988年提出。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%9A%E5%B1%82%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E5%92%8C%E9%87%8D%E6%9E%84.png" alt="多层小波分解和重构"></p>
<h2 id="小波分解"><a href="#小波分解" class="headerlink" title="小波分解"></a>小波分解</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="离散小波分解示意图"></p>
<p>S表示原始的输入信号，通过两个互补的滤波器组，一个低通滤波器，得到信号的近似值A，另一个高通滤波器，得到该滤波器的细节值D。</p>
<h2 id="小波重构"><a href="#小波重构" class="headerlink" title="小波重构"></a>小波重构</h2><p>利用小波分解的系数还原出原始信号，也叫逆离散小波变换IDWT/小波合成。</p>
<h1 id="二维离散小波变换"><a href="#二维离散小波变换" class="headerlink" title="二维离散小波变换"></a>二维离散小波变换</h1><p>将二维信号在不同尺度进行分解，得到原始信号的近似值和细节。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BA%8C%E7%BB%B4%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E5%92%8C%E9%87%8D%E6%9E%84.png" alt="二维小波分解和重构"></p>
<p>分解的结果为**近似分量cA、水平细节分量cH、垂直细节分量cV、对角细节分量cD。</p>
<h1 id="常见小波函数"><a href="#常见小波函数" class="headerlink" title="常见小波函数"></a>常见小波函数</h1><p>Haar系列，Daubechies系列，Moret系列，Sym系列，Meyer系列，Coif系列</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%B3%A2%E5%87%BD%E6%95%B0.png" alt="常用小波函数"></p>
<p>参考：<br><a href="https://www.cnblogs.com/keye/p/7809207.html" target="_blank" rel="noopener">https://www.cnblogs.com/keye/p/7809207.html</a><br><a href="https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>多尺度变换</tag>
      </tags>
  </entry>
  <entry>
    <title>局部二值LBP</title>
    <url>/2020/06/04/%E5%B1%80%E9%83%A8%E4%BA%8C%E5%80%BCLBP/</url>
    <content><![CDATA[<h1 id="LBP-局部二值模式"><a href="#LBP-局部二值模式" class="headerlink" title="LBP-局部二值模式"></a>LBP-局部二值模式</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/lbp.png" alt="lbp"></p>
<ol>
<li>将每个像素点与周围点大小比较：<ul>
<li>半径为R的圆，均匀采样P个点；</li>
<li>大小量化为0或1.</li>
</ul>
</li>
<li>多个bit组成一个书，统计每个数的直方图。</li>
</ol>
<p>解决旋转不变性：</p>
<ul>
<li>将LBP周围的二进制码按位旋转，取二进制码最小的值为最终LBP值。</li>
</ul>
<h1 id="Extended-LBP-Circular-LBP"><a href="#Extended-LBP-Circular-LBP" class="headerlink" title="Extended LBP/Circular LBP"></a>Extended LBP/Circular LBP</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/ExtendedLBP.png" alt="ExtendedLBP"></p>
<p>将3*3邻域扩展到任意领域，并用圆形领域代替正方形领域。</p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>常识</title>
    <url>/2020/03/16/%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h1 id="常见缩写"><a href="#常见缩写" class="headerlink" title="常见缩写"></a>常见缩写</h1><table>
<thead>
<tr>
<th align="center">缩写</th>
<th align="center">全称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i.e.</td>
<td align="center"></td>
<td>即，也就是说</td>
</tr>
<tr>
<td align="center">e.g.</td>
<td align="center"></td>
<td>例如，举个例子</td>
</tr>
<tr>
<td align="center">etc.</td>
<td align="center"></td>
<td>等，等等</td>
</tr>
<tr>
<td align="center">s.t.</td>
<td align="center">subject to</td>
<td>使满足。。。条件</td>
</tr>
<tr>
<td align="center">arg min</td>
<td align="center">Argument  of a complex number</td>
<td>元素变元</td>
</tr>
<tr>
<td align="center">row</td>
<td align="center"></td>
<td>行</td>
</tr>
<tr>
<td align="center">col</td>
<td align="center"></td>
<td>列</td>
</tr>
<tr>
<td align="center">sqrt</td>
<td align="center"></td>
<td>求平方根</td>
</tr>
<tr>
<td align="center">floor</td>
<td align="center"></td>
<td>向上取整</td>
</tr>
<tr>
<td align="center">ceil</td>
<td align="center"></td>
<td>四舍五入</td>
</tr>
<tr>
<td align="center">mod</td>
<td align="center"></td>
<td>做除法</td>
</tr>
</tbody></table>
<hr>
<h1 id="公司职称"><a href="#公司职称" class="headerlink" title="公司职称"></a>公司职称</h1><h2 id="决策级"><a href="#决策级" class="headerlink" title="决策级"></a>决策级</h2><table>
<thead>
<tr>
<th align="center">称谓</th>
<th align="center">英文</th>
<th align="center">缩写</th>
<th align="center">主要工作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">董事会</td>
<td align="center">board of directors</td>
<td align="center"></td>
<td align="center">制定政策</td>
</tr>
<tr>
<td align="center">董事会主席/董事长</td>
<td align="center">chairman of the board</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">首席执行官/总经理</td>
<td align="center">chief executive officer</td>
<td align="center">CEO</td>
<td align="center">行政级别最高领导人，负责公司重大执行权</td>
</tr>
<tr>
<td align="center">总裁</td>
<td align="center">president</td>
<td align="center"></td>
<td align="center">主要负责公司日常执行权</td>
</tr>
</tbody></table>
<h2 id="管理级"><a href="#管理级" class="headerlink" title="管理级"></a>管理级</h2><table>
<thead>
<tr>
<th>称谓</th>
<th>缩写</th>
<th>主要工作</th>
</tr>
</thead>
<tbody><tr>
<td>首席运营官</td>
<td>COO</td>
<td>负责公司管理</td>
</tr>
<tr>
<td>首席技术官</td>
<td>CTO</td>
<td>负责公司技术</td>
</tr>
<tr>
<td>首席财务官</td>
<td>CFO</td>
<td>管理公司财务</td>
</tr>
</tbody></table>
<h2 id="部门管理级"><a href="#部门管理级" class="headerlink" title="部门管理级"></a>部门管理级</h2><table>
<thead>
<tr>
<th align="center">称谓</th>
<th align="center">主要工作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">总监</td>
<td align="center">某项领域高级管理人员</td>
</tr>
<tr>
<td align="center">项目经理</td>
<td align="center">公司的日常经营管理和行政事务的负责人</td>
</tr>
<tr>
<td align="center">主管</td>
<td align="center">主持管理某种专门事务的的人员</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
  </entry>
  <entry>
    <title>我与世界只差一个你</title>
    <url>/2020/03/09/%E6%88%91%E4%B8%8E%E4%B8%96%E7%95%8C%E5%8F%AA%E5%B7%AE%E4%B8%80%E4%B8%AA%E4%BD%A0/</url>
    <content><![CDATA[<blockquote><p>世界说大很大，说小很小。大到走了那么久，还没跟对的人相遇，小到围着喜欢的人绕了一圈，就看到了全世界。</p>
<p>愿你能因为某个人的出现而让世界丰盈，愿你的生活如同贺卡上烫金的祝辞欢脱，愿这悠长岁月温柔安好，有回忆煮酒，愿你没有软肋，也不需要铠甲，愿我们和爱的人一起浪费人生，热泪盈框，长生不老。我与世界只差一个你，因为是你，晚一点没关系。</p>
<p>一个有了女朋友的人就不应该再出去混局了，女人如衣服，兄弟如手足，那是古人说的话，不给你衣服穿，你还有脸出门吗。</p>
<p>你先闭嘴，我说咱能不那么作么，有时间列那么多不平等条约，好好让脑袋多装点实在东西吧，别把矫情当优点，长那么低调活得这么得瑟，以为全天下都欠着你呀。人一大好青年，被你训得话都说不出一句，这么个谈恋爱法，智商是往负250上靠吗，中情局怎么没抓你啊！</p>
<p>你的过去怎样我不想知道，你的未来如何我也不想参与。你难道一点都看不出来我不想理你吗？你还犯着贱得把脸贴过来。干吗，我屁股上装了一整个南极你感觉不到冷啊。</p>
<p>银行司机兼保镖，行动人形立牌，抗压人肉沙包</p>
<p>她不是霸道，只是有主见；她不是强势，只是给自己安全感；她不是神勇铁金刚，那点脾气只是用来掩饰她心底的脆弱罢了。如果你懂她，就该让她去决定她能决定的，放弃她可以放弃的，在她有所期待的时候不要让她失望，在她脆弱的时候扶她一把，在她每次说她很好的时候就别真的离开了，就该知道她能一直欺负你霸占你所有的时间，是因为她爱你！</p>
<p>要有多幸运，两个人才能健康无事地执手偕老。平行时空里，飞机上的人都回了家，自此谁都别忘了，能拥抱到身边的人才是最奢侈的事。</p>
<p>一百个人，有一百个对爱情的态度。我们谁都会受伤，也都会在爱里成熟，不依赖天长地久的承诺，不抱有唯我独尊的自负，在一百次冲动之前，看看自己在这段感情里的收获，别轻易觉得爱可弃，心可医，一个人能行。最好能记着，别人给的爱，都是无辜的。</p>
<footer><strong>随手转发正能量</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>我送了你那么多的巧克力，你都给我退回来了，就跟数学最后一道选择题我辛辛苦苦算了好几页草稿纸，结果ABCD里都没有我要的答案。我喜欢你这么久，明知道是死路，也还是硬着头皮走，马上就要毕业了，我觉得如果不再争取一下久永远失去你了。</p>
<p>有时我会想，我们明明是见面就互掐，特别见不得彼此好的人啊，但为什么现在会有种期待感呢，我好期待我骂你一句后你会回什么，期待我们再比一项东西我输给你后你那得意洋洋的样子，期待你今天会走哪条路，校服里面会穿哪件衣服。慢慢地，我就想迫不及待在人群里找到你，但后来我发现，不用找，我一眼就能看到你。</p>
<p>每个人的青春其实都是一本精彩的书，残酷的，悲伤的，幸运的，幸福的，要说尽其中的遗憾，怎么能用几句话说得清。只是那时的我们啊，以为只要对饮一杯酒，一起吃一碗三块钱的面，就可以永远。后来才发现，时间是永恒的敌人，永远跟有没有勇气没关系，跟牵了多久的手也没有关系，它能给人无穷尽的生命，也能给两个人最长的距离，能让你忘记所有快乐的细节，却偏偏记得痛是多么的苦骨铭心。</p>
<p>我们一起追过的剧里，江直树是真的爱着袁湘琴，李大仁是真的爱着程又青，志明是真的爱着春娇。但你别忘了，那时的我，是真的爱着你。</p>
<footer><strong>念念 相忘</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>人一生会遇到约2920万人，两个人相爱的概率是0.000049，所以你不爱我，我不怪你。</p>
<p>爱一个人的时候，多巴胺分泌旺盛，我们都会不自觉地把对方完美化，但最后真正在一起了，就会发现对方身上漏洞百出，累感不爱。择偶靠来电，但恋爱，必须要靠信任。</p>
<p>看着光影里的…，卸下那一身精致后，留下的跟凡人一样的血肉，冷的时候需要人为她添一件衣服，热了要人牵着她冲进灌满冷气的商场，她一个人那么久，其实根本不行。</p>
<p>从喜欢到愿意共同面对生活还是有很长的一段距离的。我们的生活，需要为五斗米折腰，灾难频现，要经得起时间考验，还不能放任自流，随时要踩死一只只小强以及小三小四小五，明明那么辛苦，最后，你还得说一句，爱情该走下神坛，要走向最普通的生活。确实，当你神经百战之后，再经历这些，就会觉得太微不足道了，这些连年征战就是你的油盐酱醋茶。</p>
<p>我的身旁总有健，我的回忆里也总是他的身影，而他的温柔总像无意间在哪绕了点路，要稍稍慢一拍才回传达给我，如今的我才能慢慢察觉到那份笨拙的温柔，当时的自己总是无法那么坦率，害怕被伤害而没能坚持到最后的人，是我；没能相信他的温柔就中途放弃的人，是我；决定单方面闭上眼睛就不再回头的人，是我；他一直在认真的投球，没能好好接住的人，是我。</p>
<p>别轻易弄丢那个最适合你的人，后悔了？别怕，反正爱啊，总是有遗憾，干了这杯，无醉不欢。</p>
<p>现实无法倒流，没那么多机会给你重来。</p>
<footer><strong>无醉 不欢</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>处女龟毛男：形容斤斤计较、做事拖泥带水的人。一般处女座、摩羯座居多。</p>
<p>平时见不到面的时候迟迟不回我信息，跟他见面了却能一直玩弄手机，都说人在爱情里智商为零，但他却很清醒，知道承诺就是嘴上功夫，不用去兑现的，他也知道什么时候该热情什么时候该冷静。我又不傻，男人就两样东西给你，钱给不了，那就给时间，时间都不给，那就是不爱啊，我有心理准备的。</p>
<p>这个吻，是我每天工作的一部分。感情用事是种心理缺陷，所谓粉丝，不过是指望着别人幸福来意淫自己的美好生活。</p>
<p>Tony在糖糖面前彻底现了原形，他并不是暖男，而是彻头彻尾的渣男，全身注满了人前一套背后一套的负能量，嘴上说不在意网上的恶意评论，但背地里刷着微博骂人家全家。</p>
<p>从Tony参加选秀比赛出道，顾涛就一直带着他，八年来，看着他从一个默默无闻的新人到现在成了别人眼里的风景，两个人一起受过欺负排挤，吃过常人没吃过的苦，睡过清贫的小房子，最苦时抱头痛哭过，也因为一部戏爆红而酩酊大醉过。所以他自负，他知道；他心机满腹，他知道；他要强，他也知道；他害怕失败，他更知道。Tony最红的时候说过不会亏待他，但每年只送他一部最新的iPhone，顾涛从没在Tony身上赚过什么大钱，也没跟他提过任何需求，拿着经纪公司给的薪水，在所有人都以为一人得道、鸡犬升天的时候，却靠着老母亲留下的房子维持着普通人的生活。</p>
<p>如若最后遇到下像是黑夜中静谧的星空，那当初跋涉的这一路，崴脚的石子，走过冒失的风雪，在此刻都成了过眼烟云。夜风徐徐，望着那片星空，心里有一个可以想念的人。–《唐顿庄园》有感</p>
<footer><strong>Ctrl + Alt + Del</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>如果真的为了一个人撕心裂肺哭过一次，那么那个人就会从至关重要的人变成可有可无的人，因为那个人能把自己伤害到那个样子的机会只有一次。那一次之后，即使自己还爱他，可是总有一些东西真的改变了。</p>
<p>毕业如一场告别的宴席，几杯酒下肚后就各自回家了，留在桌上的是彼此要做一辈子好朋友的誓言，带走的是我们终会把各自遗忘然后再去遇见别人的明天。</p>
<p>世界上每天都有许多爱情故事发生，或遗憾，或悲伤，或幸福，或虚假，每个善男信女向空中抛出“我想爱”的信号，撞上了一些人，避开了一些人，经历了抛物线最高的高点，也落回最初的原点。当故事要结局的时候，才发现过去那些所谓遇见分离，最后都会化为平淡，再轰轰烈烈的我爱你你爱我，归根结底，都会落入平淡。</p>
<p>我觉得我不是喜欢你，而是习惯有你；我觉得我不是失去了你，而是失去了最好的青春。</p>
<footer><strong>没在一起 挺好的</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<p><code>Drama Queen 作做女王</code></p>
<blockquote><p>现代男人的焦虑与恐慌，在工作繁重收入高的人群中尤为常见，他们除非遇上自己称心如意的人，否则绝不轻易谈恋爱，若是碰上一个情商爆表的成熟女性，那就分分钟闪婚，最怕的就是遇上胸大无脑，脸美但吵的Drama queen ，要是不小心掉入她们的桃花阵，势必没有富足的时间制造浪漫逗她们开心。</p>
<p>老板在公司是出了名的辛辣刁钻，没人能逃得过她温婉笑容下的锋利匕首，特别擅用全世界通用逼死人不偿命的沟通黄金二字——呵呵——让你体无完肤。</p>
<p>一个女人喜欢你，其实不在乎你们去了哪，做了什么，而是跟你在一起的时候，你有没有让她觉得，你是在乎她的。</p>
<p>最好的浪漫，就是平淡的相处。你知道对方就在那里，很踏实，所有的时间都得以安放，像是忘记你们正在谈恋爱。</p>
<p>就像是本来生活里所有地方都充斥着的回忆，突然之间跟你一点关系都没有了，曾经一同走过的地方、一度养成的习惯，全变成了伤疤，一碰就疼，此前天地都不怕，现在最怕回忆翻滚。</p>
<p>冬天赖床的时候，明明已经醒了，也知道不能再睡了，但还是舍不得温暖的被窝，那时觉得没关系，就再睡一下吧，因为你知道，你总会起床的。</p>
<p>多希望现在认识你，而不是当初，我不知道你有没有真心喜欢过我，但没关系，因为我爱上你了。<br>在爱情面前，我们都不是好人，不然我怎么会允许你就这样从我身边离开，而我也不敢在你背后大声叫住你，“请再看我一眼，再抱我一次。”纵使此生我们都不会再见面，但我仍希望你过得好，至少比我好，不然我会不开心。</p>
<p>那个时候我们都以为爱是你喜欢我，我喜欢你，以为爱是我所希望的就是你所希望的，希望爱是两人份的炸鸡，是一个香喷喷的屁，是被手肘压住的长发，是开在土地里卑微的花，后来才知道，爱是金风玉露一相逢，便胜却人间无数，是相看两不厌，以陪伴互为终点；爱是舒服的沉默，是和有趣的人一起浪费人生，是灵魂伴侣，是原来你也在这里。</p>
<footer><strong>还好最后是 你</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>这个世界上的爱情分为多种，一种是心灵伴侣，靠一碗鸡汤秉承爱就是不见也不散；一种是卑微如尘，对方给你一巴掌，你还会关心Ta手为什么这么凉；另一种是彼此折磨，两个人像周瑜打黄盖，一个愿打一个愿挨；还有一种是无间道宫心计，互相猜，好像瞅准了看谁先出轨似的；最后一种，是心照不宣的暧昧，就像电影里说，你想和她上床，她也想和你上床，你们都知道总有一天你们会上床，但不知道你们会在哪一天上床，这就是最好的时光。</p>
<p>她在不同男人面前变成不同的女人，遇到保护欲强的，就二十四小时装脆弱，看3D《泰坦尼克》哭，看3D《史瑞克》哭；遇到动漫爱好者，就穿着女仆装约会，一、二次元无障碍转换；遇到霸道总裁，就每天娇滴滴被阵风都能吹跑；遇到花心男，就成了耐追的绿茶婊；遇到色胚，就把自己捆好放床上。</p>
<p>有些人沦为平庸浅薄，金玉其外，而败絮其中。可不经意间，有一天你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。</p>
<p>人嘛，就是要在关键时刻不要脸，我们平时就是乖太久，才会在爱降临的时候，按部就班，像是经不起一点委屈的温顺兔子，被鸡汤洗脑，高喊着要在爱里活出自己的口号，一遇到刁难就折腰。其实在爱面前，我们什么都不是，我们并没有想象的那么伟大，清风能醉人，尘埃能致命。既然如此，不如彻底放肆，破坏规则，最是青春留不住，青春也不须留。</p>
<p>这个世界从不缺好的故事，故事的结局，静香没有嫁给大雄，晴子可能也就负责打开樱木花道的初恋大门，有人曾牵手，但不会到最后。就像刚好在赶不同的列车，可能就与缘分失之交臂，抑或是原本以为能长久同行的人，结果提前下了车，看似遗憾，但人生海海，总要允许有人错过你，才能赶上最好的相遇。</p>
<p>我们谁都会受伤，也都会在爱里成熟，不依赖天长地久的承诺，不抱有唯我独尊的自负。<br>在一百次冲动之前，看看自己在这段感情里的收获，别轻易觉得爱可弃，心可医，一个人能行。</p>
<p>时间是永恒的敌人，永远跟有没有勇气没关系，跟牵了多久的手也没有关系，它能给人无穷尽的生命，也能给两个人最长的距离，能让你忘记所有快乐的细节，却偏偏记得痛是多么刻骨铭心。</p>
<footer><strong>和你赶上最好的相遇</strong><cite>张皓宸</cite></footer></blockquote>]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/03/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>稳定性：</p>
<ul>
<li>稳定：对于关键字相等的记录，排序后的序列和排序前的序列顺序相同；</li>
<li>不稳定：对于关键字相等的记录，排序后的序列和排序前的序列顺序不一定相同。</li>
</ul>
<h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><p><em>待排序记录存放在计算机存储器中进行的排序过程</em></p>
<table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">时间复杂度</th>
<th align="center">最好时间复杂度</th>
<th align="center">最坏时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">直接插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O({log}_2^n)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">简单选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">二路归并排序</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n{log}_2^n)$</td>
<td align="center">$O(n)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<ol>
<li>冒泡排序<ol>
<li>比较<code>第一个记录的关键字</code>和<code>第二个记录的关键字</code>；</li>
<li>若为逆序，则将两个记录进行交换；</li>
<li>然后比较<code>第二个记录的关键字</code>和<code>第三个记录的关键字</code>，依次遍历到最后一个记录的关键字；</li>
<li>第一趟”起泡排序”，关键字最大的记录被安置到最后位置；</li>
<li>进行第二趟起泡排序，排除最后一个，只比较<strong>前n-1</strong>个数；</li>
<li>直到”<strong>某一趟排序中没有进行过交换记录</strong>“ 。</li>
</ol>
</li>
<li>插入排序：一般默认为直接插入排序<ol>
<li>直接插入排序<ol>
<li>将<code>第一个记录的关键字</code>作为有序数组，剩余其它为无序数组；</li>
<li>依次从无序数组中取出<code>任一个记录的关键字(默认第一个位置)</code>插入到有序数组中；</li>
<li>若有序数组中的当前元素大于🆕元素，将有序数组中的元素后移一个位置；</li>
<li>重复步骤3，直到找到有序数组中的元素不大于(小于或等于)🆕元素的位置；</li>
<li>将🆕元素插入到该位置；</li>
<li>重复步骤2-5，直到无序数组中没有元素为止。</li>
</ol>
</li>
<li>折半插入排序</li>
<li>2路插入排序</li>
<li>希尔排序/缩小增量排序：将记录按一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多；当增量为1时终止。<ol>
<li>选择一个增量序列$t_1,t_2,…t_i,…,t_j,…t_k$，其中$t_i &gt; t_j$，$t_k = 1$；</li>
<li>按增量序列个数k，对序列进行k趟排序；</li>
<li>每趟排序，根据对应的增量$t_i$，将待排序分割成若干长度为m的子序列，分别对各子序列进行直接插入排序。</li>
</ol>
</li>
</ol>
</li>
<li>快速排序：采用<strong>分治法</strong>，通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分小，继续对这两部分进行排序，以达到整个序列有序。<ol>
<li>从数组中挑选一个元素(默认选择第一个)作为<code>基准pivot</code>；</li>
<li>重新排列数组，所有比pivot小的放在其前面，所有比pivot大的放在其后面；</li>
<li>步骤2可使用双向指针遍历，操作完成后，pivot位于数列的中间位置，称为分区操作partition；</li>
<li>递归将小于和大于pivot的子序列进行排序。</li>
</ol>
</li>
<li>选择排序：一般默认为简单选择排序<ol>
<li>简单选择排序<ol>
<li>比较<code>第二个记录的关键字</code>和<code>第一个记录的关键字</code>；</li>
<li>若为逆序，则将两个记录进行交换；（此处选择最小值）</li>
<li>然后比较<code>第三个记录的关键字</code>和<code>第一个记录的关键字</code>，直到最后一个记录的关键字；</li>
<li>第一趟排序后，关键字最小的记录被安置到第一个位置；</li>
<li>进行第二趟排序，排除第一个位置，只比较<code>后n-1</code>个数；</li>
<li>直到最后一轮比较。</li>
</ol>
</li>
<li>树形选择排序</li>
<li>堆排序(优先队列的一种实现)：堆积一个近似完全二叉树的结构，且子结点的键值或索引总是小于或大于它的父结点。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"><ol>
<li>将初始待排序关键字序列$R_1,R_2,…,R_n$构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素$R_1$和最后一个元素$R_n$交换，此时得到新的无序区$R_1,R_2,…,R_{n-1}$和新的有序区$R_n$，且满足$R[1,2,…,n-1]&lt;=R[n]$;</li>
<li>由于交换后新的堆顶$R_1$可能违反堆的性质，因此需要对当前无序区$R_1,R_2,…,R_{n-1}$调整为新堆；</li>
<li>然后再次将$R_1$和无序区最后一个元素交换，得到新的无序区$R_1,R_2,…,R_{n-2}$和新的有序区$R_{n-1},R_n$；</li>
<li>不断重复步骤3-4，直到有序区的元素个数为n-1。<br>补充：<ul>
<li>大顶堆：每个结点的值都大于或等于其左右孩子结点的值；</li>
<li>小顶堆：每个结点的值都小于或等于其左右孩子结点的值。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>归并排序：采用<strong>分治法</strong>，将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序。<ol>
<li>二路归并排序<ol>
<li>将长度为n的输入序列分为两个长度为n/2的子序列；</li>
<li>分别对这两个子序列进行归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列；</li>
</ol>
</li>
<li>多路归并排序</li>
</ol>
</li>
</ol>
<p>—以下为<strong>非比较排序</strong>算法—</p>
<ol start="6">
<li>计数排序：将输入的数据值转为键存储在额外开辟的数组空间中。<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加；</li>
<li>反向填充目标数组，根据计数累加和，每填充一次计数减1。</li>
</ol>
</li>
<li>桶排序：计数排序的升级版，利用了函数的映射关系；假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序。<ol>
<li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值，<strong>数值有限、容量不限</strong>；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序，可以使用其它排序方法，也可递归使用桶排序(当桶数量为1时可能会陷入死循环)；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
</li>
<li>基数排序：先按低位排序，然后收集；再按高位排序，然后收集；直到最高位。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"><ol>
<li>取得数组中的最大数，并取得<strong>位数</strong>；</li>
<li>从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序。</li>
</ol>
</li>
</ol>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p><em>待排序记录的数量大，内存不能一次容纳全部记录</em></p>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://blog.csdn.net/weixin_41190227/article/details/86600821" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41190227/article/details/86600821</a></li>
<li><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></li>
<li><a href="https://www.cnblogs.com/lanhaicode/p/10546257.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanhaicode/p/10546257.html</a></li>
<li><a href="https://www.cnblogs.com/dslx/p/10555311.html" target="_blank" rel="noopener">https://www.cnblogs.com/dslx/p/10555311.html</a></li>
<li><a href="https://www.cnblogs.com/luomeng/p/10618709.html" target="_blank" rel="noopener">https://www.cnblogs.com/luomeng/p/10618709.html</a></li>
<li><a href="https://www.cnblogs.com/luomeng/p/10639926.html" target="_blank" rel="noopener">https://www.cnblogs.com/luomeng/p/10639926.html</a></li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数学公式</title>
    <url>/2020/04/25/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>$e^{ix} = cos{x} + isin{x}$</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F.png" alt="欧拉公式"></p>
<h1 id="链式求导法则"><a href="#链式求导法则" class="headerlink" title="链式求导法则"></a>链式求导法则</h1><p>$$(f(g(x)))’ = f’(g(x)) g’(x)$$</p>
<p>或</p>
<p>$$\frac{dy}{dx} = \frac{dy}{dz} \cdot \frac{dz}{dx}$$</p>
<h1 id="极大似然估计MLE"><a href="#极大似然估计MLE" class="headerlink" title="极大似然估计MLE"></a>极大似然估计MLE</h1><ol>
<li>样本集中的样本都是独立同分布iid的，可以只考虑一类样本集D，来估计参数向量$\theta$。</li>
</ol>
<p>$D = {x_1, x_2, … ,x_N}$</p>
<ol start="2">
<li>似然函数(likelihood function)：联合概率密度函数$p(D| \theta )$称为相对于$\theta$的似然函数。</li>
</ol>
<p>$l(\theta) = p(D|\theta) = p(x_1, x_2,…,x_N | \theta) = \prod_{i=1}^N p(x_i | \theta)$</p>
<p>当$\widehat{\theta}$是参数空间中<strong>使似然函数最大的$\widehat{\theta}$值</strong>，那么，$\widehat{\theta}$很可能是最可能的参数值，则$\widehat{\theta}$为$\theta$的极大似然估计量。</p>
<ol start="3">
<li>MLE：求解使得出现该组样本的概率最大的$\theta$值。</li>
</ol>
<p>$$\widehat{\theta} = arg\underset{\theta}max l(\theta) = arg\underset{\theta}max \prod_{i=1}^N p(x_i | \theta)$$</p>
<ol start="4">
<li>对数似然函数（便于分析）</li>
</ol>
<p>$$\widehat{\theta} = arg\underset{\theta}max H(\theta) = arg\underset{\theta}max ln l(\theta) = arg\underset{\theta}max \sum_{i=1}^N ln p(x_i|\theta)$$</p>
<h1 id="Lipschitz连续"><a href="#Lipschitz连续" class="headerlink" title="Lipschitz连续"></a>Lipschitz连续</h1><p>在一个连续函数f上面额外施加一个限制，要求存在一个常数$K \geq 0$，使得定义域内的任意两个元素$x_1$和$x_2$都满足$|f(x_1) - f(x_2)| \leq K|x_1 - x_2|$，即f的导数的绝对值不超过K。</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>服务器连接</title>
    <url>/2020/03/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="ssh远程连接（无需输入密码）"><a href="#ssh远程连接（无需输入密码）" class="headerlink" title="ssh远程连接（无需输入密码）"></a>ssh远程连接（无需输入密码）</h1><ol>
<li><p>确保已经有生成有SSH公钥：<br>进入 <code>~/.ssh</code> 可看到有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> ，其中 <code>id_rsa.pub</code> 为公钥。<br>若没有，运行：<code>ssh-keygen -t rsa -C &quot;***@gmail.com&quot;</code> 或 <code>ssh-keygen</code></p>
</li>
<li><p>将本电脑公钥发送到服务器端：<br><code>ssh-copy-id username@144.202.***.***</code></p>
</li>
<li><p>验证：<br><code>ssh &#39;username@144.202.***.***&#39;</code><br>自动连接！</p>
</li>
</ol>
<ul>
<li>若使用该方式后重置，再次连接时，会出现 <code>Host key verfication failed</code> 情况，使用 <code>ssh-keygen -R ip地址</code> 清除。</li>
</ul>
<h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><ol>
<li><p>上传本地文件夹到服务器<br><code>scp -P port -r LocalWorkSpaces username@IP:WorkSpaces</code></p>
</li>
<li><p>下载服务器文件夹到本地<br><code>scp -P port -r username@IP:WorkSpaces LocalWorkSpaces</code> </p>
</li>
<li><p>上传本地文件到服务器<br><code>scp -P port file username@IP:WorkSpaces</code></p>
</li>
<li><p>下载服务器文件到本地<br><code>scp -P port 用户名@IP:file LocalWorkSpaces</code> </p>
</li>
</ol>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>remote</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习</title>
    <url>/2020/06/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="深度学习与神经网络的区别"><a href="#深度学习与神经网络的区别" class="headerlink" title="深度学习与神经网络的区别"></a>深度学习与神经网络的区别</h1><ul>
<li>网络架构：3-5层$\longrightarrow$上千层</li>
<li>激活函数：sigmoid$\longrightarrow$ReLU</li>
<li>层间连接：全连接$\longrightarrow$权值共享、ResNet</li>
<li>梯度下降：SGD$\longrightarrow$Adam<br>   一般先用Adam快速验证，再精调SGD进行极致优化。</li>
<li>目标函数：MSE$\longrightarrow$CE</li>
<li>除过拟合：凭经验$\longrightarrow$Dropout</li>
</ul>
<h1 id="SoftMax"><a href="#SoftMax" class="headerlink" title="SoftMax"></a>SoftMax</h1><p>SoftMax层的作用是突出最大值，并转换成概率的形式。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/softMax.jpg" alt="softMax"></p>
<p>将一些输入映射为0-1之间的实数，并且归一化保证和为1，并且按照概率分布，即分值大的值取到的概率大，分值小的值偶尔取到。</p>
<p>假定现有一个数组V，v_i 表示V中第i个元素，那么这个元素的soft-max值为$s_i = \frac{e^i}{\sum_j e^j}$</p>
<h1 id="梯度消失问题"><a href="#梯度消失问题" class="headerlink" title="梯度消失问题"></a>梯度消失问题</h1><p>随着网络层数的增加，网络发生了退化(degradation)的现象：</p>
<ul>
<li>随着网络层数的增多，训练集loss逐渐下降，然后趋于饱和；</li>
<li>当再增加网络深度时，训练集loss反而会增大；</li>
<li>不是过拟合，因为在过拟合中训练loss是一直减小的。</li>
</ul>
<p>梯度消失的原因：</p>
<ul>
<li>神经元的激活函数采用了Sigmoid函数；</li>
<li>大部分情况下$|w| &lt; 1$，而Sigmoid的导数$\sigma’ &lt; \frac{1}{4}$。</li>
</ul>
<p>2006年，Hinton等用受限玻尔兹曼机RBM预训练的方式解决梯度消失的问题；<br>2015年，开始使用<a href="/2020/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" title="ReLU">ReLU</a>激活函数。</p>
<h1 id="目标函数-损失函数-代价函数"><a href="#目标函数-损失函数-代价函数" class="headerlink" title="目标函数/损失函数/代价函数"></a>目标函数/损失函数/代价函数</h1><h2 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h2><p>$$\sum_{i=1}^n (y_i - \widehat{y}_i)^2$$</p>
<p>预测得到的结果与真实值间的误差的平方和的平均值。</p>
<h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>$$-\sum_{i=1}^n \widehat{y}_i ln y_i = 0$$</p>
<p>计算出的y值不可能为0，可避免计算困难。<br>交叉熵目标函数的最优值搜索空间的“地形”更陡，更有利于快速找到最优值。</p>
<h1 id="学习步长"><a href="#学习步长" class="headerlink" title="学习步长"></a>学习步长</h1><ul>
<li>若学习步长过大，则目标函数可能不降低；</li>
<li>若学习步长过小，训练过程可能非常缓慢。</li>
</ul>
<p>解决方法：训练几轮后按一些因素调整学习步长。</p>
<h1 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h1><p>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Batch_Normalization.png" alt="Batch_Normalization"></p>
<ul>
<li>在每次SGD时，通过mini-batch来对相应的activation做规范化操作，使得输出信号各维度的均值为0，方差为1；</li>
<li>最后的<code>scale and shift</code>是为了让因训练所需而刻意加入的BN能够还原最初的输入。</li>
</ul>
<h1 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h1><p>当目标函数在<code>验证集</code>上不再减小时，训练就应该停止了，不能一味追求<code>训练集</code>的误差减小。</p>
<p>权重衰减：因为在BP中很多权重是无用的，因此对于原梯度下降$w \leftarrow w - \eta \frac{\partial L}{\partial w}$将权重衰减为$w \leftarrow (1-\lambda)w - \eta \frac{\partial L}{\partial w}$，其中，$\lambda$为衰减率，随着训练持续越来越小。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Dropout.jpg" alt="Dropout"></p>
<ul>
<li>每次更新参数前，按照一定的比例来删减部分神经元；</li>
<li>Dropout是集成学习的一种，使用一小块数据来训练一系列“子网络”。</li>
</ul>
<p><strong>测试时，要使用所有神经元，并且权重要按照同衰减比例缩小。</strong></p>
<p>参考：<br><a href="https://www.cnblogs.com/guoyaohua/p/8724433.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8724433.html</a></p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
  </entry>
  <entry>
    <title>激活函数</title>
    <url>/2020/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/sigmoid.jpg" alt="sigmoid"></p>
<p>$g(z) = \frac{1}{1 + e^{-z}}$</p>
<p>常用于二元分类的输出层，输出介于0-1之间。</p>
<h1 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/tanh.png" alt="tanh"></p>
<p>$tanh(x) = \frac{e^x - e^{-x}}{e^{-x} + e^x}$</p>
<h1 id="ReLu"><a href="#ReLu" class="headerlink" title="ReLu"></a>ReLu</h1><p><em>rectified linear unit，修正线性单元</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/ReLU.jpg" alt="ReLU"></p>
<ul>
<li>常规ReLU：$Max(0,x_i)$<ul>
<li>当$x\geq0$时，$y_i=x_i$；</li>
<li>当$x&lt;0$时，$y_i=0$；</li>
</ul>
</li>
<li>Leaky ReLU：$Max(ax_i,x_i)$<ul>
<li>当$x\geq0$时，$y_i=x_i$；</li>
<li>当$x&lt;0$时，$y_i=a_i x_i$；</li>
</ul>
</li>
<li>Randomized Leaky ReLU：<ul>
<li>当$x\geq0$时，$y_i=x_i$；</li>
<li>当$x&lt;0$时，$y_{ji}=a_{ji} x_{ji}$；</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/ReLU%E6%BF%80%E6%B4%BB.png" alt="ReLU激活"></p>
<p>使用ReLU激活后，一些单元的输出成了0，另一些则变为线性单元，避免了调整各层权重时的梯度消失的问题。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/ReLU%E4%BC%98%E5%8C%96.png" alt="ReLU优化"></p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
  </entry>
  <entry>
    <title>熵</title>
    <url>/2020/06/27/%E7%86%B5/</url>
    <content><![CDATA[<h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><ul>
<li>假设一个样本集中有<strong>两个概率分布p、q</strong>，其中p为真实分布，q为非真实分布；</li>
<li>按照真实分布p来衡量识别一个样本所需要的编码长度的期望为：$$\sum_i p(i) \cdot log(\frac{1}{p(i)})$$</li>
<li>按照错误分布q表示来自真实分布p的平均编码长度的期望为：$$\sum_i p(i) \cdot log(\frac{1}{q(i)})$$</li>
<li>$H(p,q)$称之为交叉熵。</li>
</ul>
<h1 id="相对熵-KL散度"><a href="#相对熵-KL散度" class="headerlink" title="相对熵/KL散度"></a>相对熵/KL散度</h1><p>KL散度，是两个概率分布P和Q差别的非对称性的度量。</p>
<p>通常情况下，</p>
<ul>
<li>P表示数据的真实分布；</li>
<li>Q表示数据的理论分布（模型分布、P的近似分布）$D(P||Q) = \sum P(x) log \frac{P(x)}{Q(x)}$ 。</li>
</ul>
<p>KL散度<strong>不对称</strong>，不满足距离的性质，即$D_{KL}(P||Q) \neq D_{KL}(Q||P)$ 。</p>
<h1 id="JS散度"><a href="#JS散度" class="headerlink" title="JS散度"></a>JS散度</h1><p>JS散度，度量两个概率分布的相似度；是基于KL散度的变体，解决了KL散度非对称性的问题。</p>
<p>$$JS(P||Q) = \frac{1}{2} KL(P(x)||\frac{P(x)+Q(x)}{2}) + \frac{1}{2} KL(Q(x)||\frac{P(x)+Q(x)}{2})$$</p>
<p>KL散度具有对称性，其取值区间为[0,1]。</p>
]]></content>
  </entry>
  <entry>
    <title>生成对抗网络</title>
    <url>/2020/06/09/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="生成式模型和判别式模型"><a href="#生成式模型和判别式模型" class="headerlink" title="生成式模型和判别式模型"></a>生成式模型和判别式模型</h1><ul>
<li>判别式模型</li>
</ul>
<p>已知观察变量X和隐含变量z，对$p(z|X)$进行建模，根据输入的观察变量x得到隐含变量z出现的概率。</p>
<ul>
<li>生成式模型</li>
</ul>
<p>已知观察变量X和隐含变量z，对$p(X|z)$进行建模，根据隐含变量z得到输出是观察变量x的概率。</p>
<h1 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GAN%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="GAN基本流程"></p>
<ul>
<li><p>生成器网络Generator：$x = G(z; \theta^{(G)})$，负责生成样本数据；</p>
<ul>
<li>输入：高斯白噪声向量z；</li>
<li>输出：样本数据向量x；</li>
</ul>
</li>
<li><p>判别器网络Discriminator：$y = D(x, \theta^D)$，负责检测样本数据真假；</p>
<ul>
<li>输入：真实/生成 样本数据；</li>
<li>输出：真/假 标签；</li>
</ul>
</li>
</ul>
<p><em>该网络参数一定满足可微分。</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/G2D.png" alt="G2D"></p>
<p>基本思路：</p>
<ol>
<li>让第一代的G产生一些图片，将其和部分真实图片放到D中学习；</li>
<li>让第一代的D能够分辨生成的图片和真实的图片；</li>
<li>训练第二代的G，让第二代G生成的图片，能欺骗过第一代的D；</li>
<li>训练第二代的D；</li>
<li>依次循环3、4，直到满足终止条件。</li>
</ol>
<p><em>通过将新一代的G和上一代的D连接起来(感觉有些类似级联分类器)，形成一个新的G，生成能欺骗过上一代D的图像。</em></p>
<p>模型的目标：</p>
<ul>
<li>训练数据集的模型：$x ~ p_{train} (x)$</li>
<li>生成样本的模型：$x ~ p_{model} (x)$</li>
<li>使其相等：$p_{train} (x) = p_{model} (x)$</li>
</ul>
<p>优化目标/价值函数：<br>  $$min_G max_D V(D,G) = E_{x \sim p_{data}(x)} [log D(x)] + E_{z \sim p_z(z)} [log (1-D(G(z)))]$$</p>
<ul>
<li>生成器G固定后，使用$max_D V(D,G)$来评价$p_{data}$和$p_z$间的差异；</li>
<li>判别器优化方向 -&gt; 最大化价值函数$$J(D) = -\frac{1}{2} E_{x \sim p_{data}} log D(x) - \frac{1}{2} E_z log(1-D(G(z)))$$</li>
<li>生成器优化方向 -&gt; 最小化价值函数$$J(G) = -J(D) = \frac{1}{2} E_z log(1-D(G(z)))$$</li>
</ul>
<p>  <em>优化目标函数，直到达到纳什均衡</em></p>
<p>为了引入KL散度和JS散度，对目标函数进行变换：</p>
<ol>
<li>$KL(P_1||P_2)=E_{x \sim P_1} log \frac{P_1}{P_2}$</li>
<li>$JS(P_1||P_2)=\frac{1}{2} KL(P_1|| \frac{P_1+P_2}{2} + \frac{1}{2} KL(P_2|| \frac{P_1+P_2}{2})$</li>
<li>$2JS(P_r||P_g) - 2log2$</li>
<li>$E_{x \sim P_r}[log D(x)] + E_{x \sim P_g}[log (1-D(x)]$</li>
<li>$E_{x \sim P_r}log \frac{P_r (x)}{\frac{1}{2} [P-r(x) + P_g(x)]} + E_{x \sim P_g}log \frac{P_g(x)}{\frac{1}{2} [P_r(x) + P_g(x)]} - 2log2$</li>
</ol>
<p>在最优判别器下，GAN定义的$G_{loss}$可等价变换为<strong>最小化真实函数与生成分布</strong>的JS散度。</p>
<p>主要解决问题：</p>
<ul>
<li>构建高维、复杂概率分布；</li>
<li>解决数据缺少问题；</li>
<li>用于多模态输出；</li>
<li>解决真实输出任务；</li>
<li>进行数据预测etc。</li>
</ul>
<p>存在问题：</p>
<ul>
<li>训练困难，难以达到纳什均衡点，且无法有效监控收敛状态；</li>
<li>模型崩溃，D能力明显强于G；</li>
<li>输出多样性低，G将数据集中生成在D最好的空间点；</li>
<li>不适用于离散输出（不可微分）。</li>
</ul>
<h2 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DCGAN.png" alt="DCGAN"></p>
<p>模型稳定训练的tricks：</p>
<ul>
<li>全连接层、池化层、上采样层 -&gt; 卷积层；</li>
<li>使用<code>batch normalization</code>；</li>
<li>生成器中卷积层-&gt;反卷积层，并使用ReLU激活函数，输出使用Tanh；</li>
<li>判别器中使用<code>Leaky ReLU</code>激活函数；</li>
<li>使用Adam优化器训练，学习率建议0.0002。</li>
</ul>
<p>生成的特征具有向量的计算特性，即特征可以进行加减运算。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/z%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E7%89%B9%E6%80%A7.png" alt="z向量的计算特性"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/z%E5%90%91%E9%87%8F%E7%9A%84%E6%8F%92%E5%80%BC%E7%89%B9%E6%80%A7.png" alt="z向量的插值特性"></p>
<p>生成效果：LSUN数据集</p>
<ul>
<li>仅支持低分辨率的图片；</li>
<li>无法捕捉物体的结构特性。</li>
</ul>
<h2 id="CGAN"><a href="#CGAN" class="headerlink" title="CGAN"></a>CGAN</h2><p>将GAN中输入的随机的数据，更改为有意义的数据。ex.手写数字字体的生层，输入的是一个数字，输出对应的字体。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CGAN.png" alt="CGAN"></p>
<p>实现思路：</p>
<ul>
<li>在生成网络的输入z的基础上连接一个输入额外信息y；</li>
<li>在判别网络的输入x的基础上连接一个y；</li>
<li>目标函数变为$$min_G max_D V(D,G) = E_{x \sim p_{data}(x)} [log D(x|y)] + E_{z \sim p_z(z)} [log (1-D(G(z|y)))]$$</li>
</ul>
<h2 id="Wasserstein-GAN"><a href="#Wasserstein-GAN" class="headerlink" title="Wasserstein GAN"></a>Wasserstein GAN</h2><p>目标函数问题：</p>
<ul>
<li>$P_r$和$P_g$不重叠部分，JS为固定常数，对SGD来说梯度为0；</li>
<li>$P_r$和$P_g$的重叠部分基本可以忽略；</li>
<li>在最优D下，最小化G的loss等价于最小化$P_r$和$P_g$间的JS散度。</li>
</ul>
<p>由于$P_r$和$P_g$多少都会有可以忽略的重叠部分，所以，无论相聚多远，JS散度都是常数，最终导致G的梯度近似为0，梯度消失。</p>
<p>Wasserstein距离/Earth-Mover距离：$$W(P_r,P_G)=inf_{\gamma \sim \Pi(P_r, P_g)} \mathbb{E}_{(x,y)\sim \gamma} [||x-y||]$$</p>
<p>$W(P_r,P_G)$即为最优路径规划下的最小能量，可理解为将$P_r$转为$P_g$的能量。</p>
<p>Wasserstein距离相比KL散度、JS散度的优点：即便两个分布没有重叠，Wasserstein距离依然能反映$P_r$和$P_g$的距离。</p>
<p>目标函数：</p>
<ul>
<li>生成器loss：$-\mathbb{E}_{x \sim P_g}[f_w(x)]$</li>
<li>判别器loss：$\mathbb{E}<em>{x \sim P_g} [f_w(x)] - \mathbb{E}</em>{x \sim P_r} [f_w(x)]$</li>
</ul>
<p>创新点：</p>
<ol>
<li>判别器最后一层去掉sigmoid（不做分类，改为回归问题）；</li>
<li>G和D的loss不取log；</li>
<li>每次更新D的参数后将其绝对值截断到不超过一个固定常数c；</li>
<li>不用基于动量的优化算法(momentum、adam等)，推荐RMSProp、SGD等。</li>
</ol>
<p>实现效果：</p>
<ul>
<li>解决GAN训练不稳定的问题，无需担心平衡G和D的训练程度；</li>
<li>基本解决<code>collapse mode</code>的问题，确保生成样本的多样性；</li>
<li>训练过程中拥有了交叉熵、准确率等数值表示来指导训练的过程，数值越小G生成的图像质量越高；</li>
<li>最简单的多层全连接网络即可达到较好效果，不需精心设计的网络架构。</li>
</ul>
<p><em>WGAN不用DCGAN各种特殊的架构设计，与DCGAN结果类似。</em></p>
<h1 id="Super-ResolutionGAN"><a href="#Super-ResolutionGAN" class="headerlink" title="Super-ResolutionGAN"></a>Super-ResolutionGAN</h1><p>$I^{HR}$，高分辨率图像，来自数据库；<br>$I^{LR}$，由$I^{HR}$进行高斯滤波，然后下采样获得。</p>
<p>目标函数：<br>$min_{\theta_G} max_{\theta_D} \mathbb{E}<em>{I^{HR}\sim p</em>{train}(I^{HR})}[log D_{\theta_D}(I^{HR})]+\mathbb{E}<em>{I^{LR}\sim p_G(I^{LR})}[log(1-D</em>{\theta_D}(G_{\theta_G}(I^{LR})))]$</p>
<p>参数$\theta_G$通过优化一个损失函数$l^{SR}$得到：$\widehat{\theta}<em>G=arg min</em>{\theta_G}\frac{1}{N}\sum_{n=1}^N l^{SR}(G_{\theta_G}(I_n^{LR}),I_n^{HR})$</p>
<ol>
<li>生成网络：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/SRGAN_G.png" alt="SRGAN_G"><ul>
<li>应用分布相同的B残差块，每个残差块由两个卷积层；</li>
<li>卷积层后加上BN层，并用PReLU为激活函数；</li>
<li>卷积层的卷积核全部为3*3，并有64个特征图；</li>
<li>添加跳层/跃层连接。</li>
</ul>
</li>
<li>判别网络：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/SRGAN_D.png" alt="SRGAN_D"><ul>
<li>由连续卷积块构成，包括卷积层、LeakyReLU、BN层；</li>
<li>卷积核为3*3；</li>
<li>最后使用两个dense层，并通过sigmoid进行判别。</li>
</ul>
</li>
</ol>
<h1 id="CycleGAN"><a href="#CycleGAN" class="headerlink" title="CycleGAN"></a>CycleGAN</h1><p><em>可实现无配对的两个图片集的训练，结构有些类似于自动编码器。</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CycleGAN.png" alt="CycleGAN"></p>
<p>CycleGAN本质上是镜像对称的GAN网络，构成了一个环形回路。两个GAN共享两个G，并各自带了一个D，一个单向GAN两个loss，因此，整个网络共有四个loss。</p>
<p>损失函数（使用均方误差）：<br>$L_{LSGAN}(G,D_Y,X,Y)=\mathbb{E}<em>{y\sim p</em>{data}(y)}[(D_Y(y)-1)^2]+\mathbb{E}<em>{x\sim p</em>{data}(x)}[1-D_Y(G(x))]^2$</p>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/104575937" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104575937</a><br><a href="https://blog.csdn.net/gdymind/article/details/82696481" target="_blank" rel="noopener">https://blog.csdn.net/gdymind/article/details/82696481</a><br><a href="https://zhuanlan.zhihu.com/p/83630387" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/83630387</a><br><a href="https://zhuanlan.zhihu.com/p/90835081" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90835081</a><br><a href="https://www.jianshu.com/p/64bf39804c80" target="_blank" rel="noopener">https://www.jianshu.com/p/64bf39804c80</a></p>
]]></content>
  </entry>
  <entry>
    <title>皮囊</title>
    <url>/2020/03/09/%E7%9A%AE%E5%9B%8A/</url>
    <content><![CDATA[<p>本来是抱着一个很轻松的心情翻开这本书的，但是在看完几页之后愈感沉重，以至于不得不分到几天时间才能看完。总体来说，这种书写得很厚重，只有在经历了人生的坡坡坎坎之后才能有此积淀。我觉得这本书最出彩的地方在于它可以主动去勾起你的回忆，以及对人生的思考。人生在世，我们每个人都披了一层皮囊，以此区别于不同的人，为其注入各种不同的思想，活出自己的精彩人生。</p>
<p>倔强而又骄傲的母亲，为了完成与心爱之人的约定，执着又顽强的坚定的遵从自己的内心。活出了女性的坚持与美丽。与之对应的是爱面子的父亲，在重病期间依旧想的是如何撑起这个家，他将一生全部奉献给了这个家。这是国内传统家庭的真实写照，男主外女主内，在父亲病重后由儿子撑起这个家，在这种交替中，完成了一种身份的转变，责任的交接。</p>
<p>“张美丽”和“阿小”是当时在那个大环境下的必然产物，是人的内心欲望使然，是人们开始过上美好富裕生活的必然转变，他们是活在了那个特殊的年代，因此显得与周围人格格不入，也正是由于有了这些人的存在，为我们的时代发展转变做出了自己的贡献，我们在现代这个大环境下才活得那么的自然。</p>
<p>“天才文展”与“厚朴”是我们基本都会遇到的，一个被尊奉为天才，一个充满正能力，有理想，是我们每个人都渴望成为的那类人的分解。“天才文展”学习好，够坚持，有目标，但是活得过于压抑；“厚朴”每天活在自己的想象中，快乐，虚假，脱离了实际。这两类人又是两种互补人格，以两个人的结局与自己形成鲜明对比，告诫我们要如何选择自己的人生。</p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>监督学习</title>
    <url>/2020/06/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Delta学习规则"><a href="#Delta学习规则" class="headerlink" title="Delta学习规则"></a>Delta学习规则</h1><p>通过神经元的实际输出，与期望输出的差别，来调整连接权重。</p>
<p>$$\bigtriangleup w_{ij} = a \cdot (d_i - y_i) x_j(t)$$</p>
<p>其中,</p>
<ul>
<li>$\bigtriangleup w_{ij}$表示神经元j到神经元i的连接权重增量；</li>
<li>$d_i$是神经元i的期望输出；</li>
<li>$y_i$是神经元i的实际输出；</li>
<li>$x_i$是神经元j的状态；</li>
<li>$a$表示学习速率。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>目标检测DPM</title>
    <url>/2020/06/02/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BDPM/</url>
    <content><![CDATA[<h1 id="DPM"><a href="#DPM" class="headerlink" title="DPM"></a>DPM</h1><p>该模型包含了一个<code>8*8</code>分辨率的根滤波器(Root filter)，和<code>4*4</code>分辨率的组件滤波器(Part filter)，和高斯滤波后的2倍空间模型。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DPM.png" alt="DPM"></p>
<p><em>中间分辨率为左图的2倍，梯度更加精细。</em></p>
<p><em>自行车DPM检测：</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%87%AA%E8%A1%8C%E8%BD%A6DPM.png" alt="自行车DPM"></p>
<h2 id="响应分数"><a href="#响应分数" class="headerlink" title="响应分数"></a>响应分数</h2><p>$$ score(x_0, y_0, l_0) = R_{0,l_0}(x_0, y_0) + \sum_{i=1}^n D_{i,l_0-\lambda}(2(x_0,y_0)+v_i) + b $$</p>
<p>其中，$x_0,y_0,l_0$分布为锚点的横坐标、纵坐标、尺度；<br>$R_{0,l_0}(x_0,y_0)$为跟模型的响应分数；<br>$D_{i,l_0-\lambda}(2(x_0,y_0)+v_i)$为部件模型的响应分数；<br>b为不同模型组件间的偏移系数，使其与根模型对齐；<br>$2(x_0,y_0)$表示组件模型的像素为原始的2倍。</p>
<h2 id="检测流程"><a href="#检测流程" class="headerlink" title="检测流程"></a>检测流程</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DPM%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B.png" alt="DPM检测流程"></p>
<ol>
<li>对输入图像，提取其DPM特征图，然后将原图像进行高斯金字塔上采样，然后提取其DPM特征图；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DPM_31D%E7%89%B9%E5%BE%81.png" alt="DPM_31D特征"></li>
<li>对原图像的DPM特征图和训练好的<code>Root filter</code>做卷积操作，得到<code>Root filter</code>的响应图；</li>
<li>对2倍图像的DPM特征图和训练好的<code>Part filter</code>做卷积，得到<code>Part filter</code>的响应图；</li>
<li>对其精细高斯金字塔做下采样操作，使<code>Root filter</code>响应图和<code>Part filter</code>响应图具有相同分辨率；</li>
<li>对其进行加权平均，得到最终响应图。<em>亮度越大响应值越大</em></li>
</ol>
<h2 id="Latent-SVM"><a href="#Latent-SVM" class="headerlink" title="Latent SVM"></a>Latent SVM</h2><a href="/2020/06/02/svm/" title="Latent-SVM">Latent-SVM</a>

<p>DPM选择最大的正样本，但是其latent变量较多，如<code>bounding box</code>在HOG特征金字塔中的level，某样本属于哪一类component。<br>即有一张正样本图像，标注了<code>bounding box</code>，我们要在某一位置、某一尺度，提取出最大正样本作为某一component的正样本。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DPM-SVM.png" alt="DPM-SVM"></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>object detection</tag>
      </tags>
  </entry>
  <entry>
    <title>直方图均衡化</title>
    <url>/2020/06/06/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</url>
    <content><![CDATA[<h1 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h1><ul>
<li>实质上是对图像进行非线性拉伸，重新分配各个灰度单位的像素点数量，使其均匀分布；</li>
<li>利用图像直方图对图像的对比度进行调整；</li>
<li>通常用于增强局部的对比度而不影响整体对比度，过黑或过曝的处理。</li>
</ul>
<p>思路：</p>
<ol>
<li>统计每个颜色出现的概率；</li>
<li>计算累计概率；</li>
<li>根据累计概率求取新的颜色映射表：p*255；</li>
<li>利用新颜色映射表完成颜色映射。</li>
</ol>
<h2 id="自适应直方图均衡AHE"><a href="#自适应直方图均衡AHE" class="headerlink" title="自适应直方图均衡AHE"></a>自适应直方图均衡AHE</h2><ul>
<li>移动模版在源图像上按stride滑动；</li>
<li>移动后，模版区域内做直方图均衡，映射后的结果赋值给模版区域内所有点；</li>
<li>对每个点取多次赋值的均值。</li>
</ul>
<p>缺点：过度放大平滑区域噪声。</p>
<h2 id="CLAHE（自适应直方图均衡）"><a href="#CLAHE（自适应直方图均衡）" class="headerlink" title="CLAHE（自适应直方图均衡）"></a>CLAHE（自适应直方图均衡）</h2><p>算法步骤：</p>
<ol>
<li>对图像进行分块，以块为单位；</li>
<li>先计算直方图，然后对其进行修剪，然后均衡；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CLAHE%E4%BF%AE%E5%89%AA.png" alt="CLAHE修剪"></li>
<li>遍历各个图像块，对块间区域进行双线性差值，使图像平滑；</li>
<li>与源图像做涂层滤色混合操作（可选）。</li>
</ol>
<p>映射关系：<br>    <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CLAHE%E6%98%A0%E5%B0%84.png" alt="CLAHE映射"></p>
<ul>
<li>小黑点处的灰度值由映射函数直接计算得出；</li>
<li>粉色区域灰度值由映射函数计算得出；</li>
<li>滤色区域灰度值由相邻2块灰度值映射线性插值得出；</li>
<li>紫色区域灰度值由相邻4块灰度值映射线性插值得出。</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>多尺度变换</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生复试</title>
    <url>/2018/03/15/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/</url>
    <content><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>Good morning, dear professors. It is my pleasure to be here for this interview. My name is …, I am 24 years old, born in …, hebei province. I have finished my graduate education in … university, majoring in software engineering.</p>
<p>I have broad interests. In my spare time, I like riding, reading and especially in engineering such as software programming, website design. I like to ride a bike to relax when I am in a bad mood or I have no idea. In the past few years, I have accomplished two websites: one is the website of our online examination system, and the other is the website of my graduation design. Furthermore, I am interested in C programming language and have written some application programs. During the days preparing for postgraduate examination I insist on running everyday. Thanks to this, I could concentrate on my study .</p>
<p>Although I have broad interests in many aspects and grasp the essential knowledge of the major, but I think at present, I can do many things in a superficial level, but not be competent to do things professionally owing to lack of ample knowledge and ability. So I think further study is still urgent for me to realize self-value. I think further education is still urgent for me to realize self-value. Life is precious. It is necessary to seize any chance for self-development, especially in this competitive modern world. In a word, I am looking forward to making a solid foundation for future profession after three years study here. </p>
<p>If I got a chance to study here, I would spare no effort to do research of my major, build up systematic view of management and achieve self value .</p>
<p>That’s all. Thank you.</p>
]]></content>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/2020/06/05/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png" alt="人工神经网络"></p>
<p>神经网络：由大量神经元节点按照一定体系架构连接而成的网状结构，一般包含输入层、隐藏层、输出层三部分。</p>
<p>神经网络可用于分类、模式识别、连续值预测 etc. </p>
<p><em>一般的浅层网络只有3-5层，这也是区别于DL的主要地方。</em></p>
<h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><h3 id="生物神经元"><a href="#生物神经元" class="headerlink" title="生物神经元"></a>生物神经元</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%94%9F%E7%89%A9%E7%A5%9E%E7%BB%8F%E5%85%83.jpg" alt="生物神经元"></p>
<p>生物神经元之间的相互连接，使得信息在大脑中得以传递。</p>
<h3 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E5%85%83.jpg" alt="人工神经元"></p>
<p>每个神经元都是一个结构相似的独立单元，接受前一层传来的数据，并将其加权和输入到非线性激活函数中，然后，将非线性激活函数的输出传递给下一层。</p>
<p>神经元包括以下内容：</p>
<ul>
<li>输入向量x；</li>
<li>权重向量w；</li>
<li>偏置向量b；</li>
<li>激活函数f；</li>
</ul>
<h2 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h2><ul>
<li>前馈神经网络采用一种单向多层结构；</li>
<li>各神经元从输入层开始，接收前一级输入，并输出到下一级，直到输出层。</li>
<li>每一层包含若干各神经元，同一层间的神经元间没有连接，层间信息的传递只沿一个方向进行；</li>
<li>整个网络中没有反馈，类似一个有向无环图。</li>
</ul>
<h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><a href="/2020/06/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" title="Delta学习规则">Delta学习规则</a>

<p>$$J(w) = \frac{1}{2} \Vert t - z \Vert^2 = \frac{1}{2} \sum_{k=1}^c (t_k - z_k)^2$$<br>其中，$t = (t_1,…,t_c$表示期望输出，$z = (z_1,…,z_c$表示实际输出。</p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/gradient_descent.png" alt="gradient_descent"></p>
<p>这是一个表示参数w与目标函数J(w)的关系图，红色部分表示J(w)有较高取值，需要让J(w)的值尽可能降低，到达深蓝色部分。</p>
<p>$$w(m+1) = w(m) + \bigtriangleup w(m) = w(m) - \eta \frac{\partial J}{\partial w}$$</p>
<p>看到一个很形象的示意图：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="梯度下降示意图"></p>
<p>整体思路：</p>
<ul>
<li>先确定一个初始点；</li>
<li>将w按照梯度下降方向进行调整，使J(w)向更低方向变化；</li>
<li>直到，w无法继续下降为止。</li>
</ul>
<h2 id="误差反向传播"><a href="#误差反向传播" class="headerlink" title="误差反向传播"></a>误差反向传播</h2><p>定义几个变量：J为目标函数；z为输出结果；$net_k$为输出单元的总输入；$net_j$为隐藏层单元的总输入；$y_j$为隐藏层单元的输出。</p>
<ol>
<li>输出层权重改变量：</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BE%93%E5%87%BA%E5%B1%82%E6%9D%83%E9%87%8D%E6%94%B9%E5%8F%98.png" alt="输出层权重改变"></p>
<p>$$\frac{\partial J}{\partial w_{kj}} = \frac{\partial J}{\partial net_k} \frac{\partial net_k}{\partial w_{kj}}$$</p>
<p>其中，</p>
<ul>
<li>$$J(w) = \frac{1}{2} \Vert t - z \Vert^2 = \frac{1}{2} \sum_{k=1}^c (t_k - z_k)^2$$</li>
<li>$$net_k = \sum_{i=1}^{n_H} w_{ki}y_i$$</li>
<li>$$\frac{\partial J}{\partial net_k} = \frac{\partial J}{\partial z_k} \frac{\partial z_k}{\partial net_k} = -(t_k - z_k) f’(net_k)$$</li>
<li>$$\frac{\partial net_k}{\partial w_{kj}} = y_j$$</li>
</ul>
<ol start="2">
<li>隐藏层权重改变量：</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%9A%90%E8%97%8F%E5%B1%82%E6%9D%83%E9%87%8D%E6%94%B9%E5%8F%98.png" alt="隐藏层权重改变"></p>
<ul>
<li>先找到$w_{ji}$与$net_j$的关系；</li>
<li>然后找$net_j$与隐藏层输出$y_j$的关系。</li>
</ul>
<p>$$\frac{\partial J}{\partial w_{ji}} = \frac{\partial J}{\partial y_j} \frac{\partial y_i}{\partial net_j} \frac{\partial net_j}{\partial w_{ji}}$$</p>
<p>其中，</p>
<ul>
<li>$$\frac{\partial net_j}{\partial w_{ji}} = \frac{\partial}{\partial w_{ji}} (\sum_{m=1}^d w_{jm} x_m) = x_i$$</li>
<li>$$\frac{\partial y_j}{\partial net_j} = f’(net_j)$$</li>
<li>$$\frac{\partial J}{\partial y_i} = \frac{\partial}{\partial y_j} [\frac{1}{2} \sum_{k=1}^{c} (t_k - z_k)^2] = -\sum_{k=1}^c (t_k - z_k) \frac{\partial z_k}{\partial y_i} = -\sum_{k=1}^c (t_k - z_k) \frac{\partial z_k}{\partial net_k} \frac{\partial net_k}{\partial y_i} =  -\sum_{k=1}^c (t_k - z_k) f’(net_k) w_{kj}$$</li>
</ul>
<ol start="3">
<li>输出层和隐藏层的误差传播公式可统一为：</li>
</ol>
<ul>
<li>权重增量 = -1 * 学习步长 * 目标函数对权重的偏导数；</li>
<li>目标函数对权重的偏导数 = -1 * 残差 * 当前层的输入；</li>
<li>残差 = 当前层激活函数的导数 * 上层反传的误差；</li>
<li>上层反传的误差 = 上层残差的加权和。</li>
</ul>
<h3 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h3><p>随机梯度下降SGD在样本量很大时，对每个样本迭代更新速度过慢，可能只需其中部分样本即可迭代到最优解。</p>
<p>SGD噪音比BGD(批量梯度下降)多，因此，并不是每次迭代都向着整体最优方向。</p>
<p>优点：<strong>稳定</strong>。</p>
<p>存在的问题：</p>
<ul>
<li>学习步长不易确定，太小收敛满，太大损失函数会在极小值处震荡或偏离；</li>
<li>每个参数的learning rate都相同，当数据稀疏时，难以对出现频率低的特征进行大一点的更新；</li>
<li>学习过程中容易陷入到马鞍面中，所有方向梯度值几乎为0；</li>
</ul>
<p><em>马鞍面：</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%A9%AC%E9%9E%8D%E9%9D%A2.png" alt="马鞍面"></p>
<h3 id="Mini-batch-Gradient-Descent"><a href="#Mini-batch-Gradient-Descent" class="headerlink" title="Mini-batch Gradient Descent"></a>Mini-batch Gradient Descent</h3><p>每次从所有训练数据中取一个子集用于计算梯度，是BGD和SGD的折中。</p>
<ul>
<li>在CNN训练时，绝大多数都采用基于mini-batch的随机梯度下降算法为基础进行训练；</li>
<li>随着输入数据的不断变化，网络中的参数不断调整，网络各层输入数据的分布也不断变化；</li>
<li>各层在训练的过程中需要不断的改变，以适应新的数据分布，容易造成网络训练困难，难以拟合的问题。</li>
</ul>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
  </entry>
  <entry>
    <title>科学上网</title>
    <url>/2020/03/09/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>在<a href="https://my.vultr.com" target="_blank" rel="noopener">vultr</a>注册并创建一个国外的服务器，本人使用的是 <code>Ubuntu1604</code> 版本的服务器。</p>
<h2 id="V2Ray配置"><a href="#V2Ray配置" class="headerlink" title="V2Ray配置"></a>V2Ray配置</h2><ul>
<li><p>安装 <code>V2Ray</code>，安装后输入 <code>v2ray</code> 即可进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;KiriKira&#x2F;v2ray.fun&#x2F;kiriMod&#x2F;install.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;KiriKira&#x2F;v2ray.fun&#x2F;kiriMod&#x2F;uninstall.sh &amp;&amp; bash uninstall.sh</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="进行加速配置："><a href="#进行加速配置：" class="headerlink" title="进行加速配置："></a>进行加速配置：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget —no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>
<ol>
<li>更改加速权限：<code>chmod +x bbr.sh</code>；</li>
<li>开始进行配置：<code>./bbr.sh</code>；</li>
<li>安装后重启；</li>
<li>验证加速设置 <code>lsmod | grep bbr</code>，出现 <code>tcp_bbr</code>。</li>
</ol>
<h2 id="SSR配置（不建议使用）"><a href="#SSR配置（不建议使用）" class="headerlink" title="SSR配置（不建议使用）"></a>SSR配置（不建议使用）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ToyoDAdoubi&#x2F;doubi&#x2F;master&#x2F;ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>
<p>修改时使用 <code>bash ssr.sh</code> 进入管理界面。</p>
<hr>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="Mac推荐使用-V2RayU-进行配置"><a href="#Mac推荐使用-V2RayU-进行配置" class="headerlink" title="Mac推荐使用 V2RayU 进行配置"></a>Mac推荐使用 <code>V2RayU</code> 进行配置</h2><h2 id="Chrome管理插件-Proxy-SwitchyOmega"><a href="#Chrome管理插件-Proxy-SwitchyOmega" class="headerlink" title="Chrome管理插件 Proxy SwitchyOmega"></a>Chrome管理插件 <code>Proxy SwitchyOmega</code></h2><ol>
<li>先配置Proxy文件，端口号根据自己设定自行更改；</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Proxy%E9%85%8D%E7%BD%AE.png" alt="Proxy配置"></p>
<ol start="2">
<li>再配置Switch文件，并添加规则；</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Switch%E9%85%8D%E7%BD%AE.png" alt="Switch配置"><br>规则链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gfwlist&#x2F;gfwlist&#x2F;master&#x2F;gfwlist.txt</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可自定添加规则定制，如添加YouTube设置；<br>在Switch配置文件中，选择 <code>Add condition</code> ，在域名前更改为 * ，并更改 <code>Profile</code>。</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%87%AA%E5%AE%9A%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE.png" alt="自定规则配置"></p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>稀疏表示</title>
    <url>/2020/03/16/%E7%A8%80%E7%96%8F%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h1><p>就是给定一组数据，我们要尽可能的用更少的数据来表示该数据。稀疏表示对应一个超完备字典，利用少量数据与字典的矩阵乘法运算来表示该组数据。<br>即假如原本包含5个值，我们用SR，只用4个值就可以表示。(此处借用一张导师给的example)<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/sr%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.jpg" alt="sr简单理解"></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>在稀疏表示学习过程中，必然会接触到以下词汇：</p>
<pre><code>- autoencoder：简单理解为一个压缩编码器；
- sparse coding：是将输入的样本集X分解为多个基元的线性组合；
- Sparse Autoencoder = sparse coding + autoencoder。</code></pre><p>$$ min_{A,\alpha_i} \sum^m_{i=1} ||{x_i-A\alpha_i}||^2_2 + \lambda \sum^m_{i=1} ||{\alpha_i}||_1 $$<br>第一个累加项说明了字典学习的第一个目标是字典矩阵与稀疏表示的线性组合尽可能的还原样本；<br>第二个累加项说明了 $ \alpha_i $ 应该尽可能的稀疏。<br>满足条件：<br>    $ A^T_j*A_j\leq1 \forall j $<br>    即按常数比例缩放A的同时再按这个常数的倒数缩放\alpha，结果不会改变误差大小，却会减少稀疏代价值。</p>
<p>总体来说，可以归为两部分，先构建一个超完备字典，再通过约束条件（可以是非0个数等）对字典进行一个约束，因为合适的字典一般不只是一个。<br>在常见的PCA算法中，是可以找到一组基来分解X的，只不过那个基的数目比较小，所以可以得到分解后的系数a是可以唯一确定，而在sparse coding中，k太大，比n大很多，其分解系数a不能唯一确定。一般的做法是对系数a作一个稀疏性约束，这也就是sparse coding算法的来源。</p>
<p>$$ J(A,s)=||{x-As}||^2_2 + \lambda \sqrt{s^2+\epsilon}+\gamma||A||^2_2 $$<br>针对上式进行了优化，尤其是对 <code>s</code> 取第一范式时在 <code>0</code> 处不可导问题。</p>
<h1 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h1><p>一些初始化的设置，随后进行迭代优化。</p>
<ol>
<li>随机初始化A</li>
<li>重复以下步骤直至收敛：<ul>
<li>根据上一步给定的A，求解能够最小化J(A,s)的s</li>
<li>根据上一步得到的s，，求解能够最小化J(A,s)的A</li>
</ul>
</li>
</ol>
<p>优化：</p>
<ul>
<li>将样本分批为“mini块”</li>
<li>设置良好的 <code>s</code> 初始值 </li>
</ul>
<hr>
<h2 id="部分以下待完善"><a href="#部分以下待完善" class="headerlink" title="部分以下待完善"></a>部分以下待完善</h2><h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><ul>
<li><p>patch：20000</p>
</li>
<li><p>特征数：256，此处在后续使用时标注121</p>
</li>
<li><p>块维度：16</p>
</li>
<li><p>可见大小：16*16=256，此处在后续使用时标注64</p>
</li>
<li><p>池化维度：3</p>
</li>
<li><p>分组区域维度：3*3</p>
</li>
<li><p>每batch的patch数：2000</p>
</li>
<li><p>$ lambda $：5e-5</p>
</li>
<li><p>$ epsion $：1e-5，此处是为了防止第二个参数在原点处不可导的改进。</p>
</li>
<li><p>$ gamma $：1e-2，此处是在上式基础上添加了一个对sr的惩罚项。</p>
</li>
</ul>
<h2 id="查看mat文件包含图片内容"><a href="#查看mat文件包含图片内容" class="headerlink" title="查看mat文件包含图片内容"></a>查看mat文件包含图片内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load IMAGES.mat</span><br><span class="line">whos</span><br><span class="line">for i &#x3D; 1:10</span><br><span class="line">    subplot(4,5,i)</span><br><span class="line">    imshow(IMAGES(:,:,i))</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>图片大小为 <code>512*512</code>，共10组：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/images_mat.jpg" alt="images_mat"></p>
<h2 id="patches设置"><a href="#patches设置" class="headerlink" title="patches设置"></a>patches设置</h2><p>参数：images; patchDim=16; numPatches=20000.<br>选取10000张图片做训练，patchsize=8</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/tornadomeet/archive/2013/04/13/3018393.html" target="_blank" rel="noopener">https://www.cnblogs.com/tornadomeet/archive/2013/04/13/3018393.html</a><br><a href="https://www.cnblogs.com/yifdu25/p/8385204.html#3991271" target="_blank" rel="noopener">https://www.cnblogs.com/yifdu25/p/8385204.html#3991271</a><br><a href="https://www.cnblogs.com/sprint1989/p/3982204.html" target="_blank" rel="noopener">https://www.cnblogs.com/sprint1989/p/3982204.html</a><br><a href="https://www.jianshu.com/p/38dc2253e4fb" target="_blank" rel="noopener">https://www.jianshu.com/p/38dc2253e4fb</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>稀疏表示</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计与算法</title>
    <url>/2020/01/02/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="程序设计与算法-郭炜-北京大学"><a href="#程序设计与算法-郭炜-北京大学" class="headerlink" title="程序设计与算法 郭炜-北京大学"></a>程序设计与算法 郭炜-北京大学</h1><p>网课地址：<a href="https://www.icourse163.org/learn/PKU-1001894005?tid=1206483202#/learn/announce" target="_blank" rel="noopener">https://www.icourse163.org/learn/PKU-1001894005?tid=1206483202#/learn/announce</a></p>
<ul>
<li>有公式套公式，多数题目要分情况讨论；</li>
<li>浮点数比较大小不能使用==，要看其差值是否小于某一极小值。</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>完美立方、生理周期、称硬币(真假)、熄灯问题</code></p>
<p>基于逐个尝试答案的一种问题求解策略。合理缩小范围以减少计算量。</p>
<p><em>称硬币 ABCD EFGH；ABCI EFJK；ABIJ EFGH</em></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><code>求阶乘、汉诺塔问题、N皇后，逆波兰表达式、表达式求值，上台阶/爬楼梯、放苹果、算24</code></p>
<p>一个函数调用（栈）其自身。</p>
<p>用途：</p>
<ol>
<li>替代多重循环；</li>
<li>解决本来就是用递归形式定义的问题；</li>
<li>将问题分解为规模更小的子问题进行求解。</li>
</ol>
<h2 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h2><p><code>二分查找函数、二分法求方程的根（区间内单调才可求）、一对数、农夫和奶牛</code></p>
<ul>
<li>数组必须为有序数组；</li>
<li>为防止(L+R)过大溢出，应将中间元素下标设置为$mid = L + \frac{R - L}{2}$。</li>
</ul>
<p>一般题解方法：</p>
<ol>
<li>枚举/穷举；</li>
<li>先排序，再进行二分查找；</li>
<li>先排序，使用双指针进行查找遍历。</li>
</ol>
<h2 id="分治（常用递归实现）"><a href="#分治（常用递归实现）" class="headerlink" title="分治（常用递归实现）"></a>分治（常用递归实现）</h2><p><code>称假币、输出前m大的数、求排列的逆序数</code></p>
<p>将一个任务，分成形式和原任务相同，但规模更小的几个部分任务，或只需<strong>选一部分完成</strong>，然后再处理完成后几部分结果，实现整个任务的完成。</p>
<h2 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h2><p><code>数字三角形、最长上升子序列、最长公共子序列、最佳加法表达式、Help Jimmy、滑雪、神奇的口袋、0-1背包问题、分蛋糕</code></p>
<ul>
<li>避免重复计算：数字三角形的记忆递归型动归程序（使用数组存储中间计算）；递归转成递推（利用数组从底层依次向上）。</li>
<li>递推到动规的一般转化方法：递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数的逆过程。</li>
</ul>
<p>动规解题的一般思路：</p>
<ol>
<li>将原问题分解为若干子问题：<ul>
<li>将原问题分解为若干子问题，子问题和原问题形式相同或类似，只是规模变小了；</li>
<li>子问题的解一旦求出就会被保存，因此，每个子问题只需求解一次即可。</li>
</ul>
</li>
<li>确定状态：<br> <em>将与子问题相关的各个变量的一组取值称为一个“状态”。</em><br> 一个状态对应于一个或多个子问题，所谓某个状态下的值，即是该状态所对应的子问题的解。</li>
<li>确定一些初始状态（边界状态）的值；</li>
<li>确定状态转移方程。</li>
</ol>
<p>能用动规解决的问题的特点：</p>
<ul>
<li>问题具有最优子结构特性，即求最优解、最值等问题；</li>
<li>无后效性，即一旦该状态值确定，就可用此值推出下一个状态的值，而无需再使用之前确定该状态的值。</li>
</ul>
<p>动规的两种常用形式：</p>
<ol>
<li>递归型<ul>
<li>优点：直观、易编写；</li>
<li>缺点：会因递归层数深而爆栈、函数调用带来额外时间开销，无法使用滚动数组节省空间。</li>
</ul>
</li>
<li>递推型<br> 效率高，可使用滚动数组节省空间。</li>
</ol>
<h2 id="深度优先搜索："><a href="#深度优先搜索：" class="headerlink" title="深度优先搜索："></a>深度优先搜索：</h2><p><code>城堡问题、踩方格、寻路问题、生日蛋糕</code></p>
<p>在图上寻找路径：从起点出发，选取一条路走，走不通就回退。用栈进行存储。</p>
<p>图的表示方法：</p>
<ul>
<li>二维数组，时间复杂度O(n^2)；</li>
<li>邻接表，时间复杂度O(n+e),e为边的数目。</li>
</ul>
<p>优化：</p>
<ul>
<li>最优性剪枝；</li>
<li>可行性剪枝；</li>
</ul>
<h2 id="广度优先搜索："><a href="#广度优先搜索：" class="headerlink" title="广度优先搜索："></a>广度优先搜索：</h2><p><code>抓住那头牛、迷宫问题、八数码</code></p>
<p><em>对于很多深度优先搜索案例进行最优性剪枝后很像广度优先搜索</em></p>
<p>从起点开始给结点进行分层，按层进行遍历。用队列进行存储，需要大量存储空间。</p>
<h2 id="贪心算法："><a href="#贪心算法：" class="headerlink" title="贪心算法："></a>贪心算法：</h2><p><code>圣诞老人的礼物、电影节、分配畜栏、放置雷达、钓鱼</code></p>
<a href="/2020/06/04/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="贪心算法">贪心算法</a>

<ul>
<li>每一步行动总是按某种指标选取最优的操作来进行，该指标只看眼前，并不考虑以后可能造成的影响。</li>
<li>贪心算法需要证明其正确性。</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>级联分类器</title>
    <url>/2020/06/04/%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    <content><![CDATA[<h1 id="级联分类器"><a href="#级联分类器" class="headerlink" title="级联分类器"></a>级联分类器</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB.png" alt="级联分类"></p>
<p>级联分类器是将多个强分类器连接在一起进行操作，每一个强分类器都由若干个弱分类器加权构成。</p>
<p>级联分类器，每一个强分类器都是对负样本更敏感，使得每次被强分类器拒绝的，都几乎是负样本。<br>因此，通过所有强分类器的，基本上可以认定为正样本。</p>
<h1 id="强-弱分类器"><a href="#强-弱分类器" class="headerlink" title="强/弱分类器"></a>强/弱分类器</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Boosting%E5%88%86%E7%B1%BB%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Boosting分类器示意图"></p>
<p>将每轮得到的最佳弱分类器按照一定方法(Boosting)提升为强分类器。</p>
<h2 id="弱分类器："><a href="#弱分类器：" class="headerlink" title="弱分类器："></a>弱分类器：</h2><p>训练一个弱分类器，即在当前权重分布下，确定f的最优阈值，使该弱分类器对所有训练样本的分类误差最低。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%BC%B1%E5%88%86%E7%B1%BB%E5%99%A8%E8%AF%86%E5%88%AB%E4%BA%BA%E8%84%B8.png" alt="弱分类器识别人脸"></p>
<ul>
<li>在海量特征中，选取一个特征，能够区分是否为人脸，使错误率最低；</li>
<li>能够以<strong>稍低于50%的错误率</strong>来区分人脸和非人脸图像；</li>
</ul>
<hr>
<h1 id="Adaboost分类器"><a href="#Adaboost分类器" class="headerlink" title="Adaboost分类器"></a>Adaboost分类器</h1><p><em>Adaboost是一种基于级联分类模型的分类器。</em></p>
<p>adaboost训练：</p>
<ol>
<li>初始化数据权值分布；</li>
<li>遍历阈值p：选取最小阈值p——t；</li>
<li>计算权重；</li>
<li>更新训练数据权重分布。</li>
</ol>
<p>训练终止条件：</p>
<ol>
<li>for循环次数；</li>
<li>p小于设定阈值。</li>
</ol>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>分类器</tag>
      </tags>
  </entry>
  <entry>
    <title>线程&amp;进程</title>
    <url>/2020/07/07/%E7%BA%BF%E7%A8%8BVS%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程与线程、协程"><a href="#进程与线程、协程" class="headerlink" title="进程与线程、协程"></a>进程与线程、协程</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%BC%AB%E7%94%BB.jpg" alt="进程和线程漫画"></p>
<h2 id="进程：最小资源管理单元"><a href="#进程：最小资源管理单元" class="headerlink" title="进程：最小资源管理单元"></a>进程：最小资源管理单元</h2><p>CPU处理器运行程序(一系列指令)，随后，为方便多任务处理，进行多任务分配，即进程。<br>操作系统为了执行进程间的切换，会维护着一张进程表ProcessTable，每个进程占用一个进程表项。</p>
<p>进程存放：</p>
<ul>
<li>地址空间(存放程序正文和数据等，包括下列所述)；</li>
<li>全局变量；</li>
<li>打开文件；</li>
<li>子进程；</li>
<li>即将发生的定时器；</li>
<li>信号和信号处理程序；</li>
<li>账号信息；</li>
</ul>
<ul>
<li>进程位于内核空间中，可被系统调用；</li>
<li>进程是基于时钟进行中断的；</li>
<li>一个进程的内存空间和其它资源共享，即父进程调用子进程时内存空间共享；</li>
<li>多个进程共享物理内存、磁盘、打印机和其它资源。</li>
</ul>
<p>创建进程：</p>
<ol>
<li>系统初始化init；</li>
<li>正在运行的程序执行创建进程的系统调用fork；</li>
<li>用户请求创建一个新建成(如打开app)；</li>
<li>初始化一个批处理工作。</li>
</ol>
<p><em>父进程和子进程具有相同的内存映像等基本环境<code>copy-on-write</code>，但是其内存地址不同。</em></p>
<p>退出进程：</p>
<ol>
<li>正常退出；</li>
<li>错误退出；</li>
<li>严重错误，这里指app自行处理错误，不交给系统；</li>
<li>被其它进程杀死kill。</li>
</ol>
<p>进程的状态：</p>
<ul>
<li>运行态，进程实际占用CPU时间片运行时；</li>
<li>就绪态，可运行，但因其它进程正在运行而处于就绪状态；</li>
<li>阻塞态，除非某种外部事件发生，否则进程不能运行pause。</li>
</ul>
<p>进程的状态切换：<br>  <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png" alt="进程状态切换"></p>
<ul>
<li>进程因为等待输入而阻塞；</li>
<li>调度程序选择另一个进程；</li>
<li>调度程序选择一个进程开始运行；</li>
<li>出现有效的输入。</li>
</ul>
<p>中断处理和调度过程：</p>
<ol>
<li>硬件压入堆栈程序计数器等；</li>
<li>硬件从中断向量(与IO类相关联)装入新的程序计数器；</li>
<li>汇编语言过程保存寄存器的值；</li>
<li>汇编语言过程设置新的堆栈；</li>
<li>C中断服务器运行（典型的读和缓存写入）；</li>
<li>调度器决定下面那个程序先运行；</li>
<li>C过程返回至汇编代码；</li>
<li>汇编语言过程开始新的当前进程。</li>
</ol>
<h2 id="线程：最小执行单元"><a href="#线程：最小执行单元" class="headerlink" title="线程：最小执行单元"></a>线程：最小执行单元</h2><p>类似于“车间中的工人”，用于协同完成一个进程任务。<br>线程是CPU上执行调度的实体。</p>
<p>线程存放：</p>
<ul>
<li>程序计数器，用来记录要执行哪条指令；</li>
<li>寄存器，保存线程当前正在使用的变量；</li>
<li>堆栈，记录程序的执行路径；</li>
<li>线程状态。</li>
</ul>
<ul>
<li>线程可位于内核空间，也可位于用户空间(抢占式调度)；</li>
<li>内核空间的线程也是基于时钟中断的，用户空间中的线程无法利用时钟中断强行让线程让出CPU；</li>
<li>用户空间中的同一进程中的所有线程拥有完全一致的地址空间，可共享同样的全局变量；</li>
<li>用户空间中的线程可以读取、写入、擦除另一个线程的堆栈；</li>
</ul>
<p>线程的实现：</p>
<ul>
<li>在用户空间实现线程，允许进程定制程序调度算法，效率高(不需切换到内核，不需上下文切换，不需对内存高速缓存进行刷新)；</li>
<li>在内核空间中实现线程，能够对线程进行阻塞调用，可避免缺页中断问题，能够使用轮转调度方式调度线程；</li>
<li>在用户和内核空间中混合实现线程：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%94%A8%E6%88%B7_%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="用户_内核线程多路复用"><ul>
<li>程序员可以自由控制用户线程和内核线程的数量；</li>
<li>内核只识别内核级线程，并对其进行调度；</li>
<li>内核级线程会被过个用户级线程多路复用。</li>
</ul>
<em>线程创建后，通常返回一个线程标识符，该标识符为新线程的name。</em></li>
</ul>
<p>线程的状态及转换：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p>
<p>线程的优势：</p>
<ul>
<li>多线程间共享同一块地址空间和所有可用数据的能力；</li>
<li>线程比进程更<strong>轻量级</strong>，比进程更容易创建和销毁，可快10-100倍；</li>
<li>若多个线程都是CPU密集型的，不能获得性能上的增强；</li>
<li>如果存在大量的计算和IO处理，拥有多线程能彼此重叠进行，会加快app的执行速度。</li>
</ul>
<h3 id="多线程的web服务器"><a href="#多线程的web服务器" class="headerlink" title="多线程的web服务器"></a>多线程的web服务器</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="多线程的web服务器"></p>
<ol>
<li>调度线程从网络中读入工作请求；</li>
<li>在调度线程检查完请求后，选择一个空闲的/阻塞的工作线程处理请求；</li>
<li>将消息的指针写入每个线程关联的特殊字中；</li>
<li>调度线程唤醒正在睡眠中的工作线程，将工作线程的状态从阻塞态变为就绪态。</li>
<li>工作线程检查请求是否在web页面的高速缓存中；</li>
<li>若不在高速缓存中，调用一个read操作从磁盘中读取页面并阻塞线程，直到磁盘操作完成。</li>
</ol>
<p><em>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显示的保存或重新装入相应的计算状态。每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，该类设计称为有限状态机<code>finite-state machine</code>。</em></p>
<table>
<thead>
<tr>
<th align="center">模型</th>
<th align="center">特性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单线程</td>
<td align="center">无并行性，性能较差，阻塞系统调用</td>
</tr>
<tr>
<td align="center">多线程</td>
<td align="center">并行性，阻塞系统调用</td>
</tr>
<tr>
<td align="center">有限状态机</td>
<td align="center">并行性，非阻塞系统调用、中断</td>
</tr>
</tbody></table>
<h3 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h3><p>为了使编写可移植线程程序成为可能，IEEE在IEEE标准1003.1c中定义了线程标准。线程包被定义为Pthreads。</p>
<p>POSIX线程/pthreads是一种独立于语言而存在的执行模型，以及并行执行模型。它允许程序控制时间上重叠多个不同的工作流程/线程。</p>
<h2 id="协程co-routine-纤程fiber"><a href="#协程co-routine-纤程fiber" class="headerlink" title="协程co-routine/纤程fiber"></a>协程co-routine/纤程fiber</h2><p>一个线程可拥有多个协程(串行)，由程序控制，在用户态执行。</p>
<ul>
<li>协程位于用户空间，进行的是非抢占式调度；</li>
<li>适用于事件驱动的编程。</li>
</ul>
<p>协程是一个特殊的函数，该函数可在某个地方挂起，并且可以重新在挂起处继续运行。</p>
<hr>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池，即创建一些线程，它们的集合就称为线程池。使用线程池可以很好的提高性能，线程池在<strong>系统启动时即创建</strong>大量空闲的线程。<br>程序将一个任务传给线程池，线程池就会启动一个任务传给线程池，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>
<p>线程池的<strong>工作机制：</strong></p>
<ul>
<li>在线程池的编程模式下，任务是提交给线程池，而不是直接提交给某个线程；</li>
<li>线程池在拿到任务后，就在内部寻找是否有空闲的进程，如果有，则将任务交给某个空闲的线程；</li>
<li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</li>
</ul>
<p>ExecutorService是Java提供的用于管理线程池的类，该类的两个作用：控制线程数量、重用线程。</p>
<p>线程池的<strong>实现</strong>：</p>
<ul>
<li>Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没之前建立的线程，有就直接使用，没有就建一个新的线程加入池中；缓存型池子通常用于执行一些生存期很短的异步型任务。</li>
<li>Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行该线程。</li>
<li>Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO、LIFO、优先级)执行。</li>
</ul>
<p>定长线程池的大小最好根据系统资源进行设置，如Runtime.getRuntime().availableProcessors()。</p>
<p>线程池的优势：</p>
<ul>
<li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li>
<li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li>
<li>方便线程并发数的管控，因为线程无限制的创建，可能会导致内存占用过多而产生内存溢出OOM，并会造成CPU过度切换；</li>
<li>可延时定时线程池。</li>
</ul>
<h2 id="自定义线程池：ThreadPoolExecutor和BlockingQueue连用"><a href="#自定义线程池：ThreadPoolExecutor和BlockingQueue连用" class="headerlink" title="自定义线程池：ThreadPoolExecutor和BlockingQueue连用"></a>自定义线程池：ThreadPoolExecutor和BlockingQueue连用</h2><p>自定义线程池，可使用ThreadPoolExecutor类创建，通过其构造方法来创建线程池。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">- corePoolSize：线程池基本大小，当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize。除了利用提交新任务来创建和启动线程（按需构造），也可通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。</span><br><span class="line">- maximumPoolSize：线程池最大大小，线程池所允许的最大线程个数。当队列已满，且已创建的线程数小于maximumPoolSize，线程池会创建新的线程来执行任务。但对于无界队列，可忽略该参数。</span><br><span class="line">- keepAliveTime：线程存活保持时间，当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</span><br><span class="line">- workQueue：任务队列，用于传输和保存等待执行任务的阻塞队列。</span><br><span class="line">- threadFactory：线程工厂，用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</span><br><span class="line">- handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</span><br><span class="line">*&#x2F;</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池使用BlockingQueue原因：</strong></p>
<ul>
<li>阻塞队列可保证任务队列中没有任务时，阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源；</li>
<li>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行，使线程不至于一直占用cpu资源；</li>
</ul>
<p>  <em>线程执行完成任务后通过循环再次从任务中取出任务进行执行：<code>while (task != null || (task = getTask()) != null) {}</code></em></p>
<h2 id="缓冲队列-BlockingQueue"><a href="#缓冲队列-BlockingQueue" class="headerlink" title="缓冲队列 BlockingQueue"></a>缓冲队列 BlockingQueue</h2><p>BlockingQueue是双缓冲队列，其内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。<br>在保证并发安全的同时，提高了队列的存取效率。</p>
<ul>
<li>ArrayBlockingQueue(int i)：规定大小的BlockingQueue，其构造必须指定大小，其所含对象是FIFO顺序排列；</li>
<li>LinkedBlockingQueue()：大小不固定，其构造时可指定大小，不指定时由Integer.MAX_VALUE决定，其所含对象是FIFO顺序排列</li>
<li>PriorityBlockingQueue()：大小不固定，其构造时可指定大小，不指定时由Integer.MAX_VALUE决定，其所含对象由对象的自然顺序或构造函数的Comparator决定；</li>
<li>SynchronizedQueue()：特殊的BlockingQueue，对其操作必须时放和取交替完成。</li>
</ul>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384</a></li>
<li><a href="https://www.cnblogs.com/jiawen010/p/11855768.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiawen010/p/11855768.html</a></li>
<li><a href="https://www.jianshu.com/p/7726c70cdc40" target="_blank" rel="noopener">https://www.jianshu.com/p/7726c70cdc40</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>自编码机</title>
    <url>/2020/06/23/%E8%87%AA%E7%BC%96%E7%A0%81%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.png" alt="编码与解码"></p>
<p>左侧将原始图像编码为向量，右侧通过解卷积层“解码”，还原回原始图像。</p>
<p><em>可以用尽可能多的图像来训练网络，当保存了某张图像的编码向量，可用解码组件重建。</em></p>
<h1 id="经典自编码机VAE"><a href="#经典自编码机VAE" class="headerlink" title="经典自编码机VAE"></a>经典自编码机VAE</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE.png" alt="VAE"></p>
<p><em>通过编码向量，创造潜在向量，或实现连续、平滑的潜在空间表示。</em></p>
<p>通过给编码网络添加一个约束，使其所产生的潜在向量大体上服从单位高斯分布。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E7%BA%A6%E6%9D%9F.png" alt="VAE约束"></p>
<p>如图，只需从单位高斯分布中采样出一个潜在向量，并将其传递到解码器，就可以生成一张新的图像了。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E9%87%87%E6%A0%B7.png" alt="VAE采样"></p>
<p>基本思路：</p>
<ul>
<li>假定输入数据的数据集D的分布完全由一组隐变量z操控，并且，该组隐变量间相互独立且服从高斯分布；</li>
<li>VAE让encoder学习输入数据的隐变量模型，即学习该组隐变量的高斯概率分布的参数：隐变量高斯分布的均值$\mu$和方差$\theta$的$log$值；</li>
<li>隐变量z通过对参数的正态分布中采样得到：$z \sim N(\mu, \theta)$；</li>
<li>通过decoder对隐变量进行解码，重构函数。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E5%88%86%E5%B8%83.png" alt="VAE分布"></p>
<p>总体目标函数：<br>    $\mathcal{L}(x,\widehat{x}) + \sum_j KL(q_j(z|x)||p(z))$</p>
<p>误差：误差项精确度及潜在变量在单位高斯分布上的契合程度。</p>
<ul>
<li>生成误差，用以衡量网络重构图像精准度的均方误差；</li>
<li>潜在误差，用以衡量潜在变量在单位高斯分布上的契合程度的KL散度。</li>
</ul>
<h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h2><p><em>VAE模型并没有真正的用$z \sim N(\mu,\theta)$来采样得到z变量：因为采样后无法对$(\mu,\theta)$进行求导。</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE_Reparameterization.png" alt="VAE_Reparameterization"></p>
<p>一般先采样一个标准的高斯分布/正态分布$\epsilon \sim N(0,1)$，然后令$z=\mu+\epsilon*\theta$，这样得到的z就服从$z \sim N(\mu,\theta)$，同时也可正常对$(\mu,\theta)$求导。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>优点：遵循“编码-解码”模式，能直接将生成的图像同原始图像进行对比；</li>
<li>缺点：直接采用均方误差，导致其神经网络倾向生成较为模糊的图像。</li>
</ul>
<h1 id="VAE和GAN的区别"><a href="#VAE和GAN的区别" class="headerlink" title="VAE和GAN的区别"></a>VAE和GAN的区别</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE_vs_GAN.png" alt="VAE_vs_GAN"></p>
<p>GAN是VAE后半部分再加上一个鉴别网络，导致完全不同的训练方式。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_40955254/article/details/82315224" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315224</a></li>
<li><a href="https://blog.csdn.net/weixin_40955254/article/details/82315909?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315909?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="网络七层协议-OSI七层模型"><a href="#网络七层协议-OSI七层模型" class="headerlink" title="网络七层协议/OSI七层模型"></a>网络七层协议/OSI七层模型</h1><ul>
<li>应用层<ul>
<li>用户接口、应用程序，<strong>网络进程</strong>访问应用层；</li>
<li>Application典型设备：网关；</li>
<li>典型协议、标准、应用：TELNET、FTP、HTTP、DNS；</li>
</ul>
</li>
<li>表示层<ul>
<li>数据表示、压缩、加密presentation，应用层数据的<strong>格式转化</strong>；</li>
<li>典型设备：网关；</li>
<li>典型协议、标准、应用：ASCLL、PICT、TIFF、JPEG｜MPEG；</li>
<li>表示层相当于一个东西的表示，表示的一些协议，如图片、声音、视频MPEG；</li>
</ul>
</li>
<li>会话层<ul>
<li>会话的建立和结束，<strong>应用程序间</strong>的会话；</li>
<li>典型设备：网关；</li>
<li>典型协议、标准、应用：RPC、SQL、NFS、X WINDOWS、ASP；</li>
</ul>
</li>
<li>传输层<ul>
<li>主要功能：端到端控制Transport，<code>网段</code>传输；</li>
<li>典型设备：网关；</li>
<li>典型协议、标准、应用：<strong>TCP</strong>、<strong>UDP</strong>、SPX；</li>
<li>错误检测和<strong>恢复</strong>：海明码；</li>
</ul>
</li>
<li>网络层<code>host-to-network</code>：IP头-&gt;源地址SIP-&gt;目标地址DIP-&gt;”DLL_Data”<ul>
<li>主要功能：路由、寻址NetWork，<code>数据包</code>传输；</li>
<li>典型设备：路由器Router；<ul>
<li>路由表<code>route</code>：目标网络、端口、距离(路径选择)；</li>
</ul>
</li>
<li>典型协议、标准、应用：<strong>IP</strong>、IPX、APPLETALK、ICMP、<strong>ARP、逆地址解析协议RARP</strong>；</li>
</ul>
</li>
<li>数据链路层：前导符_8-&gt;目标地址DMAC_6-&gt;源地址SMAC_6-&gt;长度_2-&gt;Data-&gt;FCS_4<ul>
<li>主要功能：保证无差错的疏忽链路的data link，<code>帧</code>传输；</li>
<li>典型设备：交换机、网桥、网卡；<ul>
<li>交换机各接口拥有各自冲突域；</li>
<li>同一广播域；</li>
<li>通过加压等手段，解决电流不分压问题；</li>
</ul>
</li>
<li>典型协议、标准、应用：802.2、802.3ATM、HDLC、FRAME RELAY；</li>
<li>错误检测：奇偶校验；CRC冗余校验、</li>
</ul>
</li>
<li>物理层<ul>
<li>主要功能：传输比特流Physical，二进制<code>位</code>传输；</li>
<li>典型设备：集线器、中继器；<ul>
<li>集线器特点：<ul>
<li>同一冲突域：CSMA/CD载波侦听多路访问控制；</li>
<li>同一广播域：电流扩散特性；</li>
<li>所有设备共享相同带宽：并联分压；</li>
</ul>
</li>
</ul>
</li>
<li>典型协议、标准、应用：V.35、EIA/TIA-232。</li>
</ul>
</li>
</ul>
<h1 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h1><p>TCP/IP协议是一个<strong>协议簇</strong>，包含很多协议，如UDP。<br>TCP/IP<strong>协议集/协议族</strong>包括：应用层、传输层、网络层、网络访问层/数据链路层。</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>Internet层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><code>Transmission Control Protocol</code>，传输控制协议，是<strong>面向连接</strong>的协议，在<strong>收发数据前必须建立起可靠的连接</strong>。<br>一个TCP连接必须要经过<strong>三次握手</strong>才能建立，经过<strong>四次挥手</strong>断开连接，大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互。</p>
<p>TCP报头：原端口_16位，目标端口_16，序列号_32，TCP头长度_4，reserved_6，控制代码_6，窗口大小_16，偏移量_16，校验和_16，选项_32(可选)。<br><em>TCP最小报头长度为20字节。</em></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol>
<li>主机A通过向主机B发送一个<strong>含有同步序列号SYN的标识位的数据段</strong>给主机B，向主机B请求建立连接。<br>通过该数据段，主机A告诉主机B两件事：我想要和你通信；你可以用那个序列号作为起始数据段来回应我。</li>
<li>主机B收到主机A的请求后，用一个<strong>带有确认应答ACK和同步序列号SYN标识位的数据段</strong>响应主机A。<br>主机B回应主机A两件事：我已经收到你的请求，你可以传输数据了；你要用哪个序列号作为起始数据段来回应我。</li>
<li>主机A收到回应的数据段后，再发送一个<strong>确认应答ACK</strong>，确认已收到主机B的数据段“我已收到回复，我现在要开始传输实际数据了”。</li>
</ol>
<p>三次握手的特点：</p>
<ul>
<li>没有应用层的数据；</li>
<li>SYN这个标识位只有在TCP建立连接时才会被置为1，握手完成后SYN标识位被置为0。</li>
</ul>
<p>ACK：TCP报头的控制位之一，对数据进行确认，确认由目的端发出，告诉发送端某序列号之前的数据段都收到了。<br>    如，确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时，确认才有效；当ACK=0时，确认号无效，要求重传数据，保证数据的完整性。<br>SYN：同步序列号，TCP建立连接时，将该位置置为1。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol>
<li>当主机A完成数据传输后，将<strong>控制位FIN置为1</strong>，提出停止TCP连接的请求；</li>
<li>主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将要关闭，将<strong>ACK置为1</strong>；</li>
<li>主机B提出反方向的关闭请求，将<strong>FIN置为1</strong>；</li>
<li>主机A对主机B的请求进行确认，将<strong>ACK置为1</strong>，TCP连接关闭。</li>
</ol>
<p>FIN：发送端完成发送任务后，当TCP完成数据传输需要断开时，提出断开连接的一方将该位置为1。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><code>User Data Protocol</code>，用户数据报协议：</p>
<ul>
<li>UDP是一个<strong>非连接的协议</strong>，传输数据之前源端和终端不建立连接，当它想传送时就简单的去抓取来自应用程序的数据，并尽可能快的将其扔到网络上。<ul>
<li>发送端，UDP传送数据的速度仅仅受应用程序生成数据的速度、计算机的能力、传输带宽的限制；</li>
<li>接收端，UDP将每个消息段放在队列中，应用程序每次从队列中读取一个消息段；</li>
</ul>
</li>
<li>由于传输数据不建立连接，因此不需要维护连接状态(包括收发状态等)；<ul>
<li>一台服务器可同时向多个客户机传输相同的消息；</li>
</ul>
</li>
<li>UDP信息报的标题只有8个字节，信息报的额外开销小；</li>
<li>吞吐量不受拥塞控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制；</li>
<li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，主机不需要维持复杂的链接状态表；</li>
<li>UDP<strong>面向报文</strong>，发送方的UDP对应用程序交下来报文，在添加首部后就向下交付给IP层，既不拆分，也不合并，保留这些报文的边界。<ul>
<li>应用程序需要选择合适的报文大小。</li>
</ul>
</li>
</ul>
<p>UDP报头：源端口_16，目的端口_16，长度_16，校验和_16位。</p>
<h2 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs. UDP"></a>TCP vs. UDP</h2><p>TCP：一种<strong>流模式</strong>的协议，面向连接、传输可靠(保证数据正确性，保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销大(时间&amp;系统资源)，TCP程序结构较简单。<br>UDP：一种<strong>数据报模式</strong>的协议，面向非连接、传输不可靠、用于传输少量数据(数据报模式)、速度快，对系统资源占用少，UDP程序结构较简单。</p>
<h1 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h1><h2 id="Hypertext-Transfer-Protocol-超文本传输协议"><a href="#Hypertext-Transfer-Protocol-超文本传输协议" class="headerlink" title="Hypertext Transfer Protocol 超文本传输协议"></a>Hypertext Transfer Protocol 超文本传输协议</h2><p>Http是建立在TCP协议上的一种应用，是Web联网的基础。</p>
<p>核心：<strong>客户端发送的每次请求都需要服务器发送响应，在请求结束后，主动释放连接</strong>。</p>
<ul>
<li>从建立连接到关闭连接的过程称为<code>一次连接</code>。</li>
<li>Http连接是一种<code>**短连接**</code>，即要保持客户端程序的在线状态，需要不断的向服务器发起连接请求；<ul>
<li>若服务器长时间无法收到客户端的请求，则认为客户端“下线”；</li>
<li>若客户端长时间无法收到服务器的回复，则认为网络已经断开。</li>
</ul>
</li>
</ul>
<ul>
<li>Http 1.0<ul>
<li>客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，自动释放连接。</li>
<li>生命周期通过request界定，一个request对应一个response。</li>
</ul>
</li>
<li>Http 1.1<ul>
<li>可在一次连接中处理多个请求，并且多个请求可以交叠进行，不需要等待一个请求结束再发送下一个请求。</li>
<li>添加一个keep-alive，可将多个http请求合并为一个，即在一个http链接中，可以发送多个request，接受对应多个response。</li>
</ul>
</li>
</ul>
<p><em>response是被动的，不能主动发起。</em></p>
<h2 id="Hypertex-Transfer-Protocol-over-Secure-Socket-Layer"><a href="#Hypertex-Transfer-Protocol-over-Secure-Socket-Layer" class="headerlink" title="Hypertex Transfer Protocol over Secure Socket Layer"></a>Hypertex Transfer Protocol over Secure Socket Layer</h2><p>https是以安全为目标的http通道，在http下加入SSL层(安全加密)。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/https.jpeg" alt="https"></p>
<ol>
<li>客户端发送https请求，服务器端应非对称加密生成公钥和私钥；</li>
<li>服务端将公钥发送给客户端，服务端保存私钥；</li>
<li>客户端拿到公钥，生成一个密钥(客户端和服务端通信的🔑)；</li>
<li>客户端用公钥对密钥进行加密，发送给服务器；</li>
<li>服务器拿到客户端发送的加密后的密钥，用私钥进行解密，双方均获得通信的🔑。</li>
</ol>
<p>https与http的区别：</p>
<ul>
<li>https：需要<strong>ca申请证书</strong>，<strong>端口号443</strong>，https是由<code>ssl+http</code>构建的可进行<strong>加密传输、身份认证</strong>的网络协议。</li>
<li>http：超文本传输协议，明文信息传输，<strong>端口号80</strong>，http的连接是<strong>无状态</strong>的。</li>
</ul>
<h1 id="Socket-套接字协议"><a href="#Socket-套接字协议" class="headerlink" title="Socket 套接字协议"></a>Socket 套接字协议</h1><p>Socket是通信的基石，是支持TCP/IP协议的网络通信的<strong>基本操作单元</strong>。</p>
<p>Socket是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：</p>
<ul>
<li>连接使用的协议</li>
<li>本地主机的IP地址</li>
<li>本地进程的协议端口</li>
<li>远地主机的IP地址</li>
<li>远地进程的协议端口</li>
</ul>
<p>解决问题：</p>
<ul>
<li>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序提供并发服务的问题。</li>
<li>多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。</li>
<li>为了区别不同的应用程序进程和连接，操作系统为应用程序及TCP/IP协议交互提供了Socket接口。</li>
<li>应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，<strong>实现数据传输的并发服务</strong>。</li>
</ul>
<h2 id="Socket连接的建立"><a href="#Socket连接的建立" class="headerlink" title="Socket连接的建立"></a>Socket连接的建立</h2><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端<code>ClientSocket</code>，另一个运行于服务器端<code>ServerSocket</code>。</p>
<ol>
<li>服务器监听：ServerSocket不定位具体的ClientSocket，而是<strong>处于等待连接的状态</strong>，<strong>实时监控网络状态</strong>，等待客户端的连接请求。</li>
<li>客户端请求：ClientSocket提出连接请求，要连接的目标是ServerSocket。<ol>
<li>ClientSocket必须描述要连接的ServerSocket，指出S而verSocket的地址和端口号；</li>
<li>向ServerSocket提出连接请求。</li>
</ol>
</li>
<li>连接确认：当ServerSocket监听/接收到ClientSocket的连接请求，响应ClientSocket请求。<ol>
<li>建立一个新线程，将ServerSocket的描述发送给客户端；</li>
<li>待客户端确认该描述，双方正式建立连接；</li>
<li>ServerSocket继续处于监听状态，继续接收其它ClientSocket的连接请求。</li>
</ol>
</li>
</ol>
<h2 id="Socket连接-vs-TCP连接"><a href="#Socket连接-vs-TCP连接" class="headerlink" title="Socket连接 vs. TCP连接"></a>Socket连接 vs. TCP连接</h2><p>创建Socket连接时，可指定使用的传输层协议，当Socket使用TCP协议进行连接时(<strong>默认TCP</strong>)，Socket就是一个TCP连接。<br>当Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。</p>
<p>在实际网络应用中，客户端到服务器间的通信往往需要穿越多个中间节点(路由器、网关、防火墙等)而导致Socket连接中断，因此，<strong>需要通过<code>轮询</code>告诉网络该连接处于活跃状态</strong>。</p>
<h2 id="Socket连接-vs-http连接"><a href="#Socket连接-vs-http连接" class="headerlink" title="Socket连接 vs. http连接"></a>Socket连接 vs. http连接</h2><ul>
<li>Socket连接：服务器可主动向客户端推送数据，保持客户端于服务器数据的实时与同步；</li>
<li>http连接：<code>请求-响应</code>方式，在请求时需要先建立连接，在客户端向服务器发送请求后，服务器端才能回复数据；客户端需要定时向服务器端发送连接请求，使其保持在线状态，同时询问服务器是否有新数据。</li>
</ul>
<h1 id="GET-amp-POST"><a href="#GET-amp-POST" class="headerlink" title="GET &amp; POST"></a>GET &amp; POST</h1><ul>
<li>get使用URL传输；</li>
<li>post使用body传输数据。</li>
</ul>
<h2 id="浏览器中的GET和POST"><a href="#浏览器中的GET和POST" class="headerlink" title="浏览器中的GET和POST"></a>浏览器中的GET和POST</h2><p>浏览器中的非Ajax的Http请求，即从html和浏览器就一直使用的http协议中的GET/POST。</p>
<ul>
<li>用get请求来获取一个html页面/图片/css/js等资源；<ul>
<li>get是读取一个资源，可以对get请求的数据做缓存。</li>
</ul>
</li>
<li>用post来提交一个<form>表单，并得到一个结果的网页；<ul>
<li>不等幂(不能随意多次执行)，页面不能被缓存，如下订单页面。</li>
</ul>
</li>
</ul>
<h2 id="接口中的GET和POST"><a href="#接口中的GET和POST" class="headerlink" title="接口中的GET和POST"></a>接口中的GET和POST</h2><p>指通过浏览器的Ajax api、ios/Android的app发出的http client、Java中的commons-httpclient/okhttp、curl/postman等工具发出的get/post请求。</p>
<p>该get/post不仅能用在前后端的交互中，还能用在后端各个子服务的调用中(即充当一种RPC协议使用)。</p>
<h1 id="session-amp-cookie"><a href="#session-amp-cookie" class="headerlink" title="session &amp; cookie"></a>session &amp; cookie</h1><p>针对http的无状态的特性，无法判断具体哪个用户，因此，设计了Cookie和Session。、</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie存储在客户端，用来记录用户状态，区分用户。<br>一般由服务端将生成的Cookie通过响应返回给客户端，由客户端进行保存。</p>
<ul>
<li>修改Cookie<ul>
<li>相同Key值得到的新的Cookie会<strong>覆盖</strong>旧的Cookie；</li>
<li>覆盖规则是<code>name path</code>和<code>domain</code>等需要与原有的一致。</li>
</ul>
</li>
<li>删除Cookie<ul>
<li>设置Cookie的expires为过去的一个时间点，或<code>maxAge = 0</code>。</li>
</ul>
</li>
</ul>
<p>如何保证Cookie的安全：</p>
<ul>
<li>对Cookie进行加密处理；</li>
<li>只在https上携带Cookie；</li>
<li>设置Cookie为httpOnly，防止跨站脚本攻击。</li>
</ul>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session存储在网络端，需要依赖Cookie机制。<br>服务端生成Session后，返回给客户端，客户端进行存储<code>setCookie:sessionID</code>；<br>再次请求时，客户端将Cookie发送给服务端，服务端解析出<code>SessionID</code>，根据<code>SessionID</code>判断当前用户。</p>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>Http状态码是一个客户发出请求的时候，web服务器返回给客户的一个状态回应。</p>
<ul>
<li><code>1xx</code>信息代码；</li>
<li><code>2xx</code>成功代码；</li>
<li><code>3xx</code>重定向；</li>
<li><code>4xx</code>客户端错误，可以是web浏览器、curl命令、postman等其它服务器测试软件发出的请求等；</li>
<li><code>5xx</code>服务器错误，服务器发生错误或服务器识别出无法处理的请求。</li>
</ul>
<h2 id="客户端错误及处理"><a href="#客户端错误及处理" class="headerlink" title="客户端错误及处理"></a>客户端错误及处理</h2><ul>
<li>400请求错误，服务器无法理解请求，发送到服务器的请求具有无效语法；<ul>
<li>检查http请求中可能发生的语法错误，确保请求的URL或Post语法没有错误；</li>
<li>尝试清楚浏览器的cookie和cache再尝试；</li>
<li>尝试更新或更改浏览器，可能是浏览器版本太老或其它问题。</li>
</ul>
</li>
<li>401未经授权的错误，访问系统需要身份验证，而在请求中没有给予正当的认证凭据token等；<ul>
<li>提供正确的身份验证或凭据(账号密码或token等)。</li>
</ul>
</li>
<li>403禁止访问，客户端无权访问该内容，服务器拒绝对访问所请求的文件给出正确的响应；<ul>
<li>当用户没有访问所请求资源的权限时，通常会发生403错误；</li>
<li>通常可能是客户端IP、Agent等被web服务器拒绝访问，比如触发了WAF、反扒策略等；</li>
<li>可通过修改Agent内容、更换IP等来解决。</li>
</ul>
</li>
<li>404文件找不到，用户可与服务器通信，并且服务器也想将资源发送给用户，但是无法找到用户请求的资源；<ul>
<li>如果使用的是浏览器，还可能是服务器无法识别该URL；</li>
<li>检查是否犯了类型错误，文件是否存在该目录下，是否已移动或删除。</li>
</ul>
</li>
<li>408请求超时，<ul>
<li>当服务器关闭连接时会发送此响应，因为客户端需要很长时间才能发送请求；</li>
<li>当客户端连接速度较慢或服务器存在巨大负载时会发生；</li>
<li>即使没有客户端先前的任何请求，此错误响应也经常由服务器发送，代表服务器希望关闭此未使用的连接。</li>
</ul>
</li>
<li>429请求太多，用户在给定时间内发送了太多请求，通过被限制速率；<ul>
<li>等待一段时间，然后重试或阅读与API访问限制有关文档来解决。</li>
</ul>
</li>
</ul>
<h2 id="服务器错误及处理"><a href="#服务器错误及处理" class="headerlink" title="服务器错误及处理"></a>服务器错误及处理</h2><ul>
<li>500内部服务器错误，服务器遇到错误，不知道如何处理；<ul>
<li>通常是由服务器配置错误导致，需要查询服务器详细的错误日志，或相关应用服务器的日志，具体问题具体解决。</li>
</ul>
</li>
<li>502错误网关，服务器在工作以获取处理请求所需的另一台服务器的响应(接口、数据库等)时得到的响应无效；<ul>
<li>客户端发送请求的服务器是代理服务器，需要从另一台服务器获取数据；</li>
<li>通常是服务器配置错误，缺少软件包或不正确的负载均衡服务器可能会导致；</li>
</ul>
</li>
<li>503服务不可用，服务器由于某些原因而处于维护或关闭状态，或服务器过载且无法处理请求；<ul>
<li>若服务器未关闭，可能是服务器资源(如CPU ram或带宽)无法处理流量，需要重新配置任一服务器增加资源允许更过流量，或进行优化；</li>
</ul>
</li>
<li>504网关超时，当服务器充当网关或代理服务器且无法在规定时间段内从代理服务器获得响应；<ul>
<li>主要原因是父服务器负载严重，由于位置或带宽较慢，服务器间存在大量延迟。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1yb41157bj?from=search&amp;seid=2308486019812769228" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yb41157bj?from=search&amp;seid=2308486019812769228</a></li>
<li><a href="https://www.jianshu.com/p/a9a960677508" target="_blank" rel="noopener">https://www.jianshu.com/p/a9a960677508</a></li>
<li><a href="https://blog.csdn.net/u013967628/article/details/85210036" target="_blank" rel="noopener">https://blog.csdn.net/u013967628/article/details/85210036</a></li>
<li><a href="https://www.jianshu.com/p/afb516bc4519" target="_blank" rel="noopener">https://www.jianshu.com/p/afb516bc4519</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/06/04/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="贪心算法-贪婪算法"><a href="#贪心算法-贪婪算法" class="headerlink" title="贪心算法/贪婪算法"></a>贪心算法/贪婪算法</h1><p>贪心算法，在每一个选择过程中都选择<strong>当前最优解</strong>，从而希望最终结果达到最优的算法。</p>
<h2 id="算法实现步骤："><a href="#算法实现步骤：" class="headerlink" title="算法实现步骤："></a>算法实现步骤：</h2><ol>
<li>创建数学模型来描述问题；</li>
<li>把求解的问题<strong>分成若干个子问题</strong>；</li>
<li>对每一子问题求解，得到子问题的<strong>局部最优解</strong>；</li>
<li>把子问题的解局部最优解合成所求问题的一个解。</li>
</ol>
<p><strong>贪心算法的实现，要根据具体问题具体分析。</strong></p>
<h2 id="常用解决的问题："><a href="#常用解决的问题：" class="headerlink" title="常用解决的问题："></a>常用解决的问题：</h2><ul>
<li>贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码、旅行推销员问题等。</li>
<li>对于其它问题，贪心算法一般不能得到我们所要求的答案，常用作辅助算法或直接解决一些要求结果不是特别严格的问题。</li>
<li>一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决该问题的最好方法。</li>
</ul>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>对解决问题具有高效性；</li>
<li>所得结果更接近于最优结果。</li>
</ul>
<h2 id="贪心算法与动态规划的不同"><a href="#贪心算法与动态规划的不同" class="headerlink" title="贪心算法与动态规划的不同"></a>贪心算法与动态规划的不同</h2><ul>
<li>贪心算法要求对每个子问题的解决方案都要做出选择，且不能回退；</li>
<li>动态规划会保存之前的运算结果，并依据以前的结果对当前方案进行选择，可回退。</li>
</ul>
<p>换个思路，就是贪心算法有一个优先级的问题；动态规划则是使用一个数组来进行记录当前方案，会对每一种方法进行尝试。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>金字塔变换</title>
    <url>/2020/05/14/%E9%87%91%E5%AD%97%E5%A1%94%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h1><p>在传统金字塔的基础上，对每一层用不同的参数$\sigma$做高斯模糊，使得每一层金字塔有多张高斯模糊图像，这样的一组图像称为一个$octave$。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94.png" alt="高斯金字塔"></p>
<p>$octave(i+1)$的第一张（从下往上）图像是由$octave(i)$中的倒数第三张图像降采样得到。</p>
<p>高斯金字塔的构建：</p>
<ol>
<li>对图像做不同尺度的高斯模糊；</li>
<li>对图像做降采样(隔点采样)。</li>
</ol>
<p>金字塔的层数根据图像的原始大小和塔顶图像的大小共同决定。<br>为使其尺度体现连续性，高斯金字塔在简单降采样的基础上添加了高斯滤波。</p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>高斯模糊是一种图像滤波器，使用正态分布(高斯函数)计算模糊模板，并使用该模板与原图像做卷积运算，达到模糊图像的目的。</p>
<p>每个像素的值都是周围相邻像素值的加权平均：原始像素的值有最大的高斯分布值，具有最大的权重，相邻像素随着距离原始像素越来越远，其权重也越来越小。</p>
<p>优点：</p>
<ul>
<li>比其它的均衡模糊滤波器更好的保留了边缘效果。<br>缺点：</li>
<li>因模板矩阵的关系而造成边缘图像缺失，$\theta$越大，缺失像素越多，丢弃模板会造成黑边；</li>
<li>当$\theta$变大时，高斯模板(高斯核)和卷积运算量将大幅度提高。</li>
</ul>
<p><em>理论上来讲，图像中每个像素点的分布都不为零，即每个像素的计算都需要包含整幅图像。</em><br><em>在实际应用中，在计算高斯函数的离散近似时，在大概$3\theta$距离之外的像素都可以看作不起作用，即高斯模板矩阵的大小$(6\theta+1) * (6\theta+1)$。大尺度对应于图像的概貌特征，小尺度对应于图像的细节特征。</em><br><em>为了确保模板矩阵中的元素在[0,1]之间，需将模板矩阵归一化。</em></p>
<h3 id="分离高斯模糊"><a href="#分离高斯模糊" class="headerlink" title="分离高斯模糊"></a>分离高斯模糊</h3><p>高斯函数的可分离性是指使用二维矩阵变换得到的效果可通过在水平方向进行一维高斯矩阵变换加上竖直方向的一维高斯矩阵变换得到。</p>
<p>根据高斯函数的可分离性，可对二维高斯模糊函数进行改进：两次一维的高斯卷积将消除二维高斯矩阵所产生的边缘。</p>
<h1 id="高斯差分金字塔"><a href="#高斯差分金字塔" class="headerlink" title="高斯差分金字塔"></a>高斯差分金字塔</h1><p>高斯差分函数，Difference of Gaussian，简称DoG算子，可产生较强的边缘响应。</p>
<p>在实际计算时，使用<strong>高斯金字塔每组中相邻上下两层图像相减，得到高斯差分图像</strong>，进行极值检测。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/LoG_DoG.jpg" alt="LoG_DoG"></p>
<p>由于高斯差分的计算更加简单，因此常用DoG算子近似替代LoG算子。</p>
<a href="/2020/05/25/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81/" title="高斯拉普拉斯LoG">高斯拉普拉斯LoG</a>

<h1 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94.png" alt="拉普拉斯金字塔"><br>保留所有层在卷积和下采样过程中丢失的高频信息，用于图像恢复。</p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>多尺度变换</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计原则</title>
    <url>/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h1><p>软件实体应当对扩展开放，对修改关闭。当应用的<strong>需求改变</strong>时，在<strong>不修改软件实体的源代码</strong>或二进制代码的前提下，可以<strong>扩展模块的功能</strong>，使满足新的需求。</p>
<p><strong>软件实体</strong>包括：项目中划分出的模块、类与接口、方法。</p>
<h2 id="开闭原则的作用"><a href="#开闭原则的作用" class="headerlink" title="开闭原则的作用"></a>开闭原则的作用</h2><p>OCP是OOP的终极目标，使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。</p>
<ol>
<li>对软件测试的影响：测试时只需对扩展代码进行测试即可。</li>
<li>提高代码的可复用性：粒度越小，被复用的可能性越大；在OOP中，根据原子和抽象编程可提高代码的可复用性。</li>
<li>提高软件的可维护性：稳定性高、延续性强，软件易于开发和维护。</li>
</ol>
<h2 id="开闭原则的实现方法"><a href="#开闭原则的实现方法" class="headerlink" title="开闭原则的实现方法"></a>开闭原则的实现方法</h2><p>可通过“<strong>抽象约束、封装变化</strong>”来实现OCP，即通过接口或抽象类为软件实体定义一个相对稳定的抽象层，<strong>将相同的可变因素封装在相同的具体实现类</strong>中。</p>
<p>因为抽象灵活性好，适应性广，只要抽象的合理，基本可以保持软件架构的稳定。<br>软件中易变的细节可从抽象派生来的实现类进行扩展。当软件需求发生变化时，只需根据需求重新派生一个实现类来扩展即可。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Windows%E6%A1%8C%E9%9D%A2%E4%B8%BB%E9%A2%98%E7%B1%BB%E5%9B%BE.png" alt="Windows桌面主题类图"></p>
<h1 id="里式替换原则LSP"><a href="#里式替换原则LSP" class="headerlink" title="里式替换原则LSP"></a>里式替换原则LSP</h1><p>继承必须确保超类所拥有的性质在子类中仍然成立。</p>
<p>LSP主要阐述了<strong>有关继承的一些原则</strong>，即何时应使用继承，什么时候不应该使用继承，及其中蕴含的原理。<br>LSP是继承复用的基础，反映了<strong>基类与子类间的关系</strong>，是对OCP的补充，是<strong>对实现抽象化的具体步骤的规范</strong>。</p>
<h2 id="里式替换原则的作用"><a href="#里式替换原则的作用" class="headerlink" title="里式替换原则的作用"></a>里式替换原则的作用</h2><ol>
<li>LSP是实现OCP的重要方式之一。</li>
<li>LSP克服了继承中重写父类造成的可复用性变差的缺点。</li>
<li>LSP是动作正确性的保证，即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>
</ol>
<h2 id="里式替换原则的实现方法"><a href="#里式替换原则的实现方法" class="headerlink" title="里式替换原则的实现方法"></a>里式替换原则的实现方法</h2><p>LSP简单来讲，子类可以扩展父类的功能，但不能改变父类原有的功能，即子类继承父类时，除添加新的方法完成新增功能外，<strong>尽量不要重写父类的方法</strong>。</p>
<p><em>重写父类方法，会使整个继承体系的可复用性变差，特别是运用多态频繁时，程序运行出错的概率会非常大。</em></p>
<p>当程序违背了LSP，应取消原来的继承关系，重新设计它们间的关系。</p>
<p><em>鸟一般都会飞行，但新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算几维鸟飞行花费的时间。结果会发生“除零异常”或是“无穷大”。</em><br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%87%A0%E7%BB%B4%E9%B8%9F%E4%B8%8D%E6%98%AF%E9%B8%9F.png" alt="几维鸟不是鸟"></p>
<h1 id="依赖倒置原则DIP"><a href="#依赖倒置原则DIP" class="headerlink" title="依赖倒置原则DIP"></a>依赖倒置原则DIP</h1><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。即<strong>要面向接口编程，不要面向实现编程</strong>。</p>
<p>在软件设计中，细节(具体的实现类)具有多变性，而抽象层(接口或抽象类)相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定。</p>
<p>使用接口或抽象类的目的是<strong>制定好规范和契约</strong>，而不去涉及任何具体的操作，把<strong>展现细节的任务交给其实现类</strong>去完成。</p>
<h2 id="依赖倒置原则的作用"><a href="#依赖倒置原则的作用" class="headerlink" title="依赖倒置原则的作用"></a>依赖倒置原则的作用</h2><p>DIP是实现OCP的重要途径之一，降低了客户与实现模块之间的耦合。</p>
<ul>
<li>DIP可降低类间的耦合性；</li>
<li>DIP可提高系统的稳定性；</li>
<li>DIP可减少并行开发引起的风险；</li>
<li>DIP可提高代码的可读性和可维护性。</li>
</ul>
<h2 id="依赖倒置原则的实现方法"><a href="#依赖倒置原则的实现方法" class="headerlink" title="依赖倒置原则的实现方法"></a>依赖倒置原则的实现方法</h2><ol>
<li>每个类尽量提供接口或抽象类，或者两者均有；</li>
<li>变量的声明类型尽量是接口或抽象类；</li>
<li>任何类都不应该从具体类派生；</li>
<li>使用继承时尽量遵循DIP。</li>
</ol>
<h1 id="单一职责原则SRP-单一功能原则"><a href="#单一职责原则SRP-单一功能原则" class="headerlink" title="单一职责原则SRP / 单一功能原则"></a>单一职责原则SRP / 单一功能原则</h1><p>SRP规定<strong>一个类应该有且仅有一个引起它变化的原因(职责)</strong>，否则，类应该被拆分。</p>
<p>SRP提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p>
<ol>
<li>一个职责的变化可能会削弱/抑制这个类实现其它职责的能力；</li>
<li>当客户端需要该对象的某一个职责时，不得不将其它不需要的职责全部包含进来，从而造成冗余代码或代码的浪费。</li>
</ol>
<h2 id="单一职责的优点"><a href="#单一职责的优点" class="headerlink" title="单一职责的优点"></a>单一职责的优点</h2><p>SRP的核心就是<strong>控制类的粒度大小</strong>，将对象解耦，提高其内聚性。</p>
<ul>
<li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单。</li>
<li>提高类的可读性。复杂性降低，自然其可读性会提高。</li>
<li>提高系统的可维护性。可读性提高，自然更容易维护。</li>
<li>变更引起的风险降低。变更是必然的，若遵守SRP，当修改一个功能时，可显著降低对其它功能的影响。</li>
</ul>
<h2 id="单一职责原则的实现方法"><a href="#单一职责原则的实现方法" class="headerlink" title="单一职责原则的实现方法"></a>单一职责原则的实现方法</h2><p>SRP是最简单但又最难运用的原则，需要设计人员发现类的不同职责，并将其分离，再封装到不同的类或模块中。<br>发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>
<h1 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h1><p>客户端不应该被迫依赖于它不使用的方法。一个类对另一个类的依赖应该建立在最小的接口上。<br>要为各个类建立它们需要的<strong>专用接口</strong>，而不是试图去建立一个庞大的接口供所有依赖它的类去调用。</p>
<p>ISP要求程序员尽量将臃肿庞大的<strong>接口拆分成更小的和更具体的接口</strong>，让接口中只包含客户感兴趣的方法。</p>
<h2 id="SRP和ISP的区别"><a href="#SRP和ISP的区别" class="headerlink" title="SRP和ISP的区别"></a>SRP和ISP的区别</h2><p>SRP和ISP都是为了提高类的内聚性，降低它们之间的耦合性，体现了封装的思想。</p>
<ul>
<li>SRP注重的是职责；ISP注重的是对接口的依赖；</li>
<li>SRP主要是约束类，针对的是程序中的实现和细节；ISP主要约束接口，主要针对抽象和程序整体框架的构建。</li>
</ul>
<h2 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h2><p>ISP是为了约束接口，降低类对接口的依赖性。</p>
<ul>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>ISP提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>若接口的粒度大小定义合理，能保证系统的稳定性；但如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义多大，灵活性降低，无法提高定制服务，给整体项目带来无法预料的风险。</li>
<li>使用<strong>多个专门的接口能体现对象的层次</strong>，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现该接口时被迫设计冗余的代码。</li>
</ul>
<h2 id="接口隔离原则的实现方法"><a href="#接口隔离原则的实现方法" class="headerlink" title="接口隔离原则的实现方法"></a>接口隔离原则的实现方法</h2><ul>
<li>接口尽量小，但要有限度。一个接口只服务于一个子模块或业务逻辑。</li>
<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>
<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深度了解业务逻辑。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事。</li>
</ul>
<h1 id="迪米特法则LoD-最少知识原则LKP"><a href="#迪米特法则LoD-最少知识原则LKP" class="headerlink" title="迪米特法则LoD / 最少知识原则LKP"></a>迪米特法则LoD / 最少知识原则LKP</h1><p>只与你的直接朋友交谈，不跟“陌生人”说话。<em>朋友可以为当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</em><br>如果两个软件实体无法直接通信，那就不应当发生直接的相互调用，可通过第三方转发该调用。</p>
<p>其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<h2 id="迪米特法则的优点"><a href="#迪米特法则的优点" class="headerlink" title="迪米特法则的优点"></a>迪米特法则的优点</h2><p>LoD要求<strong>限制软件实体间通信的宽度和深度</strong>。</p>
<ul>
<li>降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li>
</ul>
<p>过度使用LoD会使系统产生大量的中介类，从而增加系统的复杂性，使模块间的通信效率降低。<br>在采用LoD时需要<strong>反复权衡</strong>，确保高内聚和低耦合的同时，保证系统的结构清晰。</p>
<h2 id="迪米特法则的实现方法"><a href="#迪米特法则的实现方法" class="headerlink" title="迪米特法则的实现方法"></a>迪米特法则的实现方法</h2><ul>
<li>从依赖者的角度来说，<strong>只依赖应该依赖的对象</strong>。</li>
<li>从被依赖者的角度说，<strong>只暴露应该暴露的方法</strong>。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>在类的划分上，应创建弱耦合的类。</li>
<li>在类的结构设计上，尽量降低类成员的访问权限。</li>
<li>在类的设计上，优先考虑将一个类设置成不变类。</li>
<li>在对其它类的引用上，将引用其它对象的次数降到最低。</li>
<li>不暴露类的属性成员，提供对应的访问器(set和get方法)。</li>
<li>谨慎使用序列化Serializable功能。</li>
</ul>
<h1 id="合成复用原则CRP-组合-聚合复用原则CARP"><a href="#合成复用原则CRP-组合-聚合复用原则CARP" class="headerlink" title="合成复用原则CRP / 组合/聚合复用原则CARP"></a>合成复用原则CRP / 组合/聚合复用原则CARP</h1><p>要求在软件复用时，要尽量<strong>先使用组合或聚合等关联关系</strong>来实现，其次才考虑使用继承关系来实现。</p>
<p>如果要使用继承管理，必须要个遵守LSP。</p>
<p><em>CRP和LSP相辅相成，两者都是OCP的具体实现规范。</em></p>
<h2 id="合成复用原则的重要性"><a href="#合成复用原则的重要性" class="headerlink" title="合成复用原则的重要性"></a>合成复用原则的重要性</h2><p>通常类的复用分为继承复用和合成复用两种</p>
<ul>
<li>继承复用：简单、易实现；<ul>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，又称<code>白箱复用</code>。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变会导致子类的实现发生改变，不利于类的扩展和维护。</li>
<li>限制类复用的灵活性。从父类继承的实现是静态的，在编译时已定义，在运行时不能发生变化。</li>
</ul>
</li>
<li>组合/聚合复用：可将已有对象纳入新对象，使之成为新对象的一部分，新对象可调用已有对象的功能；<ul>
<li>维持了类的封装性。因为成分对象的内部细节是新对象看不见的，又称<code>黑箱复用</code>。</li>
<li>新旧类的耦合度低。复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li>
<li>复用的灵活性高。复用可在运行时动态进行，新对象可动态地引用与成分对象类型相同的对象。</li>
</ul>
</li>
</ul>
<h2 id="合成复用原则的实现方法"><a href="#合成复用原则的实现方法" class="headerlink" title="合成复用原则的实现方法"></a>合成复用原则的实现方法</h2><p>CRP通过将已有对象纳入新对象中，作为新对象的成员对象来实现，新对象可调用已有对象的功能，从而达到复用。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://c.biancheng.net/view/1331.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1331.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>软件设计模式</title>
    <url>/2020/07/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="软件设计模式概述"><a href="#软件设计模式概述" class="headerlink" title="软件设计模式概述"></a>软件设计模式概述</h1><p>GoF合作出版了《设计模式：可复用面向对象软件的基础》，共收录23种设计模式，从此树立了软件设计领域的里程碑，人称GoF设计模式。<br>这23种设计模式的本质是面向对象设计原则的实际应用，是对类的封装性、继承性、多态性，及类的关联关系和组合关系的充分理解。</p>
<p>软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：</p>
<ul>
<li>对于简单的程序，可能写一个简单的算法要比引入某种设计模式更容易；</li>
<li>对于大型项目或框架设计，用设计模式来组织代码可提高效率。</li>
</ul>
<h2 id="软件设计模式的基本要素："><a href="#软件设计模式的基本要素：" class="headerlink" title="软件设计模式的基本要素："></a>软件设计模式的<strong>基本要素</strong>：</h2><p><em>模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展、相关模式等。</em></p>
<ul>
<li>模式名称：有助于理解记忆；</li>
<li>问题：描述该模式的<strong>应用环境</strong>，解释了设计问题和问题存在的前因后果，及必须满足的一系列先决条件；</li>
<li>解决方案：包括设计的组成成分、相互关系、各自的职责和协作方式。并不描述一个特定而具体的设计或实现，只是<strong>提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合(类/对象的组合)来解决该问题</strong>。</li>
<li>效果：描述模式的应用效果及使用该模式应该权衡的问题，及模式的<strong>优缺点</strong>。主要是对时间和空间的衡量，及该模式对系统的灵活性、扩充性、可移植性的影响，并考虑其实现问题。</li>
</ul>
<h2 id="设计模式的分类："><a href="#设计模式的分类：" class="headerlink" title="设计模式的分类："></a>设计模式的<strong>分类</strong>：</h2><ol>
<li>根据目的划分：<ol>
<li>创建型模式：描述怎样创建对象，<strong>将对象的创建和使用分离</strong>。单例、原型、工厂方法、抽象工厂、建造者；</li>
<li>结构型模式：描述如何将类/对象按某种布局<strong>组成更大的结构</strong>。代理、适配器、桥接、装饰、外观、享元、组合；</li>
<li>行为型模式：描述类/对象间如何<strong>相互协作共同完成</strong>单个对象无法单独完成的任务，及如何分配职责。模版方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。</li>
</ol>
</li>
<li>根据作用范围划分：<ol>
<li>类模式：处理<strong>类与子类</strong>间的关系，通过<strong>继承</strong>建立，是<strong>静态</strong>的，在编译时便确定。工厂方法、适配器、模版方法、解释器；</li>
<li>对象模式：处理<strong>对象</strong>间的关系，通过<strong>组合或聚合</strong>实现，在运行时是<strong>动态</strong>变化的。除⬆️4种。</li>
</ol>
</li>
</ol>
<h1 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h1><p>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p>
<p>单例模式，指<strong>一个类只有一个实例</strong>，且该类能自行创建这个实例的一种模式。</p>
<h2 id="单例模式的特点："><a href="#单例模式的特点：" class="headerlink" title="单例模式的特点："></a>单例模式的特点：</h2><ul>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点。</li>
</ul>
<p>优点：</p>
<ul>
<li>提供了对唯一实例的受控访问；</li>
<li>由于在系统内存中只存在一个对象，可节约系统资源，对一些需要频繁创建和销毁的对象单例模式可提高系统性能；</li>
<li>允许可变数目的实例。<br>缺点：</li>
<li>由于单例模式没有抽象层，因此单例类很<strong>难扩展</strong>；</li>
<li>单例类的职责过重，在一定程度上违背了<a href="/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="单一职责原则SRP">单一职责原则SRP</a>；</li>
<li>滥用单例将带来负面问题<ul>
<li>如为了节约系统资源，将数据库连接池对象设计为单例模式，可能导致共享连接池对象的程序过多而出现连接池溢出；</li>
<li>如实例化的对象长时间不使用，系统当作垃圾回收，将导致对象状态的丢失。</li>
</ul>
</li>
</ul>
<h2 id="单例模式的结构及实现"><a href="#单例模式的结构及实现" class="headerlink" title="单例模式的结构及实现"></a>单例模式的结构及实现</h2><p>通常，普通类的构造函数是公有的，外部类可通过“new 构造函数()”来生成多个实例。<br>若将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。<br>单例类自身<strong>必须定义一个静态私有实例</strong>，并<strong>向外提供一个静态的公有函数</strong>用于创建或获取该静态私有实例。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="单例模式结构图"></p>
<p>Singleton模式通常有两种实现形式：</p>
<ol>
<li>懒汉式单例：类加载时不生成单例，<strong>只有当第一次调用getInstance方法时才创建</strong>这个单例。<br>多线程时要保留volatile和synchronized关键字，但<strong>每次访问都要同步</strong>，会影响性能，且消耗更多资源。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LazySingleton</span><br><span class="line">&#123;</span><br><span class="line">    private static volatile LazySingleton instance&#x3D;null;    &#x2F;&#x2F;保证 instance 在所有线程中同步</span><br><span class="line">    private LazySingleton()&#123;&#125;    &#x2F;&#x2F;private 避免类在外部被实例化</span><br><span class="line">    public static synchronized LazySingleton getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;getInstance 方法前加同步</span><br><span class="line">        if(instance&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            instance&#x3D;new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>饿汉式单例：<strong>类一旦加载就创建一个单例</strong>，保证在调用getInstance方法前单例就已存在。<br>类创建的同时就创建好一个静态对象供系统使用，以后不再改变，线程安全，可直接用于多线程。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HungrySingleton</span><br><span class="line">&#123;</span><br><span class="line">    private static final HungrySingleton instance&#x3D;new HungrySingleton();</span><br><span class="line">    private HungrySingleton()&#123;&#125;</span><br><span class="line">    public static HungrySingleton getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>在应用场景中，某类只要求生成一个对象时。如一个班的班长，个人身份证号等；</li>
<li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如web中的配置对象，数据库连接池等。</li>
<li>当某类需要频繁实例化，创建的对象又频繁被销毁时。如多线程的线程池，网络连接池等。</li>
</ul>
<h2 id="单例模式的扩展-多例模式"><a href="#单例模式的扩展-多例模式" class="headerlink" title="单例模式的扩展-多例模式"></a>单例模式的扩展-多例模式</h2><p>单例模式可扩展为有限的多例模式，这种模式可<strong>生成有限个实例并保存在ArrayList</strong>中，客户需要时可随机获取。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%9C%89%E9%99%90%E7%9A%84%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt="有限的多例模式"></p>
<h1 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h1><p>将一个对象作为原型，通过对其进行<strong>复制而克隆出多个和原型类似的新实例</strong>。</p>
<p>原型模式，指用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。<br>原型实例指定了要创建的对象的种类，用这种方式创建对象非常高效，<strong>无须知道对象创建的细节</strong>。</p>
<h2 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h2><p><em>Java提供了对象的clone()方法，用Java实现原型模式非常简单。</em></p>
<h3 id="原型模式的结构"><a href="#原型模式的结构" class="headerlink" title="原型模式的结构"></a>原型模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" alt="原型模式"></p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口；</li>
<li>具体原型类：实现抽象原型类的clone()方法，是<strong>可被复制的对象</strong>；</li>
<li>访问类：使用具体原型类的clone()方法来复制新的对象。</li>
</ol>
<h3 id="原型模式的实现"><a href="#原型模式的实现" class="headerlink" title="原型模式的实现"></a>原型模式的实现</h3><ol>
<li>浅克隆：Java中的Object类提供了浅克隆的clone()方法，具体原型类只要实现Cloneable接口(抽象原型类)即可实现对象的浅克隆。</li>
<li>深克隆</li>
</ol>
<h2 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a>原型模式的应用场景</h2><ul>
<li>对象间相同或相似，即只有个别属性不同；</li>
<li>对象的创建过程繁琐，但复制比较简单，因为复制比创建可省略部分内存和空间消耗。</li>
</ul>
<h2 id="原型模式的扩展"><a href="#原型模式的扩展" class="headerlink" title="原型模式的扩展"></a>原型模式的扩展</h2><p>带<strong>原型管理器</strong>的原型模式，在原型模式的基础上增加了一个原型管理器PrototypeManager类，该类使用HashMap保存多个复制的原型，Client类可通过管理器的get(String id)方法获取复制的原型。</p>
<h1 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式 Factory Method"></a>工厂方法模式 Factory Method</h1><p>定义一个用于创建<strong>产品的接口</strong>，由子类决定生产什么产品。</p>
<p>工厂方法模式，指定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中，满足创建型模式中要求的<strong>创建与使用相分离</strong>的特点。</p>
<p><strong>被创建的对象–产品，创建产品的对象–工厂。</strong></p>
<p>简单工厂模式<em>(不属于GoF)</em>，若要创建的产品不多，只要一个工厂类就可完成。<br>缺点：增加新产品时会违背OCP。</p>
<p>工厂方法模式，是对简单工厂模式的进一步抽象化，优势在于<strong>可使系统在不修改原代码的基础上引进新产品</strong>，即满足OCP。</p>
<h2 id="工厂方法模式的特点"><a href="#工厂方法模式的特点" class="headerlink" title="工厂方法模式的特点"></a>工厂方法模式的特点</h2><ul>
<li>优点：<ul>
<li>用户只需要知道具体工厂的名称，即可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时，只需添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足OCP。</li>
</ul>
</li>
<li>缺点：<ul>
<li>每增加一个产品，就要增加一个具体产品类和一个对应的具体工厂类，增加了系统的复杂度。</li>
</ul>
</li>
</ul>
<h2 id="工厂方法模式的结构和实现"><a href="#工厂方法模式的结构和实现" class="headerlink" title="工厂方法模式的结构和实现"></a>工厂方法模式的结构和实现</h2><p>工厂方法模式由<strong>抽象工厂、具体工厂、抽象产品、具体产品</strong>4个要素构成。</p>
<h3 id="工厂方法模式的结构"><a href="#工厂方法模式的结构" class="headerlink" title="工厂方法模式的结构"></a>工厂方法模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="工厂方法模式"></p>
<ol>
<li>抽象工厂<code>Abstract Factory</code>：提供了创建产品的接口，调用者通过访问具体工厂的工厂方法newProduct()来创建产品。</li>
<li>具体工厂<code>Concrete Factory</code>：实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品<code>Product</code>：定义了产品的规范，描述了<strong>产品的主要特性和功能</strong>。</li>
<li>具体产品<code>Concrete Product</code>：实现了抽象产品角色所定义的接口，<strong>由具体工厂创建</strong>，同具体工厂间一一对应。</li>
</ol>
<h2 id="工厂方法模式的应用场景"><a href="#工厂方法模式的应用场景" class="headerlink" title="工厂方法模式的应用场景"></a>工厂方法模式的应用场景</h2><ul>
<li>客户只知道创建产品的工厂名，不知道具体的产品名。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，抽象工厂只提供创建产品的链接。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌。</li>
</ul>
<h2 id="工厂方法模式的扩展"><a href="#工厂方法模式的扩展" class="headerlink" title="工厂方法模式的扩展"></a>工厂方法模式的扩展</h2><p>当需要生产的产品不多，且不会增加，一个具体工厂类就可完成任务时，可删除抽象工厂类。<br>可将工厂方法模式退化为简单工厂模式。</p>
<h1 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 Abstract Factory"></a>抽象工厂模式 Abstract Factory</h1><p>提供一个<strong>创建产品族</strong>的接口，其<strong>每个子类可生产一系列相关的产品</strong>。</p>
<p>抽象工厂模式，指一种<strong>为访问类提供一个创建一组相关或相互依赖对象的接口</strong>，且访问类无须指定所要产品的具体类，就能得到同族的不同等级的产品的模式结构。</p>
<p><strong>抽象工厂和工厂方法模式的区别：</strong></p>
<ul>
<li>工厂方法模式<strong>只考虑生产<code>同等级/同种类</code>的产品</strong>；</li>
<li>抽象工厂模式<strong>考虑多等级产品的生产</strong>，将<code>同一具体工厂生产的位于不同等级的一组产品</code>成为一个产品族。</li>
<li>工厂方法模式只生产一个等级的产品，抽象工厂模式可生产多个等级的产品，是工厂方法模式的升级版。</li>
</ul>
<h2 id="抽象工厂模式的特点"><a href="#抽象工厂模式的特点" class="headerlink" title="抽象工厂模式的特点"></a>抽象工厂模式的特点</h2><ul>
<li>优点：<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理；</li>
<li>当增加一个新的产品族时不需要修改原代码，满足OCP。</li>
</ul>
</li>
<li>缺点：<ul>
<li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li>
</ul>
</li>
</ul>
<h2 id="抽象工厂模式的结构与实现"><a href="#抽象工厂模式的结构与实现" class="headerlink" title="抽象工厂模式的结构与实现"></a>抽象工厂模式的结构与实现</h2><p>抽象工厂模式同工厂方法模式一样，都是由抽象工厂、具体工厂、抽象产品、具体产品等4个要素构成，但抽象方法中方法个数不同，抽象产品的个数也不同。</p>
<h3 id="抽象工厂模式的结构"><a href="#抽象工厂模式的结构" class="headerlink" title="抽象工厂模式的结构"></a>抽象工厂模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="抽象工厂模式"></p>
<ol>
<li>抽象工厂：提供了创建产品的接口，包含多个创建产品的方法newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂：主要实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和性能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，同具体工厂间是<code>n:1</code>的关系。</li>
</ol>
<p>抽象工厂模式和工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以，<strong>创建产品的方法不止一个</strong>。</p>
<h3 id="抽象工厂模式的实现"><a href="#抽象工厂模式的实现" class="headerlink" title="抽象工厂模式的实现"></a>抽象工厂模式的实现</h3><ol>
<li>抽象工厂：提供了产品的生成方法。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface AbstractFactory &#123;</span><br><span class="line">    public Product1 newProduct1();</span><br><span class="line">    public Product2 newProduct2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>具体工厂：实现了产品的生成方法。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteFactory implements AbstractFactory &#123;</span><br><span class="line">    public Product1 newProduct1() &#123;</span><br><span class="line">        System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 1...&quot;);</span><br><span class="line">        return new ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">    public Product2 newProduct2() &#123;</span><br><span class="line">        System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 2...&quot;);</span><br><span class="line">        return new ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="抽象工厂模式的适用场景"><a href="#抽象工厂模式的适用场景" class="headerlink" title="抽象工厂模式的适用场景"></a>抽象工厂模式的适用场景</h2><ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品；</li>
<li>系统一次只可消费其中某一族的产品，即同族的产品一起使用。</li>
</ul>
<p>具体来讲，可分为如下3种：</p>
<ul>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等；</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品，如有人只喜欢某一个品牌的衣服和鞋子；</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ul>
<p>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构建，如Java的AWT中的Button和Text等构件在Windows和UNIX中的本地实现是不同的。</p>
<h2 id="抽象工厂模式的扩展"><a href="#抽象工厂模式的扩展" class="headerlink" title="抽象工厂模式的扩展"></a>抽象工厂模式的扩展</h2><p>抽象工厂模式的扩展具有一定的OCP倾斜性：</p>
<ul>
<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足OCP。</li>
<li>当产品族中需要增加一个新种类的产品时，所有的工厂类都需要进行修改，不满足OCP。</li>
</ul>
<p>当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>
<h1 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h1><p>将一个<strong>复杂对象分解</strong>成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p>
<p>建造者模式，指将一个复杂对象的<strong>构造与其表示分离</strong>，<strong>使同样的构建过程可以创建不同的表示</strong>。<br>将一个复杂的对象分解为多个简单的对象，然后一步步构建而成；将变与不变相分离，即产品的组成部分是不变的，但<strong>每一部分是灵活选择</strong>的。</p>
<h2 id="建造者模式的特点"><a href="#建造者模式的特点" class="headerlink" title="建造者模式的特点"></a>建造者模式的特点</h2><p>建造者模式和工厂方法模式的区别：（🉑️结合使用）</p>
<ul>
<li>建造者模式<strong>注重零部件的组装过程</strong>；</li>
<li>工厂方法模式注重零部件的<strong>创建过程</strong>。</li>
</ul>
<ul>
<li>优点：<ul>
<li>各个具体的建造者相互独立，有利于系统的扩展；</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>
</ul>
</li>
<li>缺点：<ul>
<li>产品的组成部分必须相同，限制了其使用范围；</li>
<li>若产品的内部变化复杂，会增加很多的建造者类。</li>
</ul>
</li>
</ul>
<h2 id="建造者模式的结构与实现"><a href="#建造者模式的结构与实现" class="headerlink" title="建造者模式的结构与实现"></a>建造者模式的结构与实现</h2><p>建造者模式由<strong>产品、抽象建造者、具体建造者、指挥者</strong>4个要素构成。</p>
<h3 id="建造者模式的结构"><a href="#建造者模式的结构" class="headerlink" title="建造者模式的结构"></a>建造者模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="建造者模式"></p>
<ol>
<li>产品角色Product：包含<strong>多个组成部件的复杂对象</strong>，由具体建造者来创建其各个部件；</li>
<li>抽象建造者Builder：包含创建产品各个子部件的抽象方法的接口，通常还包含一个<strong>返回复杂产品的方法</strong>getResult()；</li>
<li>具体建造者<code>Concrete Builder</code>：实现Builder接口，完成复杂产品的各个部件的具体创建方法；</li>
<li>指挥者Director：调用建造者对象中的<strong>部件构造与装配方法</strong>，完成复杂对象的创建，在指挥者中<strong>不涉及具体产品的信息</strong>。</li>
</ol>
<h3 id="建造者模式的实现"><a href="#建造者模式的实现" class="headerlink" title="建造者模式的实现"></a>建造者模式的实现</h3><ol>
<li>产品角色：包含多个组成部件的复杂对象；</li>
<li>抽象建造者：包含创建产品各个子部件的抽象方法；</li>
<li>具体建造者：实现了抽象建造者接口；</li>
<li>指挥者：调用建造者中的方法完成复杂对象的创建；</li>
<li>客户类</li>
</ol>
<h2 id="建造者模式的应用场景"><a href="#建造者模式的应用场景" class="headerlink" title="建造者模式的应用场景"></a>建造者模式的应用场景</h2><p>建造者模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定：</p>
<ul>
<li>创建的对象复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的；</li>
<li>创建复杂对象的算法独立于该对象的组成部分及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ul>
<h2 id="建造者模式的扩展"><a href="#建造者模式的扩展" class="headerlink" title="建造者模式的扩展"></a>建造者模式的扩展</h2><p>建造者模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，可省略抽象建造者，甚至指挥者。</p>
<h1 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h1><p>为某对象提供一种代理以控制对该对象的访问。即<strong>客户端通过代理间接地访问该对象</strong>，从而限制、增强或修改该对象的一些特性。</p>
<p>代理模式，由于某些原因需要给某对象提供一个<strong>代理以控制对该对象的访问</strong>，访问对象不适合或不能直接引用目标对象，代理对象作为访问对象和目标对象的中介。</p>
<h2 id="代理模式的特点"><a href="#代理模式的特点" class="headerlink" title="代理模式的特点"></a>代理模式的特点</h2><ul>
<li>优点：<ul>
<li>代理模式在客户端与目标对象间起到一个中介作用和<strong>保护目标对象</strong>的作用；</li>
<li>代理对象可以<strong>扩展目标对象的功能</strong>；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
</li>
<li>缺点：<ul>
<li>在客户端和目标对象间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度。</li>
</ul>
</li>
</ul>
<h2 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h2><p>代理模式的结构比较简单，主要是通过<strong>定义一个继承抽象主题的代理来包含真实主题</strong>，从而实现对真实主题的访问。</p>
<h3 id="代理模式的结构"><a href="#代理模式的结构" class="headerlink" title="代理模式的结构"></a>代理模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p>
<ol>
<li>抽象主题类Subject：通过接口或抽象类声明真实主题和代理对象实现的业务方法；</li>
<li>真实主题类<code>Real Subject</code>：实现类抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象；</li>
<li>代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，🉑️访问、控制、扩展真实主题的功能。</li>
</ol>
<h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><ul>
<li>远程代理：通常为了隐藏目标对象存在于<strong>不同地址空间</strong>的事实，方便客户端访问，如虚拟硬盘；</li>
<li>虚拟代理：通常用于要创建的目标对象开销较大时，先用<strong>小比例的虚拟代理替换真实对象</strong>，消除用户等待烦躁；</li>
<li>安全代理：通常用于控制不同种类客户对真实对象的访问权限；</li>
<li>智能指引：用于调用目标对象时，代理附加一些额外的处理功能；</li>
<li>延迟加载：为提高系统性能，延迟对目标的加载。</li>
</ul>
<h2 id="代理模式的扩展"><a href="#代理模式的扩展" class="headerlink" title="代理模式的扩展"></a>代理模式的扩展</h2><p>普通代理模式的缺点：</p>
<ul>
<li>真实主题于代理主题一一对应，增加真实主题需要增加对应代理；</li>
<li>设计代理之前，真实主题必须事先存在。</li>
</ul>
<p>动态代理模式：<em>如SpringAOP</em><br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="动态代理模式"></p>
<h1 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h1><p>将一个类的接口转换成客户希望的另一个接口，使得原本由于<strong>接口不兼容</strong>而不能一起工作的那些类可一起工作。</p>
<p>适配器模式，指将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类能够协同工作。</p>
<ul>
<li>类结构型模式：耦合度比对象结构型模式高，且要求程序员了解现有组件库中的相关组件的内部结构；</li>
<li>对象结构型模式</li>
</ul>
<h2 id="适配器模式的特点"><a href="#适配器模式的特点" class="headerlink" title="适配器模式的特点"></a>适配器模式的特点</h2><ul>
<li>优点：<ul>
<li>客户端通过适配器可以透明的调用目标接口；</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类；</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
</li>
<li>缺点：<ul>
<li>对类适配器来说，更换适配器的实现过程比较复杂。</li>
</ul>
</li>
</ul>
<h2 id="适配器模式的结构与实现"><a href="#适配器模式的结构与实现" class="headerlink" title="适配器模式的结构与实现"></a>适配器模式的结构与实现</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="类适配器模式"></p>
<ul>
<li>类适配器模式，可采用多重继承方式实现；<ul>
<li>如C++可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；</li>
<li>如Java不支持多继承，但可定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="对象适配器模式"></li>
</ul>
</li>
<li>对象适配器模式，可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</li>
</ul>
<h3 id="适配器模式的结构"><a href="#适配器模式的结构" class="headerlink" title="适配器模式的结构"></a>适配器模式的结构</h3><ol>
<li>目标接口Target：当前系统业务所期待的接口，可以是抽象类或接口；</li>
<li>适配者类：是被访问和适配的现存组件库中的组件接口；</li>
<li>适配器类：一个转换器，通过继承或引用适配者的对象，将适配者接口转换为目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
<h2 id="适配器模式的应用场景"><a href="#适配器模式的应用场景" class="headerlink" title="适配器模式的应用场景"></a>适配器模式的应用场景</h2><ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致；</li>
<li>使用第三方提供的组件，但组件接口定义和所需的接口定义不同。</li>
</ul>
<h2 id="适配器模式的扩展"><a href="#适配器模式的扩展" class="headerlink" title="适配器模式的扩展"></a>适配器模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8F%8C%E5%90%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="双向适配器模式"></p>
<p>适配器模式可扩展为<strong>双向适配器模式</strong>，既可以把适配者接口转换为目标接口，也可以把目标接口转换为适配者接口。</p>
<h1 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 Bridge"></a>桥接模式 Bridge</h1><p>将抽象与实现分离，使它们可以独立变化。它是用<strong>组合关系代替继承关系</strong>来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<h2 id="桥接模式的特点"><a href="#桥接模式的特点" class="headerlink" title="桥接模式的特点"></a>桥接模式的特点</h2><ul>
<li>优点：<ul>
<li>由于抽象和实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
</li>
<li>缺点：<ul>
<li>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，增加了系统的理解与设计难度。</li>
</ul>
</li>
</ul>
<h2 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h2><p>可将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h3 id="桥接模式的结构"><a href="#桥接模式的结构" class="headerlink" title="桥接模式的结构"></a>桥接模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="桥接模式"></p>
<ol>
<li>抽象化角色Abstraction：定义抽象类，并包含一个对实现化对象的引用；</li>
<li>扩展抽象化角色<code>Refined Abstraction</code>：抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法；</li>
<li>实现化角色Implementor：定义实现化角色的接口，供扩展抽象化角色调用；</li>
<li>具体实现化角色<code>Concrete Implementor</code>：给出实现化角色接口的具体实现。</li>
</ol>
<h2 id="桥接模式的应用场景"><a href="#桥接模式的应用场景" class="headerlink" title="桥接模式的应用场景"></a>桥接模式的应用场景</h2><ul>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；</li>
<li>当一个系统不希望使用继承或因多层次继承导致系统类的个数急剧增加；</li>
<li>当一个系统需要构件的抽象化角色和具体化角色间增加更多的灵活性。</li>
</ul>
<h2 id="桥接模式的扩展"><a href="#桥接模式的扩展" class="headerlink" title="桥接模式的扩展"></a>桥接模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8FAdd%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="桥接模式Add适配者模式"></p>
<p>当桥接模式的实现化角色的接口与现有类的接口不一致时，通常将桥接模式和适配器模式联合使用，通过在实现化角色和现有类之间定义一个适配器将其连接起来。<br>如上图，将原有具体实现化角色/适配者进行接口转换为具体实现化角色。</p>
<h1 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h1><p>动态的给对象增加一些职责，即增加其额外的功能。</p>
<p>装饰模式，指在<strong>不改变现有对象结构</strong>的情况下，动态的给该对象增加一些职责的模式，属于对象结构型模式。<br>在软件开发过程中，有时想用一些现存的组件，这些组件可能只是完成了一些核心功能，在不改变其结构的情况下，可以动态地扩展其功能。</p>
<h2 id="装饰模式的特点"><a href="#装饰模式的特点" class="headerlink" title="装饰模式的特点"></a>装饰模式的特点</h2><ul>
<li>优点：<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活；</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul>
</li>
<li>缺点：<ul>
<li>装饰模式增加了许多子类，过度使用会使程序变得很复杂。</li>
</ul>
</li>
</ul>
<h2 id="装饰模式的结构与实现"><a href="#装饰模式的结构与实现" class="headerlink" title="装饰模式的结构与实现"></a>装饰模式的结构与实现</h2><p>通常情况下，扩展一个类的功能会使用继承方式来实现，但<strong>继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会膨胀</strong>。<br>如果使用组合关系来创建一个包装对象(即装饰对象)来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</p>
<h3 id="装饰模式的结构"><a href="#装饰模式的结构" class="headerlink" title="装饰模式的结构"></a>装饰模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.png" alt="装饰模式"></p>
<ol>
<li>抽象构件角色Component：定义一个抽象接口以规范准备接收附加责任的对象；</li>
<li>具体构件角色<code>Concrete Component</code>：实现抽象构件，通过装饰角色为其添加一些职责；</li>
<li>抽象装饰角色Decorator：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能；</li>
<li>具体装饰角色<code>Concrete Decorator</code>：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<h2 id="装饰模式的应用场景"><a href="#装饰模式的应用场景" class="headerlink" title="装饰模式的应用场景"></a>装饰模式的应用场景</h2><ul>
<li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时，如该类被隐藏或该类时终极类或采用继承方式会产生大量子类；</li>
<li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系难以实现；</li>
<li>当对象的功能要求可以动态添加，也能动态的撤销时。</li>
</ul>
<p>装饰功能在Java中最著名的应用：Java I/O标准库的设计。<br>如，InputStream的子类FilterInputStream、OutputStream的子类FilterOutputStream、Reader的子类BufferedReader和FilterReader、Writer的子类BufferedWriter和FilterWriter及PrintWriter等，都是抽象装饰类。</p>
<h2 id="装饰模式的扩展（简化）"><a href="#装饰模式的扩展（简化）" class="headerlink" title="装饰模式的扩展（简化）"></a>装饰模式的扩展（简化）</h2><ul>
<li>只有一个具体构件，没有抽象构件时，可让抽象装饰继承具体构件；</li>
<li>只有一个具体装饰时，可将抽象装饰和具体装饰合并。</li>
</ul>
<h1 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h1><p>为多个复杂的子系统提供一个<strong>一致的接口</strong>，使这些子系统更加容易被访问。</p>
<p>外观模式，指一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。<br>该模式对外有一个统一的接口，外部应用程序不用关心内部子系统的具体细节，大大降低了应用程序的复杂度，提高了程序的可维护性。</p>
<h2 id="外观模式的特点"><a href="#外观模式的特点" class="headerlink" title="外观模式的特点"></a>外观模式的特点</h2><p>外观模式是<a href="/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="迪米特法则LoD">迪米特法则LoD</a>的典型应用。</p>
<ul>
<li>优点：<ul>
<li>降低了子系统与客户端之间的耦合度，使子系统的变化不会影响调用它的客户类；</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更容易；</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台间的移植过程，因为编译一个子系统不会影响其它子系统，也不会影响外观对象。</li>
</ul>
</li>
<li>缺点：<ul>
<li>不能很好的限制客户使用子系统类；</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了OCP；</li>
</ul>
</li>
</ul>
<h2 id="外观模式的结构与实现"><a href="#外观模式的结构与实现" class="headerlink" title="外观模式的结构与实现"></a>外观模式的结构与实现</h2><p>外观模式的结构比较简单，主要是<strong>定义了一个高层接口</strong>，包含了对各个子系统的引用，客户端可通过该接口访问各个子系统的功能。</p>
<h3 id="外观模式的结构"><a href="#外观模式的结构" class="headerlink" title="外观模式的结构"></a>外观模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.png" alt="外观模式"></p>
<ol>
<li>外观角色Facade：为多个子系统对外提供一个共同的接口；</li>
<li>子系统角色<code>Sub System</code>：实现系统的部分功能，客户可通过外观角色访问；</li>
<li>客户角色Client：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<h2 id="外观模式的应用场景"><a href="#外观模式的应用场景" class="headerlink" title="外观模式的应用场景"></a>外观模式的应用场景</h2><ul>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可简化子系统之间的依赖关系；</li>
<li>当一个复杂系统的子系统较多时，外观模式可为系统设计一个简单的接口供外界访问；</li>
<li>当客户端与多个子系统间存在很大的联系时，引入外观模式可将其分离，从而提高子系统的独立性和可移植性。</li>
</ul>
<h2 id="外观模式的扩展"><a href="#外观模式的扩展" class="headerlink" title="外观模式的扩展"></a>外观模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8Fadd%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB.png" alt="外观模式add抽象外观类"></p>
<p>在外观模式中，引入抽象外观类，可一定程度上减少修改（当增加或移除子系统时需要修改外观类问题）。</p>
<h1 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h1><p>运用共享技术来有效地支持大量细粒度对象的复用。</p>
<p>享元模式，通过共享以及存在的对象来大幅度减少需要创建的对象数量，避免大量相似类的开销，从而提高系统资源的利用率。</p>
<h2 id="享元模式的特点"><a href="#享元模式的特点" class="headerlink" title="享元模式的特点"></a>享元模式的特点</h2><ul>
<li>优点：<ul>
<li>相同对象只要保存一份，降低了系统中对象的数量，从而降低了系统中细粒度对象给<code>内存</code>带来的压力；</li>
</ul>
</li>
<li>缺点：<ul>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，增加了程序的复杂性；</li>
<li>读取享元模式的外部状态使得运行时间稍微变长。</li>
</ul>
</li>
</ul>
<h2 id="享元模式的结构与实现"><a href="#享元模式的结构与实现" class="headerlink" title="享元模式的结构与实现"></a>享元模式的结构与实现</h2><p>享元模式存在两种状态：</p>
<ul>
<li>内部状态：不会随着环境的改变而改变的可共享部分；</li>
<li>外部状态：随环境改变而改变的不可共享部分。</li>
</ul>
<h3 id="享元模式的结构"><a href="#享元模式的结构" class="headerlink" title="享元模式的结构"></a>享元模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" alt="享元模式"></p>
<ol>
<li>抽象享元角色Flyweight：所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入；</li>
<li>具体享元角色<code>Concrete Flyweight</code>：实现抽象享元角色中所规定的接口；</li>
<li>非享元角色<code>Unsharable Flyweight</code>：不可共享的外部状态，<strong>以参数的形式注入具体享元的相关方法</strong>中；</li>
<li>享元工厂角色<code>Flyweight Factory</code>：<strong>负责创建和管理享元角色</strong>。<ol>
<li>当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象；</li>
<li>若存在该享元对象，则提供给客户；</li>
<li>若不存在该享元对象，则创建一个新的享元对象。</li>
</ol>
</li>
</ol>
<h2 id="享元模式的应用场景"><a href="#享元模式的应用场景" class="headerlink" title="享元模式的应用场景"></a>享元模式的应用场景</h2><ul>
<li>系统中存在大量相同或相似的对象，这些对象消耗大量的内存资源；</li>
<li>大部分的对象可按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态；</li>
<li>由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用。</li>
</ul>
<h2 id="享元模式的扩展"><a href="#享元模式的扩展" class="headerlink" title="享元模式的扩展"></a>享元模式的扩展</h2><h3 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h3><p>单纯享元模式，所有的具体享元类都是可共享的，不存在非共享的具体享元类。</p>
<h3 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" alt="复合享元模式"></p>
<p>复合享元模式，有些享元对象由一些单纯享元对象组合而成，即复合享元对象。</p>
<p>复合享元对象本身不能共享，但可分解为单纯享元对象再被共享。</p>
<h1 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h1><p>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>组合模式，又称<code>部分-整体模式</code>，是一种将对象组合成树状层次结构的模式，用来表示<code>部分-整体</code>的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<h2 id="组合模式的特点"><a href="#组合模式的特点" class="headerlink" title="组合模式的特点"></a>组合模式的特点</h2><ul>
<li>优点：<ul>
<li>组合模式使客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，简化了客户端代码；</li>
<li>使得在组合体内添加新对象更容易，客户端不会因加入新对象而改变源代码，满足OCP；</li>
</ul>
</li>
<li>缺点：<ul>
<li>设计较复杂，客户端需要花更多时间理清类间层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能。</li>
</ul>
</li>
</ul>
<h2 id="组合模式的结构与实现"><a href="#组合模式的结构与实现" class="headerlink" title="组合模式的结构与实现"></a>组合模式的结构与实现</h2><h3 id="组合模式的结构"><a href="#组合模式的结构" class="headerlink" title="组合模式的结构"></a>组合模式的结构</h3><ol>
<li>抽象构件角色Component：为树叶构件和树枝构件声明公共接口，并实现其默认行为；<ol>
<li>在透明式的组合模式中抽象构件还声明访问和管理子类的接口；</li>
<li>在安全是的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成；</li>
</ol>
</li>
<li>树叶构件角色Leaf：组合中的叶结点对象，没有子结点，用于实现抽象构件角色中声明的<strong>公共接口</strong>；</li>
<li>树枝构件角色Composite：组合中的分支结点对象，有子结点，实现了抽象构件角色中声明的接口；<ol>
<li>用于存储和管理子部件，通常包含Add()、Remove()、GetChild()等方法。</li>
</ol>
</li>
</ol>
<h3 id="组合模式的实现"><a href="#组合模式的实现" class="headerlink" title="组合模式的实现"></a>组合模式的实现</h3><ol>
<li>透明式的组合模式<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%80%8F%E6%98%8E%E5%BC%8F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.png" alt="透明式组合模式"><ol>
<li>由于抽象构件声明了所有子类中的全部方法，客户端无须区别树叶对象和树枝对象，对客户端来说是透明的；</li>
<li>但树叶构件本没有Add()、Remove()、GetChild()方法，却要实现它们(空实现或抛异常)，会带来安全性问题。</li>
</ol>
</li>
<li>安全式的组合模式<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%AE%89%E5%85%A8%E5%BC%8F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.png" alt="安全式组合模式"><ol>
<li>将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，避免了透明式组合模式的安全性问题；</li>
<li>但由于叶子和分支有不同的接口，客户端在调用时需要直到树叶对象和树枝对象的存在，造成透明性的缺失。</li>
</ol>
</li>
</ol>
<h2 id="组合模式的应用场景"><a href="#组合模式的应用场景" class="headerlink" title="组合模式的应用场景"></a>组合模式的应用场景</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%8D%E6%9D%82%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.png" alt="复杂组合模式"></p>
<ul>
<li>在需要表示一个对象整体与部分的层次结构的场合；</li>
<li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的组合。</li>
</ul>
<h2 id="组合模式的扩展"><a href="#组合模式的扩展" class="headerlink" title="组合模式的扩展"></a>组合模式的扩展</h2><p>如果对树叶结点和树枝结点进行抽象，即树叶结点和树枝结点还有子结点，这是组合模式就被扩展为<code>复杂的组合模式</code>。<br>如Java AWT/Swing中的简单插件JTextComponent有子类JTextField、JTextArea，容器组件Container也有子类Window、Panel。</p>
<h1 id="模版方法模式-Template-Method"><a href="#模版方法模式-Template-Method" class="headerlink" title="模版方法模式 Template Method"></a>模版方法模式 Template Method</h1><p>定义一个操作中的<strong>算法骨架</strong>，将算法的一些<strong>步骤延迟到子类</strong>中，使子类可以不改变该算法结构的情况下重新定义该算法的某些特定步骤。</p>
<h2 id="模板方法模式的特点"><a href="#模板方法模式的特点" class="headerlink" title="模板方法模式的特点"></a>模板方法模式的特点</h2><ul>
<li>优点：<ul>
<li>封装了不变部分，扩展可变部分；<ul>
<li>不变部分的算法封装到父类中实现；</li>
<li>可变部分的算法由子类继承实现，便于子类继续扩展；</li>
</ul>
</li>
<li>在父类中提取了公共的部分代码，便于代码复用；</li>
<li>部分方法由子类实现，子类可通过扩展方式增加相应的功能，复合OCP；</li>
</ul>
</li>
<li>缺点：<ul>
<li>对每个不同的实现都需要定义一个子类，导致类的数量增加，系统庞大，设计也更加抽象；</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，导致一种反向的控制结构，提高了代码阅读的难度。</li>
</ul>
</li>
</ul>
<h2 id="模板方法模式的结构与实现"><a href="#模板方法模式的结构与实现" class="headerlink" title="模板方法模式的结构与实现"></a>模板方法模式的结构与实现</h2><p>模板方法模式需要注意抽象类与具体子类的协作，用到了<strong>虚函数的多态性</strong>技术及“不用调用我，让我来调用你”的<strong>反向控制</strong>技术。</p>
<h3 id="模板方法模式的结构"><a href="#模板方法模式的结构" class="headerlink" title="模板方法模式的结构"></a>模板方法模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="模板方法模式"></p>
<ol>
<li>抽象类<code>Abstract Class</code>：负责给出一个算法的轮廓和骨架，由一个模板方法和若干个基本方法构成<ol>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法；</li>
<li>基本方法：整个算法中的一个步骤<ol>
<li>抽象方法：在抽象类中声明，由具体子类实现；</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可继承或重写该方法；</li>
<li><strong>钩子方法</strong>：在抽象类中已经实现，包括<strong>用于判断的逻辑方法</strong>和<strong>需要子类重写的空方法</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>具体子类<code>Concrete Class</code>：实现抽象类中所定义的抽象方法和钩子方法，是一个顶级逻辑的一个组成步骤。</li>
</ol>
<h2 id="模板方法模式的应用场景"><a href="#模板方法模式的应用场景" class="headerlink" title="模板方法模式的应用场景"></a>模板方法模式的应用场景</h2><ul>
<li>算法的整体步骤固定，但其中个别部分易变时，可使用模板方法模式，将易变的部分抽象出来，供子类实现；</li>
<li>当多个子类存在公共的行为时，可将其提取出来并集中到一个公共父类中以避免代码重复；<ul>
<li>first，要识别现有代码的不同之处，并将不同之处分离为新的操作；</li>
<li>second，用一个调用这些新的操作的模板方法来替换这些不同的代码；</li>
</ul>
</li>
<li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>
</ul>
<h2 id="模板方法模式的扩展"><a href="#模板方法模式的扩展" class="headerlink" title="模板方法模式的扩展"></a>模板方法模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%90%AB%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="含钩子函数的模板方法模式"></p>
<p>在模板方法模式中，正确使用<code>钩子方法</code>可使子类控制父类的行为。</p>
<h1 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h1><p>定义一系列算法，并<strong>对每个算法进行封装，使其可以相互替换</strong>，且算法的改变不会影响使用算法的客户。</p>
<p>策略模式，属于对象行为模式，通过对算法进行封装，将使用算法的责任和实现分割开，并委派给不同的对象对这些算法进行管理。<br>策略模式是准备一组算法，并将这组算法封装到一系列的策略类中，作为一个抽象策略类的子类。</p>
<h2 id="策略模式的特点"><a href="#策略模式的特点" class="headerlink" title="策略模式的特点"></a>策略模式的特点</h2><ul>
<li>优点：<ul>
<li>多重条件语句不易维护，且增删改算法时需要修改原代码，使用策略模式可以避免使用多重条件语句；</li>
<li>策略模式提供了一系列的可重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复代码；</li>
<li>策略模式可以提供相同行为的不同实现，客户可根据不同时间或空间要求选择不同的实现策略；</li>
<li>策略模式提供了对OCP的完美支持，可在不修改原代码的情况下，灵活添加新的算法；</li>
<li>策略模式将算法的使用放到环境类中，将算法的实现转移到具体策略类中，实现了二者的分离；</li>
</ul>
</li>
<li>缺点：<ul>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类；</li>
<li>策略模式造成很多的策略类。</li>
</ul>
</li>
</ul>
<h2 id="策略模式的结构与实现"><a href="#策略模式的结构与实现" class="headerlink" title="策略模式的结构与实现"></a>策略模式的结构与实现</h2><p>策略模式的重心不是如何实现算法，而是<strong>如何组织算法</strong>，从而让程序结构更加灵活，具有更好的可维护性和扩展性。</p>
<h3 id="策略模式的结构"><a href="#策略模式的结构" class="headerlink" title="策略模式的结构"></a>策略模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt="策略模式"></p>
<ol>
<li>抽象策略类Strategy：定义了一个公共接口，各种不同的算法以不同的方式实现该接口，环境角色使用该接口调用不同的算法，一般使用接口或抽象类实现；</li>
<li>具体策略类<code>Concrete Strategy</code>：实现了抽象策略定义的接口，提供具体的算法实现；</li>
<li>环境类Context：持有一个策略类的引用，最终给客户端调用。</li>
</ol>
<h2 id="策略模式的应用场景"><a href="#策略模式的应用场景" class="headerlink" title="策略模式的应用场景"></a>策略模式的应用场景</h2><ul>
<li>一个系统需要动态的在几种算法中选择一种时，可将每个算法封装到策略中；</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入各自的策略类中代替；</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节；</li>
<li>系统要求使用算法的客户不应该知道其操作的数据，可使用策略模式来隐藏与算法相关的数据结构；</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择要执行的行为。</li>
</ul>
<p><em>Java SE中的容器布局管理就是一个典型的策略模式的实例，每个容器都存在多种布局供用户选择。</em></p>
<h2 id="策略模式的扩展"><a href="#策略模式的扩展" class="headerlink" title="策略模式的扩展"></a>策略模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%AD%96%E7%95%A5%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="策略工厂模式"></p>
<p>在一个使用策略模式的系统中，当存在很多策略时，客户端管理所有策略将变得很复杂，如果在环境类中使用策略工厂模式将大大减少客户端的工作复杂度。</p>
<h1 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h1><p>将一个<strong>请求封装为一个对象</strong>，使发出请求的责任和执行请求的责任分隔开。</p>
<p>命令模式，将请求的责任和执行请求的责任通过命令对象进行沟通，方便将命令对象进行储存、传递、调用、增加、管理。</p>
<h2 id="命令模式的特点"><a href="#命令模式的特点" class="headerlink" title="命令模式的特点"></a>命令模式的特点</h2><ul>
<li>优点：<ul>
<li>降低系统的耦合度，命令模式能将调用操作的对象与实现该操作的对象进行解耦；</li>
<li>增加或删除命令非常方便，采用命令模式增加与删除命令不会影响其它类，满足OCP，可灵活扩展；</li>
<li>可实现宏命令(命令模式与组合模式结合，将多个命令装配成一个组合命令)；</li>
<li>方便实现Undo和Redo操作，与备忘录模式结合，可实现命令的撤销与恢复。</li>
</ul>
</li>
<li>缺点：<ul>
<li>可能产生大量具体命令类，因为针对每一个具体操作都需要设计一个具体命令类，增加了系统的复杂性。</li>
</ul>
</li>
</ul>
<h2 id="命令模式的结构与实现"><a href="#命令模式的结构与实现" class="headerlink" title="命令模式的结构与实现"></a>命令模式的结构与实现</h2><p>通过将系统中的相关操作抽象成命令，使调用者和实现者相关分离。</p>
<h3 id="命令模式的结构"><a href="#命令模式的结构" class="headerlink" title="命令模式的结构"></a>命令模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="命令模式"></p>
<ol>
<li>抽象命令类角色Command：声明执行命令的接口，拥有执行命令的抽象方法execute();</li>
<li>具体命令角色<code>Concrete Command</code>：抽象命令类的具体实现类，拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作；</li>
<li>实现者/接收者角色Receiver：执行命令功能的相关操作，是具体命令对象业务的真正实现者；</li>
<li>调用者/请求者角色Invoker：请求的发送者，通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，不直接访问接收者。</li>
</ol>
<h2 id="命令模式的应用场景"><a href="#命令模式的应用场景" class="headerlink" title="命令模式的应用场景"></a>命令模式的应用场景</h2><ol>
<li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互；</li>
<li>当系统需要随机请求命令或经常增加或删除命令时，命令模式实现比较方便；</li>
<li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现；</li>
<li>当系统需要支持命令的撤销Undo操作和恢复Redo操作时，可将命令对象存储起来，采用备忘录模式实现。</li>
</ol>
<h2 id="命令模式的扩展"><a href="#命令模式的扩展" class="headerlink" title="命令模式的扩展"></a>命令模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%AE%8F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="宏命令模式"></p>
<p>宏命令模式/组合命令模式，将命令模式和组合模式联合使用，宏命令包含了一组命令，充当了具体命令和调用者的双重角色，执行时将递归调用它所包含的所有命令。</p>
<h1 id="责任链模式-职责链模式-Chain-of-Responsibility"><a href="#责任链模式-职责链模式-Chain-of-Responsibility" class="headerlink" title="责任链模式/职责链模式 Chain of Responsibility"></a>责任链模式/职责链模式 Chain of Responsibility</h1><p>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方法去除对象间的耦合。</p>
<p>责任链模式，是一种对象行为型模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而形成一条链，当有请求发生时，可将请求沿着这条链传递，直到有对象处理为止。</p>
<p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以，责任链将请求的发送者和请求的处理者解耦了。</p>
<h2 id="责任链模式的特点"><a href="#责任链模式的特点" class="headerlink" title="责任链模式的特点"></a>责任链模式的特点</h2><ul>
<li>优点：<ul>
<li>降低了对象间的耦合度，使一个对象无须知道到底哪一个对象处理其请求及链的结构，发送者和接收者也无须拥有对方的明确信息；</li>
<li>增强了系统的可扩展性，可根据需要增加新的请求处理类，满足OCP；</li>
<li>增强了给对象指派职责的灵活性，当工作流程发生变化，可动态地改变链内成员或调动次序，也可动态增加或删除责任；</li>
<li>责任链简化了对象间的连接，每个对象只需保持一个指向其后继者的引用，不需保持其它所有处理者的引用，避免了使用众多的if或<code>if...else</code>语句；</li>
<li>责任分担，每个类只需处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的<a href="/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="单一职责原则SRP">单一职责原则SRP</a>。</li>
</ul>
</li>
<li>缺点：<ul>
<li>不能保证每个请求一定被处理，由于一个请求没有明确的接收者，所以不能保证一定会被处理，该请求可能一直传到链的末端都得不到处理；</li>
<li>对比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响；</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如<code>可能会造成循环调用</code>。</li>
</ul>
</li>
</ul>
<h2 id="责任链模式的结构与实现"><a href="#责任链模式的结构与实现" class="headerlink" title="责任链模式的结构与实现"></a>责任链模式的结构与实现</h2><p>通常情况下，通过数据链表来实现责任链模式的数据结构。</p>
<h3 id="责任链模式的结构"><a href="#责任链模式的结构" class="headerlink" title="责任链模式的结构"></a>责任链模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="责任链模式"></p>
<ol>
<li>抽象处理者角色Handler：定义一个处理请求的接口，包含抽象处理方法和一个后继连接；</li>
<li>具体处理者角色<code>Concrete Handler</code>：实现抽象处理者的处理方法；<ol>
<li>判断能否处理本次请求，如果可以处理请求则处理；</li>
<li>不能处理请求，将请求转给其后继者；</li>
</ol>
</li>
<li>客户类角色：创建处理链，并向链头的具体处理者对象提交请求，不关心处理细节和请求的传递过程。</li>
</ol>
<h2 id="责任链模式的应用场景"><a href="#责任链模式的应用场景" class="headerlink" title="责任链模式的应用场景"></a>责任链模式的应用场景</h2><ul>
<li>有多个对象可处理一个请求，哪个对象处理该请求由运行时自动确定；</li>
<li>可动态指定一组对象处理请求，或添加新的处理者；</li>
<li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li>
</ul>
<h2 id="责任链模式的扩展"><a href="#责任链模式的扩展" class="headerlink" title="责任链模式的扩展"></a>责任链模式的扩展</h2><ol>
<li>单纯职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下行为；<ol>
<li>自行处理/承担责任；</li>
<li>将责任推给下家处理；</li>
</ol>
</li>
<li>不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后将剩余的责任传给下家，且一个请求可以最终不被任何接收端对象所接收。</li>
</ol>
<h1 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h1><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p>
<p>有状态的对象：软件开发中，应用程序中的有些对象可能会根据不同的情况作出不同的行为；当有状态的对象与外部事件产生互动时，其内部状态会发送改变，从而使其行为随之改变。<br>状态：影响对象行为的一个或多个动态变化的属性。</p>
<p>思想：当控制一个对象状态转换的条件表达式过于复杂时，把相关<strong>判断逻辑</strong>提取出来，放到一系列的状态类中，从而将复杂的逻辑判断简单化。</p>
<p>状态模式，指对有状态的对象，把复杂的判断逻辑提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<h2 id="状态模式的特点"><a href="#状态模式的特点" class="headerlink" title="状态模式的特点"></a>状态模式的特点</h2><ul>
<li>优点：<ul>
<li>状态模式将与特定状态相关的行为局部化到一个状态中，并将不同状态的行为分隔开，满足<a href="/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="单一职责原则SRP">单一职责原则SRP</a>;</li>
<li>减少对象间的相互依赖，将不同的状态引入独立的对象中会使得状态转变得更加明确，且减少对象间的相互依赖；</li>
<li>有利于程序的扩展，通过定义新的子类很容易的增加新的状态和转换；</li>
</ul>
</li>
<li>缺点：<ul>
<li>状态模式的使用必然会增加系统的类与对象的个数；</li>
<li>状态模式的结构与实现都较为复杂，如使用不当会导致程序结构和代码混乱。</li>
</ul>
</li>
</ul>
<h2 id="状态模式的结构与实现"><a href="#状态模式的结构与实现" class="headerlink" title="状态模式的结构与实现"></a>状态模式的结构与实现</h2><h3 id="状态模式的结构"><a href="#状态模式的结构" class="headerlink" title="状态模式的结构"></a>状态模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt="状态模式"></p>
<ol>
<li>环境角色/上下文Context：定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理；</li>
<li>抽象状态角色State：定义一个接口，用以封装环境对象中的特定状态所对应的行为；</li>
<li>具体状态角色<code>Concrete State</code>：实现抽象状态所对应的行为。</li>
</ol>
<h2 id="状态模式的应用场景"><a href="#状态模式的应用场景" class="headerlink" title="状态模式的应用场景"></a>状态模式的应用场景</h2><ul>
<li>当一个对象的行为取决于它的状态，并且必须在运行时根据状态改变其行为时，就可考虑使用状态模式；</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h2 id="状态模式的扩展"><a href="#状态模式的扩展" class="headerlink" title="状态模式的扩展"></a>状态模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt="共享状态模式"></p>
<p>当有多个环境对象需要共享一组状态时，需要引入享元模式，将这些具体状态对象放在集合中供程序共享。</p>
<p>共享状态模式的不同之处是在环境类中增加了一个HashMap来保存相关状态，当需要某种状态时可从中获取。</p>
<h1 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h1><p>多个对象间存在一对多关系，当一个对象发生改变时，<strong>把这种改变通知给其它多个对象</strong>，从而影响其它对象的行为。</p>
<p>观察者模式，又称<strong>发布-订阅模式、模型-视图模式</strong>，指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知，并被自动更新。</p>
<p>观察者模式是一种<strong>对象行为型</strong>模式，具有如下特点：</p>
<ol>
<li>优点：<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是<strong>抽象耦合关系</strong>；</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
</li>
<li>缺点：<ol>
<li>目标与观察者之间的<strong>依赖关系</strong>并没有完全接触，而且有可能出现<strong>循环引用</strong>；</li>
<li>当观察者对象较多时，通知的发布会花费很多时间，影响程序效率。</li>
</ol>
</li>
</ol>
<h2 id="观察者模式的结构与实现"><a href="#观察者模式的结构与实现" class="headerlink" title="观察者模式的结构与实现"></a>观察者模式的结构与实现</h2><p><strong>具体目标对象和具体观察者对象间不能直接调用</strong>，否则会将两者紧密耦合，违反OOP设计原则。</p>
<h3 id="观察者的结构："><a href="#观察者的结构：" class="headerlink" title="观察者的结构："></a>观察者的结构：</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="观察者模式结构图"></p>
<ol>
<li>抽象主题角色Subject：也称抽象目标类，提供了一个用于<strong>保存观察者对象的聚集类</strong>和<strong>增加、删除观察者对象的方法</strong>，以及<strong>通知所有观察者的抽象方法</strong>。</li>
<li>具体主题角色<code>Concrete Subject</code>：，也称具体目标类，<strong>实现抽象目标中的通知方法</strong>，当具体主题的内部状态发生改变时，<strong>通知所有注册过的观察者对象</strong>。</li>
<li>抽象观察者角色Observer：一个抽象类/接口，包含了一个<strong>更新自己的抽象方法</strong>，当接到具体主题的更改通知时被调用。</li>
<li>具体观察者角色<code>Concrete Observer</code>：实现抽象观察者中定义的抽象方法，以便在<strong>得到目标的改变通知时更新自身的状态</strong>。</li>
</ol>
<h3 id="事件监听处理"><a href="#事件监听处理" class="headerlink" title="事件监听处理"></a>事件监听处理</h3><p>观察者模式在软件开发中用的最多的是<strong>窗体程序设计中的事件处理</strong>，<strong>窗体中的所有组件都是事件源，即目标对象</strong>，而<strong>事件处理程序类的对象是具体观察者对象</strong>。</p>
<h2 id="观察者模式应用场景"><a href="#观察者模式应用场景" class="headerlink" title="观察者模式应用场景"></a>观察者模式应用场景</h2><ul>
<li>对象间存在一对多的关系，一个对象的状态改变发生会影响其它对象。</li>
<li>当一个抽象模型有两方面，一方面依赖于另一方面时，可将二者封装在独立的对象中以使其可以各自独立的改变和复用。</li>
</ul>
<h2 id="观察者模式扩展"><a href="#观察者模式扩展" class="headerlink" title="观察者模式扩展"></a>观察者模式扩展</h2><p>Java中，通过<code>java.util.Observable</code>类和<code>java.util.Observer</code>接口定义了观察者模式，只要实现其子类即可编写观察者模式实例。</p>
<h3 id="Observable类"><a href="#Observable类" class="headerlink" title="Observable类"></a>Observable类</h3><p>Observable类是抽象目标类，有一个Vector向量，用于保存所有要通知的观察者对象。</p>
<ol>
<li><code>void addObserver(Observer o)</code>方法：用于将新的观察者添加到向量中；</li>
<li><code>void notifyObservers(Object arg)</code>方法：调用向量中的所有观察者对象的update方法，通知它们数据发生改变，通常越晚加入向量的观察者越先得到通知；</li>
<li><code>void setChange()</code>方法：用来设置一个boolean类型的内部标识位，注明目标对象发生类变化，当为真时，notifyObservers()才会通知观察者。</li>
</ol>
<h3 id="Observer接口"><a href="#Observer接口" class="headerlink" title="Observer接口"></a>Observer接口</h3><p>Observer接口是抽象观察者，监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用<code>void update(Observable o, Object arg)</code>方法执行更新。</p>
<h1 id="中介者模式-调停模式-Mediator"><a href="#中介者模式-调停模式-Mediator" class="headerlink" title="中介者模式/调停模式 Mediator"></a>中介者模式/调停模式 Mediator</h1><p>定义一个中介对象来简化原有对象间的交互关系，降低系统对象间的耦合度，使原有对象间不必相互了解。</p>
<p>中介者模式，是<a href="/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="迪米特法则LoD">迪米特法则LoD</a>的典型应用，通过定义一个中介对象来封装一系列对象间的交互，使原有对象间的耦合松散，且可以独立的改变它们之间的交互。</p>
<h2 id="中介者模式的特点"><a href="#中介者模式的特点" class="headerlink" title="中介者模式的特点"></a>中介者模式的特点</h2><ul>
<li>优点：<ul>
<li>降低了对象间的耦合性，使对象易于独立的被复用；</li>
<li>将对象间的一对多关联转为一对一关联，提高了系统的灵活性，使系统易于维护和扩展；</li>
</ul>
</li>
<li>缺点：<ul>
<li>当同事类太多时，中介者的职责会变得复杂而庞大，以至于系统难以维护。</li>
</ul>
</li>
</ul>
<h2 id="中介者模式的结构与实现"><a href="#中介者模式的结构与实现" class="headerlink" title="中介者模式的结构与实现"></a>中介者模式的结构与实现</h2><h3 id="中介者模式的结构"><a href="#中介者模式的结构" class="headerlink" title="中介者模式的结构"></a>中介者模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="中介者模式"></p>
<ol>
<li>抽象中介者角色Mediator：中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法；</li>
<li>具体中介者角色<code>Concrete Mediator</code>：实现中介者接口，定义一个List来管理同事对象，协调各个同事角色间的交互，依赖于同事角色；</li>
<li>抽象同事类角色Colleague：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能；</li>
<li>具体同事类角色：抽象同事类的实现者，当需要与其它同事对象交互时，由中介者对象负责后续交互。</li>
</ol>
<h3 id="中介者模式的实现"><a href="#中介者模式的实现" class="headerlink" title="中介者模式的实现"></a>中介者模式的实现</h3><p>中介者模式实现的关键是<strong>找出中介者</strong>。</p>
<h2 id="中介者模式的应用场景"><a href="#中介者模式的应用场景" class="headerlink" title="中介者模式的应用场景"></a>中介者模式的应用场景</h2><ul>
<li>当对象间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时；</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
</ul>
<h2 id="中介者模式的扩展"><a href="#中介者模式的扩展" class="headerlink" title="中介者模式的扩展"></a>中介者模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%AE%80%E5%8C%96%E7%9A%84%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="简化的中介者模式"></p>
<ol>
<li>不定义中介者接口，把具体中介者对象实现成单例。</li>
<li>同事对象不持有中介者，在需要时直接获取中介者对象并调用。</li>
</ol>
<h1 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h1><p>提供一种方法/一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<p>迭代器模式，是一种对象行为型模式，在客户访问类和聚合类间插入一个迭代器，分离了聚合对象与其遍历行为，对客户隐藏了其内部细节，且满足SRP和OCP。<br>如Java中的Collection、List、Set、Map等都包含了迭代器。</p>
<h2 id="迭代器模式的特点"><a href="#迭代器模式的特点" class="headerlink" title="迭代器模式的特点"></a>迭代器模式的特点</h2><ul>
<li>优点：<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示；</li>
<li>遍历任务交给迭代器完成，简化了聚合类；</li>
<li>支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类支持新的遍历；</li>
<li>增加新的聚合类和迭代器无须修改原代码；</li>
<li>封装性好，为遍历不同的聚合结构提供一个统一接口。</li>
</ul>
</li>
<li>缺点：<ul>
<li>增加了类的个数，在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
</ul>
<h2 id="迭代器模式的结构与实现"><a href="#迭代器模式的结构与实现" class="headerlink" title="迭代器模式的结构与实现"></a>迭代器模式的结构与实现</h2><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明的访问聚合的内部数据。</p>
<h3 id="迭代器模式的结构"><a href="#迭代器模式的结构" class="headerlink" title="迭代器模式的结构"></a>迭代器模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="迭代器模式"></p>
<ol>
<li>抽象聚合角色Aggregate：定义存储、添加、删除聚合对象以及创建迭代器对象的接口；</li>
<li>具体聚合角色<code>Concrete Aggregate</code>：实现抽象聚合类，返回一个具体迭代器的实例；</li>
<li>抽象迭代器Iterator：定义访问和遍历聚合元素的接口，通常包含hasNext()、first()、next()等方法；</li>
<li>具体迭代器角色<code>Concrete Iterator</code>：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
</ol>
<h2 id="迭代器模式的应用场景"><a href="#迭代器模式的应用场景" class="headerlink" title="迭代器模式的应用场景"></a>迭代器模式的应用场景</h2><ul>
<li>当需要为聚合对象提供多种遍历方式时；</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时；</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ul>
<h2 id="迭代器模式的扩展"><a href="#迭代器模式的扩展" class="headerlink" title="迭代器模式的扩展"></a>迭代器模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BB%84%E5%90%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="组合迭代器模式"></p>
<p>迭代器模式通常与组合模式结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中，也可以构造一个外部迭代器来对容器构件进行访问。</p>
<h1 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式 Visitor"></a>访问者模式 Visitor</h1><p>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即<strong>每个元素有多个访问者对象访问</strong>。</p>
<p>访问者模式能把处理方法从数据结构(被处理的数据元素相对稳定而访问方式多种多样)中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码和数据结构，提高了程序的扩展性和灵活性。<br>访问者模式，将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式，是<strong>行为类模式</strong>中<strong>最复杂</strong>的一种模式。</p>
<h2 id="访问者模式的特点"><a href="#访问者模式的特点" class="headerlink" title="访问者模式的特点"></a>访问者模式的特点</h2><ul>
<li>优点：<ul>
<li>扩展性好，能在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能；</li>
<li>复用性好，可通过访问者来定义整个对象结构通用的功能，提高系统的复用程度；</li>
<li>灵活性好，访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构；</li>
<li>符合SRP，访问者模式将相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一；</li>
</ul>
</li>
<li>缺点：<ul>
<li>增加新的元素类困难，每增加一个新的元素类都要在每一个具体访问者类中增加相应的具体操作，违背了OCP；</li>
<li>破坏封装，访问者模式中具体元素对访问者公布细节，破坏了对象的封装性；</li>
<li>违反了<a href="/2020/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="依赖倒置原则DIP">依赖倒置原则DIP</a>，访问者模式将相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ul>
</li>
</ul>
<h2 id="访问者模式的结构与实现"><a href="#访问者模式的结构与实现" class="headerlink" title="访问者模式的结构与实现"></a>访问者模式的结构与实现</h2><h3 id="访问者模式的结构"><a href="#访问者模式的结构" class="headerlink" title="访问者模式的结构"></a>访问者模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="访问者模式"></p>
<ol>
<li>抽象访问者角色Visitor：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作visit()，该操作中的参数类型标识了被访问的具体元素；</li>
<li>具体访问者角色<code>Concrete Visitor</code>：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么；</li>
<li>抽象元素角色Element：声明一个包含接受操作accept()的接口，被接受的访问者对象作为accept()方法的参数；</li>
<li>具体元素角色<code>Concrete Element</code>：实现抽象元素角色提供的accept()操作，其方法体通常是visitor.visit(this)，另外具体元素中可能还包含本身业务逻辑的相关操作；</li>
<li>对象结构角色<code>Object Structure</code>：一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由List、Set、Map等聚合类实现。</li>
</ol>
<h2 id="访问者模式的应用场景"><a href="#访问者模式的应用场景" class="headerlink" title="访问者模式的应用场景"></a>访问者模式的应用场景</h2><ul>
<li>对象结构相对稳定，但其操作算法经常变化的程序；</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构；</li>
<li>对象结构包含多种类型的对象，希望对这些对象实施一些依赖于具体类型的操作。</li>
</ul>
<h2 id="访问者模式的扩展"><a href="#访问者模式的扩展" class="headerlink" title="访问者模式的扩展"></a>访问者模式的扩展</h2><h3 id="访问者模式-amp-迭代器模式"><a href="#访问者模式-amp-迭代器模式" class="headerlink" title="访问者模式&amp;迭代器模式"></a>访问者模式&amp;迭代器模式</h3><p>访问者模式中的对象结构是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，通常要用迭代器。</p>
<p>如果对象结构中的聚合类没有提供迭代器，可用迭代器模式自定义一个。</p>
<h3 id="访问者模式-amp-组合模式"><a href="#访问者模式-amp-组合模式" class="headerlink" title="访问者模式&amp;组合模式"></a>访问者模式&amp;组合模式</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F_%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.png" alt="访问者模式_组合模式"></p>
<p>访问者模式中的元素对象可能是叶子对象或容器对象，如果元素对象包含容器对象，必须用到组合模式。</p>
<h1 id="备忘录模式-快照模式-Memento"><a href="#备忘录模式-快照模式-Memento" class="headerlink" title="备忘录模式/快照模式 Memento"></a>备忘录模式/快照模式 Memento</h1><p>在不破坏封装性的前提下，<strong>获取并保存一个对象的内部状态</strong>，以便日后恢复它。</p>
<p>备忘录模式，一种对象行为型模式，能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。</p>
<h2 id="备忘录模式的特点"><a href="#备忘录模式的特点" class="headerlink" title="备忘录模式的特点"></a>备忘录模式的特点</h2><ul>
<li>优点：<ul>
<li>提高了一种可以恢复状态的机制，当用户需要时能比较方便的将数据恢复到某个历史状态；</li>
<li>实现了内部状态的封装，除了创建它的发起人外，其它对象都不能访问这些状态信息；</li>
<li>简化了发起人，发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，符合SRP；</li>
</ul>
</li>
<li>缺点：<ul>
<li>资源消耗大，如果要保存的内部状态信息过多或特别频繁，将会占用较大的内存资源。</li>
</ul>
</li>
</ul>
<h2 id="备忘录模式的结构与实现"><a href="#备忘录模式的结构与实现" class="headerlink" title="备忘录模式的结构与实现"></a>备忘录模式的结构与实现</h2><p>备忘录模式的核心是设计备忘录类及用于管理备忘录的管理者类。</p>
<h3 id="备忘录模式的结构"><a href="#备忘录模式的结构" class="headerlink" title="备忘录模式的结构"></a>备忘录模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt="备忘录模式"></p>
<ol>
<li>发起人角色Originator：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其它业务功能，可以访问备忘录里的所有信息；</li>
<li>备忘录角色Memento：负责存储发起人的内部状态，在需要时提供内部状态给发起人；</li>
<li>管理者角色Caretaker：对备忘录进行管理，提供保存与获取备忘录的功能，但不能对备忘录的内容进行访问与修改。</li>
</ol>
<h2 id="备忘录模式的应用场景"><a href="#备忘录模式的应用场景" class="headerlink" title="备忘录模式的应用场景"></a>备忘录模式的应用场景</h2><ul>
<li>需要保存与恢复数据的场景，如游戏中的存档功能；</li>
<li>需要提供一个可回滚操作的场景，如编辑软件的撤销，数据库中的事务操作。</li>
</ul>
<h2 id="备忘录模式的扩展"><a href="#备忘录模式的扩展" class="headerlink" title="备忘录模式的扩展"></a>备忘录模式的扩展</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F_%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" alt="备忘录模式_原型模式"></p>
<p>在备忘录模式中，通过定义备忘录来备份发起人信息，而原型模式的clone()方法具有自备份功能，所以，如果让发起人实现Cloneable接口就有备份自己的功能，此时可删除备忘录类。</p>
<h1 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式 Interpreter"></a>解释器模式 Interpreter</h1><p>提供如何定义语言的文法(语法规则)，以及对语言句子(语言集中的元素)的解释方法，即解释器。</p>
<p>解释器模式，给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子，即用编译语言的方式来分析应用中的实例。<br>解释器模式，是一种类行为型模式，实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p>
<h2 id="解释器模式的特点"><a href="#解释器模式的特点" class="headerlink" title="解释器模式的特点"></a>解释器模式的特点</h2><ul>
<li>优点：<ul>
<li>扩展性好，由于在解释器模式中使用类来表示语言的文法规则，因此可通过继承等机制来改变或扩展语法；</li>
<li>易实现，在语法树中的每个表达式结点类都是相似的，实现其文法较容易；</li>
</ul>
</li>
<li>缺点：<ul>
<li>执行效率低，解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度较慢，且代码的调试过程也比较麻烦；</li>
<li>会引起类膨胀，每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理和维护；</li>
<li>可应用的场景较少，在软件开发中，需要定义语言文法的应用实例非常少。</li>
</ul>
</li>
</ul>
<h2 id="解释器模式的结构与实现"><a href="#解释器模式的结构与实现" class="headerlink" title="解释器模式的结构与实现"></a>解释器模式的结构与实现</h2><ol>
<li>文法：用于描述语言的语法结构的形式规则。</li>
<li>句子：语言的基本单位，是语言集中的一个元素，由终结符构成，能由文法推出。</li>
<li>语法树：句子结构的一种树形表示，代表了句子的推导结果，有利于理解句子语法结构的层次。</li>
</ol>
<h3 id="解释器模式的结构"><a href="#解释器模式的结构" class="headerlink" title="解释器模式的结构"></a>解释器模式的结构</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="解释器模式"></p>
<ol>
<li>抽象表达式角色<code>Abstract Expression</code>：定义解释器的接口，约定解释器的解释操作，主要包含解释方法interpret()；</li>
<li>终结符表达式角色<code>Terminal Expression</code>：抽象表达式的子类，实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之对应；</li>
<li>非终结符表达式角色<code>Nonterminal Expression</code>：抽象表达式的子类，实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式；</li>
<li>环境角色Context：通常包含各个解释器需要的数据或公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值；</li>
<li>客户端Client：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，也可通过环境角色间接访问解释器的解释方法。</li>
</ol>
<h3 id="解释器模式的实现"><a href="#解释器模式的实现" class="headerlink" title="解释器模式的实现"></a>解释器模式的实现</h3><p>解释器模式实现的关键是定义文法规则、设计终结符类和非终结符类、画出结构图，必要时创建语法树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象表达式类</span><br><span class="line">interface AbstractExpression</span><br><span class="line">&#123;</span><br><span class="line">    public Object interpret(String info);    &#x2F;&#x2F;解释方法</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;终结符表达式类</span><br><span class="line">class TerminalExpression implements AbstractExpression</span><br><span class="line">&#123;</span><br><span class="line">    public Object interpret(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;对终结符表达式的处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;非终结符表达式类</span><br><span class="line">class NonterminalExpression implements AbstractExpression</span><br><span class="line">&#123;</span><br><span class="line">    private AbstractExpression exp1;</span><br><span class="line">    private AbstractExpression exp2;</span><br><span class="line">    public Object interpret(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;非对终结符表达式的处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;环境类</span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">    private AbstractExpression exp;</span><br><span class="line">    public Context()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;数据初始化</span><br><span class="line">    &#125;</span><br><span class="line">    public void operation(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;调用相关表达式类的解释方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解释器模式的应用场景"><a href="#解释器模式的应用场景" class="headerlink" title="解释器模式的应用场景"></a>解释器模式的应用场景</h2><ul>
<li>当语言的文法较简单，且执行效率不是关键问题时；</li>
<li>当问题重复出现，且可以用一种简单的语言来进行表达时；</li>
<li>当一个语言需要解释执行，并且语言中的句子可表示为一个抽象语法树的时候，如XML文档解释。</li>
</ul>
<h2 id="解释器模式的扩展"><a href="#解释器模式的扩展" class="headerlink" title="解释器模式的扩展"></a>解释器模式的扩展</h2><p>如果碰到对表达式的解释，在Java中可用Expression4J、MESP(Math Expression String Parser)或Jep等设计。</p>
<hr>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="http://c.biancheng.net/view/1317.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1317.html</a></li>
<li><a href="https://www.jianshu.com/p/4475b2e1f9ae" target="_blank" rel="noopener">https://www.jianshu.com/p/4475b2e1f9ae</a></li>
</ul>
]]></content>
  </entry>
</search>
