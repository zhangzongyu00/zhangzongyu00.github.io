<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Adam</title>
    <url>/2020/06/07/Adam/</url>
    <content><![CDATA[<h1 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h1><p>动量momentum借用了物理中的动量概念，即将前几次的梯度也加入计算过程。为了表示动量，引入了一个新的变量v。v是<strong>之前的梯度的累加</strong>，但每回合都有一定的衰减。</p>
<p>计算梯度估计：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$</p>
<p>计算更新：<br>$$v \leftarrow \alpha v - \epsilon \widehat{g}$$</p>
<p>应用更新：<br>$$\theta \leftarrow \theta + v$$</p>
<p>当前后梯度方向一致时，能够加速学习；前后梯度方向不一致时，能够抑制震荡。</p>
<h1 id="Nesterov-Momentum"><a href="#Nesterov-Momentum" class="headerlink" title="Nesterov Momentum"></a>Nesterov Momentum</h1><p><em>对momentum的改进</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Nesterov_Momentum.png" alt="Nesterov_Momentum"></p>
<p>计算梯度估计：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta + \alpha v),y_i)$$<br>计算更新：<br>$$v \leftarrow \alpha v - \epsilon \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + v$$</p>
<p>先对参数进行估计，然后使用估计后的参数来计算误差。</p>
<h1 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h1><p>主要解决：<strong>为不同参数设置不同的学习步长</strong>。</p>
<p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>累积平方梯度：<br>$$r \leftarrow r + \widehat{g} \odot \widehat{g}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \frac{\epsilon}{\delta + \sqrt{r}} \odot \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p>
<p><em>$\delta$为小常数，为了数值稳定，大约设置为$10^{-7}$</em>。</p>
<p>梯度越小，则学习步长越大；梯度越大，学习步长越小。即缓坡上大步跑，陡坡上小步挪。</p>
<h1 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h1><p><em>对Adagrad的改进</em></p>
<p>通过引入一个衰减系数，让r每回合都衰减一定比例。</p>
<p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>累积平方梯度：<br>$$r \leftarrow \rho r + (1 - \rho)\widehat{g} \odot \widehat{g}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \frac{\epsilon}{\delta + \sqrt{r}} \odot \widehat{g}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p>
<p>解决了Adagrad过早结束时间问题，适合处理非平稳目标，对RNN效果好。</p>
<h1 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h1><p>来源于<code>adaptive moment estimation</code>，自适应矩估计。</p>
<p>Adam本质上是带有动量项的RMSprop，利用梯度的一阶矩估计和二阶矩估计来动态调整每个参数的学习率。</p>
<p>计算梯度：<br>$$\widehat{g} \leftarrow + \frac{1}{m} \bigtriangledown_\theta \sum_i L(f(x_i;\theta),y_i)$$<br>一阶矩估计：<br>$$s \leftarrow \rho_1 s + (1 - \rho_1) g$$<br>$$\widehat{s} \leftarrow \frac{s}{1 - \rho_1^t}$$<br>二阶矩估计：<br>$$r \leftarrow \rho_2 r + (1 - \rho_2) g \odot g$$<br>$$\widehat{r} \leftarrow \frac{r}{1 - \rho_2^t}$$<br>计算更新：<br>$$\bigtriangleup \theta = - \epsilon \frac{\widehat{s}}{\sqrt{\widehat{r}} + \delta}$$<br>应用更新：<br>$$\theta \leftarrow \theta + \bigtriangleup \theta$$</p>
<h1 id="几种梯度下降算法比较"><a href="#几种梯度下降算法比较" class="headerlink" title="几种梯度下降算法比较"></a>几种梯度下降算法比较</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Adam%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="Adam梯度下降算法比较"></p>
<ol>
<li>在minist上训练多层神经网络；</li>
<li>在cifar10上训练卷积神经网络。</li>
</ol>
<p>参考：<br><a href="https://blog.csdn.net/program_developer/article/details/80756008" target="_blank" rel="noopener">https://blog.csdn.net/program_developer/article/details/80756008</a></p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
  </entry>
  <entry>
    <title>GrabCut分割</title>
    <url>/2020/06/06/GrabCut%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="GrabCut分割"><a href="#GrabCut分割" class="headerlink" title="GrabCut分割"></a>GrabCut分割</h1><p>前景/背景的颜色模型：</p>
<ul>
<li>假定前景和背景为高斯混合模型GMM；</li>
<li>对于每个要素，均来自于目标GMM/背景GMM的某个高斯分量；</li>
<li>用边界项来表示邻域像素间不连续的惩罚，若两邻域像素差别很小，则属于同一目标/背景的可能性就大，反之可能为边缘；</li>
<li>通过<a href="/2020/06/06/kmeans%E8%81%9A%E7%B1%BB/" title="kmeans聚类">kmeans聚类</a>算法迭代获得。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GrabCut.png" alt="GrabCut"></p>
<p>算法流程：</p>
<ol>
<li>使用标记初始化颜色模型（k=5）；</li>
<li>迭代进行GraphCut；<ul>
<li>优化前景/背景的颜色模型；</li>
<li>能量会随着不断迭代变小；</li>
<li>分割效果也越来越好。</li>
</ul>
</li>
</ol>
<h2 id="高斯混合模型GMM"><a href="#高斯混合模型GMM" class="headerlink" title="高斯混合模型GMM"></a>高斯混合模型GMM</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GMM.png" alt="GMM"></p>
<p>两组点分别通过两个不同的正态分布随机生成。</p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>Alamofire框架</title>
    <url>/2020/06/22/Alamofire%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Alamofire（swift）"><a href="#Alamofire（swift）" class="headerlink" title="Alamofire（swift）"></a>Alamofire（swift）</h1><p>使用Cocoapods进行集成；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install cocoapods</span><br></pre></td></tr></table></figure>

<ol>
<li>在项目目录下进行pod初始化设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line"># platform :ios, &#39;9.0&#39;</span><br><span class="line"></span><br><span class="line">target &#39;***&#39; do</span><br><span class="line">  # Comment the next line if you don&#39;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # Pods for AlamofireTest</span><br><span class="line">  pod &#39;Alamofire&#39;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行更新<code>pod install</code>，不更新本地库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install --no-repo-update</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>打开文件目录下<code>***.xcworkspace</code></p>
</li>
<li><p>重新配置<code>Pods_***.framework</code><br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AEframework.png" alt="重新配置framework"></p>
</li>
<li><p>修改<code>Allow Arbitrary Loads</code>访问http请求权限<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Allow_Arbitrary_Loads.png" alt="Allow_Arbitrary_Loads"></p>
</li>
</ol>
<hr>
<p><em><code>http://httpbin.org</code>用于处理http/https的相关请求</em></p>
<p>在实际开发中，为了不过于依赖某一个第三方框架，常使用封装的方式，将其封装到某一工具类，方便其框架不更新时进行修改。</p>
]]></content>
      <categories>
        <category>ios开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客</title>
    <url>/2020/03/09/Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo-GitHub-Pages搭建个人博客"><a href="#Hexo-GitHub-Pages搭建个人博客" class="headerlink" title="Hexo + GitHub Pages搭建个人博客"></a>Hexo + GitHub Pages搭建个人博客</h1><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! </p>
<h2 id="创建Hexo"><a href="#创建Hexo" class="headerlink" title="创建Hexo"></a>创建Hexo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p><code>npm install</code> 报错，解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf ~&#x2F;.node-gyp</span><br><span class="line">sudo npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br><span class="line">sudo npm i --unsafe-perm</span><br></pre></td></tr></table></figure>
<p><em>配置后更新版本等会比较麻烦，不配置同样可以使用</em></p>
<h2 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h2><p>编辑 <code>_config.yml</code> 配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:***&#x2F;***.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p><code>ERROR Deployer not found: git</code> 报错，解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>遇到 <code>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</code> 问题，安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p><em>本人使用的是<a href="https://www.aliyun.com/?utm_content=se_1000301881&accounttraceid=52e2158134cd4376ab19089abd0757e9llgh" target="_blank" rel="noopener">阿里云</a>的域名</em></p>
<ol>
<li>在终端中 <code>ping ***.github.io</code> 得到一个ip地址，copy下来；</li>
<li>在阿里云域名设置中添加解析：<ul>
<li>主机记录–www，记录类型–A，解析线路–默认不修改，<br>  记录值为 <code>步骤1</code> 中ping到的ip，TTL–默认不修改；</li>
<li>主机记录–@，记录类型–A，解析线路–默认不修改，<br>  记录值为 <code>步骤1</code> 中ping到的ip，TTL–默认不修改；</li>
</ul>
</li>
<li>在GitHub中打开username.github.io仓库中的设置，找到 <code>Custom domain</code> 将自己的域名填入其中，点击保存；</li>
<li>在本地仓库中打开 <code>source</code> 文件夹，添加 <code>CNAME</code> 文件，内容为自己的域名；</li>
<li>重新部署，等待几分钟即可访问。</li>
</ol>
<h2 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h2><p>网上有大量主题可供使用，按照主题配置修改即可。<br>本博客基于<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next主题</a>进行配置。</p>
<h3 id="图标查询"><a href="#图标查询" class="headerlink" title="图标查询"></a><a href="https://fontawesome.dashgame.com" target="_blank" rel="noopener">图标查询</a></h3><p><a href="https://fontawesome.dashgame.com" target="_blank" rel="noopener">https://fontawesome.dashgame.com</a></p>
<h3 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><ol>
<li>在GitHub新建一个repositories用于存储图片；</li>
<li>在个人GitHub账户中的 <code>Settings</code> 中选择 <code>Developer settings</code> 创建 <code>Personal access tokens</code>，勾选 <code>repo</code> 一栏即可；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/picgo-token.png" alt="picgo-token"></li>
<li>安装PicGo；</li>
<li>配置PicGo（使用了cdn加速）；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/picgo-github.png" alt="picgo-github"></li>
<li>配置完成后即可上传图片了。</li>
</ol>
<h2 id="数学公式-最新版的直接在配置文件里的mathjax设为true即可"><a href="#数学公式-最新版的直接在配置文件里的mathjax设为true即可" class="headerlink" title="数学公式(最新版的直接在配置文件里的mathjax设为true即可)"></a>数学公式(最新版的直接在配置文件里的mathjax设为true即可)</h2><h3 id="安装插件：-1"><a href="#安装插件：-1" class="headerlink" title="安装插件："></a>安装插件：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure>

<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p><a href="https://www.livere.com/login_form" target="_blank" rel="noopener">livere</a>，参考下面博客美化设置。</p>
<h3 id="设置文章阴影效果"><a href="#设置文章阴影效果" class="headerlink" title="设置文章阴影效果"></a>设置文章阴影效果</h3><p>因为在网上没有找到适合新版本7.7的方法，自己摸索尝试解决：<br>找到 <code>/themes/next/source/css/_common/components/post/post.styl</code> 中的 <code>.use-motion</code> 块，修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (hexo-config(&#39;motion.transition.post_block&#39;)) &#123;</span><br><span class="line">  .post-block &#123;</span><br><span class="line">      opacity: 0;</span><br><span class="line">      background: transparent; &#x2F;&#x2F;透明</span><br><span class="line">  &#125;</span><br><span class="line">  .pagination, .comments &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://shenzekun.cn/hexo的next主题个性化配置教程.html" target="_blank" rel="noopener">http://shenzekun.cn/hexo的next主题个性化配置教程.html</a><br><a href="https://zhuanlan.zhihu.com/p/30836436" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30836436</a><br><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a><br><a href="https://tieba.baidu.com/p/6440743671" target="_blank" rel="noopener">https://tieba.baidu.com/p/6440743671</a><br><a href="https://www.cnblogs.com/aoguai/p/11481253.html" target="_blank" rel="noopener">https://www.cnblogs.com/aoguai/p/11481253.html</a><br><a href="https://blog.uuk4.com/2019/05/09/hexo中插入数学公式/" target="_blank" rel="noopener">https://blog.uuk4.com/2019/05/09/hexo中插入数学公式/</a></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java框架</title>
    <url>/2020/03/10/Java%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="SSM-框架集"><a href="#SSM-框架集" class="headerlink" title="SSM 框架集"></a>SSM 框架集</h1><table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">框架</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">Spring</td>
<td align="center">一个轻量的控制反转和面向切面的容器框架。其中，IOC容器，可装载bean(类)，减少使用类时的初始化；aop；事务管理等。</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">SpringMVC</td>
<td align="center">用于web层，相当于controller，用来处理用户请求。</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">MyBatis</td>
<td align="center">自由控制sql，提升数据库访问效率；使用xml方式组织管理sql，易于修改。</td>
</tr>
</tbody></table>
<p><strong>一般目录结构为：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">    - main          &#x2F;&#x2F; 用于存放java代码和一些资源文件</span><br><span class="line">        - java          &#x2F;&#x2F; 存放Java代码，使用Build Path-&gt;Use as Source Folder，新建的包相当于在这里新建文件夹</span><br><span class="line">            - dao           &#x2F;&#x2F; 数据访问层(接口)，与数据打交道，可以是数据库操作、文件读写操作、redis缓存操作等</span><br><span class="line">            - entity        &#x2F;&#x2F; 实体类，与数据库表相对应，封装dao层取出来的数据为一个对象，一般只在dao层与service层传输，存放与业务相关实体类</span><br><span class="line">            - dto           &#x2F;&#x2F; 数据传输层，用于service层与web层间的传输，很多时候一个entity不能满足业务需求，也可存放与业务相关性小的数据实体类</span><br><span class="line">            - service       &#x2F;&#x2F; 业务逻辑(接口)</span><br><span class="line">            - serviceImpl   &#x2F;&#x2F; 业务逻辑(实现)，实现业务接口，一般事物控制在此处</span><br><span class="line">            - web           &#x2F;&#x2F; 控制器，SpringMVC在此处发挥作用</span><br><span class="line">        - resources     &#x2F;&#x2F; 存放资源文件，如Spring，mybatis，log配置文件</span><br><span class="line">            - mapper        &#x2F;&#x2F; 存放dao中每个方法对应的sql</span><br><span class="line">            - spring        &#x2F;&#x2F; 存放Spring相关的配置文件，包含dao、service、web三层</span><br><span class="line">                - spring-dao.xml        &#x2F;&#x2F; 配置数据库连接池、配置连接属性等</span><br><span class="line">                - spring-service.xml    &#x2F;&#x2F; 配置事物管理器等</span><br><span class="line">                - spring-web.xml        &#x2F;&#x2F; 开启SpringMVC注解模式、对静态资源处理、扫描web层等</span><br><span class="line">                - mybatis-config.xml    &#x2F;&#x2F; 连接数据库时的相关配置，如驼峰命名转换等</span><br><span class="line">            - sql</span><br><span class="line">            - jdbc.properties   &#x2F;&#x2F; 数据库配置相关参数</span><br><span class="line">        - webapp        &#x2F;&#x2F; 存放前端的静态资源</span><br><span class="line">            - resources     &#x2F;&#x2F; 项目的静态资源</span><br><span class="line">            - css</span><br><span class="line">            - images</span><br><span class="line">            - js</span><br><span class="line">        - WEB-INF       &#x2F;&#x2F; 外部浏览器无法访问</span><br><span class="line">            - jsp</span><br><span class="line">            - lib       &#x2F;&#x2F; 用于管理jar包</span><br><span class="line">            web.xml     &#x2F;&#x2F; 全局配置</span><br><span class="line">    - test          &#x2F;&#x2F; 测试分支</span><br><span class="line">        - java          &#x2F;&#x2F; 测试Java代码，应遵循包名相同的原则，使用Build Path-&gt;Use as Source Folder</span><br><span class="line">        - resources</span><br><span class="line">pom.xml     &#x2F;&#x2F; 使用maven进行管理jar包，在pom.xml添加相应依赖</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h1><table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">框架内容</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M</td>
<td align="center">model</td>
<td align="center">处理数据逻辑部分，负责在数据库中读取数据</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">view</td>
<td align="center">处理数据显示部分，依据模型数据创建</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">control</td>
<td align="center">处理用户交互部分，负责从试图读取数据，控制用户输入，并向模型发送数据</td>
</tr>
</tbody></table>
<p>典型的MVC框架为 <code>JSP + servlet + javabean</code> 模式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphCuts分割</title>
    <url>/2020/06/06/GraphCuts%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="GraphCuts分割"><a href="#GraphCuts分割" class="headerlink" title="GraphCuts分割"></a>GraphCuts分割</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GraphCuts.png" alt="GraphCuts"></p>
<ul>
<li>普通顶点对应于图像中的每个像素。每两个邻域顶点的连接为一条边。</li>
<li>两个终端顶点：S(source:前景)、T(sink:背景)。每个普通顶点和这2个终端顶点进行连接，称为第二种边。</li>
</ul>
<p>GraphCuts中的Cuts指这样一个边的集合，该集合中的所有边的断开，会导致残留S和T图的分开，被称为割。<br>如果一个割，它的边的所有权值之和最小，就称其为<strong>最小割</strong>，即GraphCuts的结果。</p>
<p>基于能量的算法：<br>    $E(A) = \lambda \cdot R(A) + B(A)$<br>    $R(A) = \sum_{p \in \mathcal{P}} R_p(A_p)$<br>    $B(A) = \sum_{ {p,q} \in \mathcal{N} } B_{ {p,q} } \cdot \delta(A_p,A_q)$<br>    <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GraphCuts%E8%83%BD%E9%87%8F.png" alt="GraphCuts能量"><br><em>区域项R(A)、边界项B(A)</em></p>
<p>R是为像素p分配标签$I_p$的惩罚：<br>    当像素p的灰度值属于目标的概率大于背景，$R_p(1) &lt; R_p(0)$，即像素p更有可能属于目标时，将p归为目标会使能量R(L)更小。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%9B%BE%E5%89%B2%E5%89%8D%E8%83%8C%E6%99%AF%E5%88%86%E5%89%B2%E5%85%AC%E5%BC%8F.png" alt="图割前背景分割公式"><br>B是像素p和q之间不连续的惩罚，一般来说，如果p和q越相似，B越大；若非常不同，B趋向于0。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GraphCuts%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="GraphCuts基本操作过程"></p>
<p>基本操作过程：</p>
<ol>
<li>先取两个种子点；</li>
<li>然后建立一个图，图中边的粗细表示对应权值大小；</li>
<li>找到权值和最小的边的组合；</li>
<li>完成图像分割。</li>
</ol>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>Java测试</title>
    <url>/2020/03/10/Java%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="开发者测试"><a href="#开发者测试" class="headerlink" title="开发者测试"></a>开发者测试</h1><p><em>插件 eclemma查询覆盖率，最新版eclipse已内置</em></p>
<h2 id="利用junit进行测试，使用assert断言进行变异测试"><a href="#利用junit进行测试，使用assert断言进行变异测试" class="headerlink" title="利用junit进行测试，使用assert断言进行变异测试"></a>利用junit进行测试，使用assert断言进行变异测试</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Junit%E6%B5%8B%E8%AF%95.png" alt="Junit测试"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testNextDay() &#123;</span><br><span class="line">	assertEquals(10&#x2F;15&#x2F;2019,10&#x2F;14,2019);</span><br><span class="line">	assertEquals(11&#x2F;1&#x2F;2019,10&#x2F;31,2019);</span><br><span class="line">	assertEquals(2&#x2F;29&#x2F;2000,2&#x2F;28,2000);</span><br><span class="line">	assertEquals(2&#x2F;29&#x2F;2004,2&#x2F;28,2004);</span><br><span class="line">	assertEquals(3&#x2F;1&#x2F;2001,2&#x2F;28,2001);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test(expected&#x3D;ArithmeticException.class)</span><br><span class="line">&#x2F;&#x2F;抛出异常</span><br><span class="line">@Test(timeout&#x3D;毫秒)</span><br><span class="line">&#x2F;&#x2F;针对死循环进行测试</span><br><span class="line"></span><br><span class="line">@BeforeClass</span><br><span class="line">@AfterClass</span><br><span class="line">&#x2F;&#x2F;最先执行，static修饰</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">@After</span><br><span class="line">&#x2F;&#x2F;每个方法单独运行</span><br><span class="line">@Ignore</span><br><span class="line">&#x2F;&#x2F;该测试方法会被忽略</span><br><span class="line"></span><br><span class="line">@RunWith</span><br><span class="line">&#x2F;&#x2F;更改测试运行器org.junit.runner.Runner</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="移动应用测试"><a href="#移动应用测试" class="headerlink" title="移动应用测试"></a>移动应用测试</h1><h2 id="配置appium"><a href="#配置appium" class="headerlink" title="配置appium"></a>配置appium</h2><p>终端打开，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb connect xxx.xxx.xxx.xxx:5555</span><br></pre></td></tr></table></figure>
<p>将app的环境配置复制到appium中进行启动会话；</p>
<h2 id="利用Android-SDK中的UI工具进行组建-控件的查询"><a href="#利用Android-SDK中的UI工具进行组建-控件的查询" class="headerlink" title="利用Android SDK中的UI工具进行组建/控件的查询"></a>利用Android SDK中的UI工具进行组建/控件的查询</h2><p><em>与appium兼容性很差，经常需要关闭appium后再打开</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过id获取组件</span><br><span class="line">driver.findElementById(&quot;cn.etouch.ecalendar:id&#x2F;rl_toutiao_img&quot;).click();</span><br><span class="line">&#x2F;&#x2F;通过XPath获取组件</span><br><span class="line">driver.findElementByXPath(&quot;&#x2F;&#x2F;android.widget.TextView[@text&#x3D;&#39;头条&#39;]&quot;).click();</span><br><span class="line">driver.findElementById(&quot;cn.etouch.ecalendar:id&#x2F;fl_refresh_icon&quot;).click();</span><br><span class="line">&#x2F;&#x2F;返回</span><br><span class="line">driver.sendKeyEvent(AndroidKeyCode.BACK);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="自主可控测试"><a href="#自主可控测试" class="headerlink" title="自主可控测试"></a>自主可控测试</h1><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><ul>
<li>eclipse:<br>  driver.get(“url”);<br>  Thread.sleep(1000);</li>
<li>word:<br>  打开操作文档，按要求查找网页中对应的元素进行输入等操作；</li>
<li>chrome:<br>  F12 检索页面元素，获取元素xpath；</li>
<li>eclipse:<br>  driver.findElement(By.xpath(“//*[@id=&quot;username&quot;]”)).sendKeys(“username”);</li>
</ul>
<h2 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h2><ul>
<li>badboy录制脚本：<br>  输入网址，对测试部分进行录制，导出为jmeter文件</li>
<li>JMeter:<br>  打开录制好的文件，更改名称，更改线程组相关设置，左侧右键add-&gt;LogicController-&gt;TransactionController;将Step移动到Transaction下面，在最后一个操作右键add-&gt;Timer-&gt;SynchronizingTimer;修改组人数为10；在最后操作上进行参数化设置${name}；</li>
<li>创建csv文件：<br>  在文件右键add-&gt;ConfigElement-&gt;CSVDataSetConfig;修改VariableNames为对应的名称即可。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM设计模式</title>
    <url>/2020/06/23/MVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/mvc.png" alt="mvc"></p>
<p>所有的对象都可以被归类为一个model，一个view，或一个controller。</p>
<p><em>部分代码没有合适的存放位置，如网络请求部分。</em></p>
<p>弊端：</p>
<ul>
<li>大量的代码被放到controller，臃肿；</li>
<li>controller规模庞大，难以维护；</li>
<li>属性较多，难以管理；</li>
<li>遵循较多协议，protocol的响应代码和controller的逻辑代码混杂。</li>
</ul>
<h1 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/mvvm.jpg" alt="mvvm"></p>
<p>引入新的组件ViewModel，放置用户输入验证逻辑、视图显示逻辑、发起网络请求、数据解析等。<br>项目中的请求数据，统一交给ViewModel管理，每个控制器对应一个专属ViewModel。</p>
]]></content>
      <categories>
        <category>ios开发</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程</title>
    <url>/2020/03/10/Java%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE.jpg" alt="Java集合类图"></p>
<p>LinkedList类实现了Queue接口，因此可以将LinkedList当成Queue来用。</p>
<p>集合特点：</p>
<ul>
<li><p>List：有序、可重复；</p>
<ul>
<li><p>ArrayList：数组-查询快、增删慢；<br>扩容机制：</p>
<ol>
<li>先对传进来的初始化参数initalCapcity初始容量进行判断，若为0初始化为一个空数组；若非空，则初始化一个容量为10的数组；</li>
<li>扩容：当数组大小 &gt; 初始容量时，扩容为原来的1.5倍；</li>
<li>扩容方式：对原数组进行拷贝为新数组，原数组被GC回收。</li>
</ol>
</li>
<li><p>LinkedList：链表-查询慢、增删快；</p>
</li>
</ul>
</li>
<li><p>Set：有序、不可重复；</p>
<ul>
<li>TreeSet：遍历时必须在实现类实现Comparable接口，重写ComparaTo方法；</li>
<li>HashSet：使用成员对象来计算hashcode值，使用equals()判断对象是否相等。</li>
</ul>
</li>
<li><p>Map：键值对，键不重复；</p>
<ul>
<li>HashMap：不保存对象的排列次序，允许键值为null、非Synchronized，但collection框架可保证Synchronized；</li>
<li>TreeMap：保存对象的排列次序。</li>
</ul>
</li>
</ul>
<h1 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h1><h2 id="websocket：持久化协议"><a href="#websocket：持久化协议" class="headerlink" title="websocket：持久化协议"></a>websocket：持久化协议</h2><p>实现服务器端主动向客户端推送信息，客户端也可主动向服务器发送请求，实现双向对话。<br>具体来讲，就是先通过客户端使用http协议向服务器发送请求，建立长链接；建立长链接之后，服务器即可主动向客户端发送消息；确定一个时间，经过该时间后，客户端向服务器发送请求确认，避免该🔗断开。</p>
<p><em>为了兼容浏览器，在握手阶段使用HTTP协议。</em></p>
<ul>
<li>websocket建立在TCP协议上，服务器端端实现较容易；</li>
<li>与HTTP协议兼容性较好，默认端口为80或443，可通过http代理的服务器；</li>
<li>数据格式轻量，性能开销较小，通信高效；</li>
<li>可以发送文本，也可以发送二进制数据；</li>
<li>没有同源限制，客户端可以与任意服务器通信；</li>
<li>协议表示符是ws，若需🔐，使用wss，服务器网址为url。</li>
</ul>
<h2 id="典型的websocket🤝"><a href="#典型的websocket🤝" class="headerlink" title="典型的websocket🤝"></a>典型的websocket🤝</h2><ul>
<li>浏览器请求：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket			&#x2F;&#x2F; websocket协议</span><br><span class="line">Connection: Upgrade			&#x2F;&#x2F; 告诉服务器，发起的请求为Upgrade对应的websocket协议</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;			&#x2F;&#x2F; Base64 encode值，由浏览器自动生成，用于验证是否使用websocket协议</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat			&#x2F;&#x2F; 用户定义的字符串，用于区分URL下不同服务所需要的协议</span><br><span class="line">Sec-WebSocket-Version: 13			&#x2F;&#x2F; websocket版本</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure></li>
<li>服务器返回：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对比HTTP"><a href="#对比HTTP" class="headerlink" title="对比HTTP"></a>对比HTTP</h2><table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">区别</th>
</tr>
</thead>
<tbody><tr>
<td align="center">http1.0</td>
<td align="center">生命周期通过request界定，一个request对应一个response</td>
</tr>
<tr>
<td align="center">http1.1</td>
<td align="center">添加一个keep-alive，可将多个http请求合并为一个，即在一个http链接🀄️，可以发送多个request，接受对应多个response</td>
</tr>
</tbody></table>
<p><em>response是被动的，不能主动发起。</em></p>
<p><em>参考：</em><br><a href="https://www.cnblogs.com/jieerma666/p/10342435.html" target="_blank" rel="noopener">用JAVA分别实现WebSocket客户端与服务端</a><br><a href="https://www.cnblogs.com/nnngu/p/9347635.html" target="_blank" rel="noopener">看完让你彻底理解 WebSocket 原理，附完整的实战代码</a><br><a href="https://blog.csdn.net/u013967628/article/details/85210036" target="_blank" rel="noopener">Java双向队列Deque栈与队列</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac常用配置</title>
    <url>/2020/03/08/Mac%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Mac布局设置"><a href="#Mac布局设置" class="headerlink" title="Mac布局设置"></a>Mac布局设置</h1><h2 id="重置dock"><a href="#重置dock" class="headerlink" title="重置dock"></a>重置dock</h2><p>在使用过程中，dock可帮助我们更方便快捷的打开、查看打开的软件/程序/文稿等。<br>对于爱瞎折腾的我来说，经常不满意自己的dock图标的设置，所以可使用如下命令恢复初始布局。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults delete com.apple.dock; killall Dock</span><br></pre></td></tr></table></figure>
<p>Tip：此操作会使启动台及桌面4角的热键打乱，均需重新调整。</p>
<h2 id="启动台图标混乱"><a href="#启动台图标混乱" class="headerlink" title="启动台图标混乱"></a>启动台图标混乱</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm ~&#x2F;Library&#x2F;Application\ Support&#x2F;Dock&#x2F;*.db &amp;&amp; killall Dock</span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool true &amp;&amp; killall Dock</span><br></pre></td></tr></table></figure>

<h2 id="使Mac保持清醒（尝试过，但好像没用）"><a href="#使Mac保持清醒（尝试过，但好像没用）" class="headerlink" title="使Mac保持清醒（尝试过，但好像没用）"></a>使Mac保持清醒（尝试过，但好像没用）</h2><p>在<code>terminal</code>使用<code>caffeinate</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">caffeinate -i -t 3600</span><br></pre></td></tr></table></figure>
<p><em>3600代表秒数，3600s=1h</em></p>
<hr>
<h1 id="MAC终端个性化设置"><a href="#MAC终端个性化设置" class="headerlink" title="MAC终端个性化设置"></a>MAC终端个性化设置</h1><h2 id="在bash中省略前缀（现在基本使用zsh代替，配置方式基本相同）"><a href="#在bash中省略前缀（现在基本使用zsh代替，配置方式基本相同）" class="headerlink" title="在bash中省略前缀（现在基本使用zsh代替，配置方式基本相同）"></a>在bash中省略前缀（现在基本使用zsh代替，配置方式基本相同）</h2><p>打开终端，对bashrc进行编辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure>
<p>滑动至最底部，选择PS1行进行修改即可。</p>
<p>默认设置 <code>PS1=&quot;%n@%m %1~ %# &quot;</code></p>
<p><em>命令列表的参数：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\u 显示当前用户的用户名（user name）</span><br><span class="line">\h 显示主机名（host name）</span><br><span class="line">\W 显示当前工作目录的名字（work directory）</span><br><span class="line">\w 当前所在的完整路径</span><br><span class="line">\$ 显示$符作为提示符，如果用户是root的话，则显示#号</span><br><span class="line">\d 现在的系统日期</span><br><span class="line">\t 现在的系统时间</span><br></pre></td></tr></table></figure>

<p><strong>zshrc同理，配置文件为 <code>/etc/zshrc</code></strong></p>
<h2 id="使用zsh代替bash"><a href="#使用zsh代替bash" class="headerlink" title="使用zsh代替bash"></a>使用zsh代替bash</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure>
<ul>
<li>bash的环境变量为<code>.bash_profile</code>;</li>
<li>zsh的环境变量为<code>.zshrc</code>;<br>若要在zsh继续使用bash的环境变量，在zsh环境变量末尾添加<code>source ~/.bash_profile</code>，重启终端即可。</li>
</ul>
<p>若想切换回来，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Homebrew安装及常用命令"><a href="#Homebrew安装及常用命令" class="headerlink" title="Homebrew安装及常用命令"></a>Homebrew安装及常用命令</h1><h2 id="Homebrew安装"><a href="#Homebrew安装" class="headerlink" title="Homebrew安装"></a><a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew安装</a></h2><p>打开终端，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Homebrew常用命令"><a href="#Homebrew常用命令" class="headerlink" title="Homebrew常用命令"></a>Homebrew常用命令</h2><ul>
<li><p>安装软件：<code>brew install ***</code> 或 <code>brew cask install ***</code></p>
</li>
<li><p>搜索软件：<code>brew search ***</code></p>
</li>
<li><p>卸载软件：<code>brew uninstall ***</code> 或 <code>brew cask uninstall ***</code></p>
</li>
<li><p>彻底卸载指定软件，包括旧版本：<code>brew uninstall --force &lt;软件名&gt;</code></p>
</li>
<li><p>更新所有软件：<code>brew update</code> 或 <code>brew cask upgrade</code></p>
</li>
<li><p>更新具体软件：<code>brew upgrade ***</code></p>
</li>
<li><p>显示已安装软件：<code>brew list</code> 或 <code>brew cask list</code></p>
</li>
<li><p>查看软件信息：<code>brew info ***</code> 或 <code>brew home ***</code><br>  brew home指令是用浏览器打开官方网页查看软件信息</p>
</li>
<li><p>查看哪些已安装的程序需要更新： <code>brew outdated</code></p>
</li>
<li><p>清理指定软件的过时包：<code>brew cleanup &lt;软件名&gt;</code></p>
</li>
<li><p>清理所有的过时软件：<code>brew cleanup</code></p>
</li>
<li><p>列出需要清理的内容：<code>brew cleanup -n</code></p>
</li>
<li><p>显示包依赖：<code>brew deps &lt;软件名&gt;</code></p>
</li>
<li><p>查看已安装的包的依赖，树形显示：<code>brew deps --installed --tree</code></p>
</li>
<li><p>显示帮助：<code>brew help</code> 或 <code>brew -h</code></p>
</li>
<li><p>查看版本：<code>brew -v</code></p>
</li>
<li><p>查找历史版本：<code>brew tap homebrew/cask-versions</code></p>
<p>  homebrew安装jdk后，查看安装位置：<code>/usr/libexec/java_home -V</code></p>
</li>
</ul>
<h2 id="安装遇到问题"><a href="#安装遇到问题" class="headerlink" title="安装遇到问题"></a>安装遇到问题</h2><p><code>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</code><br>一般都是由于网络原因，可更换网络，执行如下命令，重新安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">sudo rm -rf Caskroom Cellar Homebrew Frameworks</span><br><span class="line">cd</span><br><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="VScode配置"><a href="#VScode配置" class="headerlink" title="VScode配置"></a>VScode配置</h1><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><ul>
<li>Remote Development</li>
<li>LaTeX Workshop</li>
<li>PicGo<br>  设置方法与 <a href="/2020/03/09/Hexo%E5%8D%9A%E5%AE%A2/" title="图床">图床</a> 基本相同。</li>
<li>python<br>  <em>配合miniconda使用：</em><br>  更改设置<code>shift + command + p</code>，输入<code>user setting</code>，选择<code>workspace</code>，下拉找到<code>Edit in settings.json</code>将文件改为：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;python.venvPath&quot;:&quot;&#x2F;opt&#x2F;miniconda3&#x2F;envs&quot;,</span><br><span class="line">    &quot;python.pythonPath&quot;:&quot;&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;pytorch&#x2F;bin&#x2F;python&quot;,</span><br><span class="line">    &quot;python.venvFolders&quot;:[</span><br><span class="line">        &quot;envs&quot;,</span><br><span class="line">        &quot;.pyenv&quot;,</span><br><span class="line">        &quot;.direnv&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;code-runner.runInTerminal&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="软件无法更新"><a href="#软件无法更新" class="headerlink" title="软件无法更新"></a>软件无法更新</h2><p>修改软件权限，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R $USER ~&#x2F;Library&#x2F;Caches&#x2F;com.microsoft.VSCode.ShipIt&#x2F;</span><br><span class="line">xattr -dr com.apple.quarantine &#x2F;Applications&#x2F;Visual\ Studio\ Code.app</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Homebrew安装，默认有3种方式，完全安装、无界面、基本安装(需要自行配置包)：</p>
<ul>
<li>Full installation:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install mactex</span><br></pre></td></tr></table></figure></li>
<li>Full installation without bundled applications:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install mactex-no-gui</span><br></pre></td></tr></table></figure></li>
<li>Minimal installation:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install basictex</span><br></pre></td></tr></table></figure>
推荐选择第1种方式，如果有较强的基础可选第3种，若使用其它替代工具，可选第2种。</li>
</ul>
<h2 id="数学符号汇总"><a href="#数学符号汇总" class="headerlink" title="数学符号汇总"></a>数学符号汇总</h2><p>这里引用一个别人做好的PDF吧，非常全面！<br><code>https://www.caam.rice.edu/~heinken/latex/symbols.pdf</code></p>
<hr>
<h1 id="将iPhone备份到外置硬盘"><a href="#将iPhone备份到外置硬盘" class="headerlink" title="将iPhone备份到外置硬盘"></a>将iPhone备份到外置硬盘</h1><ol>
<li>找到存储位置：打开Finder，同时按下<code>command+shift+G</code>，输入<code>~/Library/Application\ Support/MobileSync</code>；</li>
<li>将Backup文件夹copy到外置硬盘指定位置；</li>
<li>打开终端，输入<code>ln -s /Volumes/xiaofeiyu/iPhone.backup/Backup ~/Library/Application\ Support/MobileSync</code>，将存放备份位置软链接到备份位置即可。</li>
</ol>
<hr>
<h1 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h1><h2 id="aria2下载器"><a href="#aria2下载器" class="headerlink" title="aria2下载器"></a>aria2下载器</h2><ol>
<li>安装<a href="https://github.com/aria2/aria2" target="_blank" rel="noopener">aria2</a>：<code>brew install aria2</code></li>
<li>创建配置文件 <code>touch ~/.aria2/aria2.conf</code></li>
<li>创建会话保存文件 <code>touch ~/.aria2/aria2.session</code></li>
<li>配置<a href="http://aria2c.com/usage.html" target="_blank" rel="noopener">aria2.conf</a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## &#39;#&#39;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span><br><span class="line">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span><br><span class="line"></span><br><span class="line">## 文件保存相关 ##</span><br><span class="line"></span><br><span class="line"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span><br><span class="line">dir&#x3D;~&#x2F;downloads</span><br><span class="line"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span><br><span class="line">#disk-cache&#x3D;32M</span><br><span class="line"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span><br><span class="line"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span><br><span class="line"># falloc和trunc则需要文件系统和内核支持</span><br><span class="line"># NTFS建议使用falloc, EXT3&#x2F;4建议trunc, MAC 下需要注释此项</span><br><span class="line">#file-allocation&#x3D;none</span><br><span class="line"># 断点续传</span><br><span class="line">continue&#x3D;true</span><br><span class="line"></span><br><span class="line">## 下载连接相关 ##</span><br><span class="line"></span><br><span class="line"># 最大同时下载任务数, 运行时可修改, 默认:5</span><br><span class="line">#max-concurrent-downloads&#x3D;5</span><br><span class="line"># 同一服务器连接数, 添加时可指定, 默认:1</span><br><span class="line">max-connection-per-server&#x3D;5</span><br><span class="line"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span><br><span class="line"># 假定size&#x3D;10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span><br><span class="line">min-split-size&#x3D;10M</span><br><span class="line"># 单个任务最大线程数, 添加时可指定, 默认:5</span><br><span class="line">#split&#x3D;5</span><br><span class="line"># 整体下载速度限制, 运行时可修改, 默认:0</span><br><span class="line">#max-overall-download-limit&#x3D;0</span><br><span class="line"># 单个任务下载速度限制, 默认:0</span><br><span class="line">#max-download-limit&#x3D;0</span><br><span class="line"># 整体上传速度限制, 运行时可修改, 默认:0</span><br><span class="line">#max-overall-upload-limit&#x3D;0</span><br><span class="line"># 单个任务上传速度限制, 默认:0</span><br><span class="line">#max-upload-limit&#x3D;0</span><br><span class="line"># 禁用IPv6, 默认:false</span><br><span class="line">#disable-ipv6&#x3D;true</span><br><span class="line"># 连接超时时间, 默认:60</span><br><span class="line">#timeout&#x3D;60</span><br><span class="line"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span><br><span class="line">#max-tries&#x3D;5</span><br><span class="line"># 设置重试等待的秒数, 默认:0</span><br><span class="line">#retry-wait&#x3D;0</span><br><span class="line"></span><br><span class="line">## 进度保存相关 ##</span><br><span class="line"></span><br><span class="line"># 从会话文件中读取下载任务</span><br><span class="line">input-file&#x3D;&#x2F;Users&#x2F;zzy&#x2F;.aria2&#x2F;aria2.session</span><br><span class="line"># 在Aria2退出时保存&#96;错误&#x2F;未完成&#96;的下载任务到会话文件</span><br><span class="line">save-session&#x3D;&#x2F;Users&#x2F;zzy&#x2F;.aria2&#x2F;aria2.session</span><br><span class="line"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span><br><span class="line">#save-session-interval&#x3D;60</span><br><span class="line"></span><br><span class="line">## RPC相关设置 ##</span><br><span class="line"></span><br><span class="line"># 启用RPC, 默认:false</span><br><span class="line">enable-rpc&#x3D;true</span><br><span class="line"># 允许所有来源, 默认:false</span><br><span class="line">rpc-allow-origin-all&#x3D;true</span><br><span class="line"># 允许非外部访问, 默认:false</span><br><span class="line">rpc-listen-all&#x3D;true</span><br><span class="line"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span><br><span class="line">#event-poll&#x3D;select</span><br><span class="line"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span><br><span class="line">#rpc-listen-port&#x3D;6800</span><br><span class="line"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span><br><span class="line">#rpc-secret&#x3D;&lt;TOKEN&gt;</span><br><span class="line"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="line">#rpc-user&#x3D;&lt;USER&gt;</span><br><span class="line"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="line">#rpc-passwd&#x3D;&lt;PASSWD&gt;</span><br><span class="line"># 是否启用 RPC 服务的 SSL&#x2F;TLS 加密,</span><br><span class="line"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span><br><span class="line">#rpc-secure&#x3D;true</span><br><span class="line"># 在 RPC 服务中启用 SSL&#x2F;TLS 加密时的证书文件,</span><br><span class="line"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span><br><span class="line">#rpc-certificate&#x3D;&#x2F;path&#x2F;to&#x2F;certificate.pem</span><br><span class="line"># 在 RPC 服务中启用 SSL&#x2F;TLS 加密时的私钥文件</span><br><span class="line">#rpc-private-key&#x3D;&#x2F;path&#x2F;to&#x2F;certificate.key</span><br><span class="line"></span><br><span class="line">## BT&#x2F;PT下载相关 ##</span><br><span class="line"></span><br><span class="line"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span><br><span class="line">#follow-torrent&#x3D;true</span><br><span class="line"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span><br><span class="line">listen-port&#x3D;51413</span><br><span class="line"># 单个种子最大连接数, 默认:55</span><br><span class="line">#bt-max-peers&#x3D;55</span><br><span class="line"># 打开DHT功能, PT需要禁用, 默认:true</span><br><span class="line">enable-dht&#x3D;false</span><br><span class="line"># 打开IPv6 DHT功能, PT需要禁用</span><br><span class="line">#enable-dht6&#x3D;false</span><br><span class="line"># DHT网络监听端口, 默认:6881-6999</span><br><span class="line">#dht-listen-port&#x3D;6881-6999</span><br><span class="line"># 本地节点查找, PT需要禁用, 默认:false</span><br><span class="line">#bt-enable-lpd&#x3D;false</span><br><span class="line"># 种子交换, PT需要禁用, 默认:true</span><br><span class="line">enable-peer-exchange&#x3D;false</span><br><span class="line"># 每个种子限速, 对少种的PT很有用, 默认:50K</span><br><span class="line">#bt-request-peer-speed-limit&#x3D;50K</span><br><span class="line"># 客户端伪装, PT需要</span><br><span class="line">peer-id-prefix&#x3D;-TR2770-</span><br><span class="line">user-agent&#x3D;Transmission&#x2F;2.77</span><br><span class="line">peer-agent&#x3D;Transmission&#x2F;2.77</span><br><span class="line"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span><br><span class="line">seed-ratio&#x3D;0</span><br><span class="line"># 强制保存会话, 即使任务已经完成, 默认:false</span><br><span class="line"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span><br><span class="line">#force-save&#x3D;false</span><br><span class="line"># BT校验相关, 默认:true</span><br><span class="line">#bt-hash-check-seed&#x3D;true</span><br><span class="line"># 继续之前的BT任务时, 无需再次校验, 默认:false</span><br><span class="line">bt-seed-unverified&#x3D;true</span><br><span class="line"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span><br><span class="line">bt-save-metadata&#x3D;true</span><br></pre></td></tr></table></figure></li>
<li>运行aria2：<code>aria2c --conf-path=&quot;/Users/zzy/.aria2/aria2.conf&quot; -D</code></li>
<li>设置aria2开机自启<ul>
<li>在 <code>~/.aria2</code> 目录下 <code>touch com.aria2c.plist</code>：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;KeepAlive&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;true&#x2F;&gt;</span><br><span class="line">    &lt;key&gt;Label&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;com.aria2c&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;ProgramArguments&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;string&gt;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;aria2&#x2F;1.35.0&#x2F;bin&#x2F;aria2c&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;string&gt;--rpc-listen-all&#x3D;true&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;string&gt;--rpc-allow-origin-all&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;string&gt;--conf-path&#x3D;&#x2F;Users&#x2F;zzy&#x2F;.aria2&#x2F;aria2.conf&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;array&gt;</span><br><span class="line">    &lt;key&gt;RunAtLoad&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;true&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure></li>
<li>将该文件拷贝到 <code>~/Library/LaunchAgents</code> 启动项中，运行：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp com.aria2c.plist ~&#x2F;Library&#x2F;LaunchAgents&#x2F;com.aria2c.plist</span><br><span class="line">launchctl load -w ~&#x2F;Library&#x2F;LaunchAgents&#x2F;com.aria2c.plist</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="网盘助手（配合油猴，并修改🆔）"><a href="#网盘助手（配合油猴，并修改🆔）" class="headerlink" title="网盘助手（配合油猴，并修改🆔）"></a>网盘助手（配合油猴，并修改🆔）</h2><p>谷歌应用商店搜索 <code>Tampermonkey</code>，安装后点击查找新脚本，选择 <code>GreasyFork</code>，🔍“网盘助手”，安装。</p>
<h2 id="安装YAAW-for-Chrome插件"><a href="#安装YAAW-for-Chrome插件" class="headerlink" title="安装YAAW for Chrome插件"></a>安装YAAW for Chrome插件</h2><p>若出现 <code>Error: Internal server error</code> 错误，使用 <code>lsof -i tcp:6800</code> 查看端口占用情况，<code>kill PID</code> 即可。</p>
<hr>
<h1 id="Sublime设置（基本已被VSCode代替）"><a href="#Sublime设置（基本已被VSCode代替）" class="headerlink" title="Sublime设置（基本已被VSCode代替）"></a>Sublime设置（基本已被VSCode代替）</h1><h2 id="下载并安装Sublime-Text-3"><a href="#下载并安装Sublime-Text-3" class="headerlink" title="下载并安装Sublime Text 3"></a>下载并安装<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a></h2><h2 id="安装软件包管理器"><a href="#安装软件包管理器" class="headerlink" title="安装软件包管理器"></a>安装软件包管理器</h2><p>同时按下control + ` ，在底部控制台运行如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())</span><br></pre></td></tr></table></figure>

<h2 id="Package（最好用的地方）"><a href="#Package（最好用的地方）" class="headerlink" title="Package（最好用的地方）"></a>Package（最好用的地方）</h2><ul>
<li>安装包（建议使用科学上网）<br>同时按下<code>command + shift + p</code>，打开快速菜单，输入<code>pcip</code>，选择<code>Package Control: Install Package</code>，等待数据更新，完成后会显示软件列表。</li>
<li>使用包<br>同时按下<code>command + shift + p</code>，打开快速菜单，选择所需使用的软件包即可；</li>
<li>查看已安装列表<br>同时按下<code>command + shift + p</code>，打开快速菜单，输入<code>list</code>，选择<code>Package Control: List Package</code>；</li>
<li>卸载包<br>同时按下<code>command + shift + p</code>，打开快速菜单，输入<code>pcrp</code>，选择<code>Package Control: Remove Package</code>；</li>
</ul>
<h3 id="个性化配置安装的包"><a href="#个性化配置安装的包" class="headerlink" title="个性化配置安装的包"></a>个性化配置安装的包</h3><p>在菜单栏选择<code>Sublime Text</code>-&gt;<code>Preference</code>-&gt;<code>Package Settings</code>-&gt;<code>Package Control</code>。其下分为两类，一个是软件包默认配置，一般不改；一个是用户个性化设置，可自行设置。</p>
<p><em>推荐几个好用的包：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Markdown Preview：实现浏览器预览markdown文件</span><br><span class="line">- MarkdownEditing：对md文件使用更加友好设置</span><br><span class="line">- LiveReload：实现对md文件在浏览器中的实时刷新</span><br><span class="line">- SideBarEnhancements：在文本左侧添加文件管理列表</span><br><span class="line">- SublimeCodeIntel：代码自动补全</span><br><span class="line">- auto-save：实现md文档到html文件的自动更新</span><br><span class="line">- ConvertToUTF8：打开txt文件</span><br><span class="line">- Codecs33：配合打开txt文件</span><br></pre></td></tr></table></figure>
<ul>
<li>auto-save插件选择 <code>Toggle AutoSave:current file only</code></li>
<li><code>Markdown Preview</code> 在设置中添加配置 <code>&quot;enable_autoreload&quot;: true</code></li>
<li>实现 <code>Markdown Preview</code> 插件中markdown文件浏览器自动刷新：<br>在md文件最后一行添加 <code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5.0&quot;&gt;</code> 即可，或使用 <code>LiveReload</code> 进行配置。</li>
</ul>
<hr>
<h1 id="chrome个性化设置"><a href="#chrome个性化设置" class="headerlink" title="chrome个性化设置"></a>chrome个性化设置</h1><h2 id="为了使Chrome看起来更加干净清爽，去除启动页8个快捷方式："><a href="#为了使Chrome看起来更加干净清爽，去除启动页8个快捷方式：" class="headerlink" title="为了使Chrome看起来更加干净清爽，去除启动页8个快捷方式："></a>为了使Chrome看起来更加干净清爽，去除启动页8个快捷方式：</h2><ol>
<li>打开 <code>chrome://flags</code> ；</li>
<li>查找 <code>instant extended</code> ；</li>
<li>修改 <code>Disable the &#39;instant extended&#39; limit on search suggestions</code> 为 <code>Disable</code> ；</li>
<li>重启chrome；</li>
<li>在右下角找到 <code>自定义此页</code> ；</li>
<li>选择 <code>快捷键</code> ;</li>
<li>勾选 <code>隐藏快捷方式</code> ；</li>
<li>点击 <code>完成</code> 即可。</li>
</ol>
<p><a href="https://bz.zzzmh.cn/#index" target="_blank" rel="noopener">壁纸网站</a></p>
<h1 id="时钟屏保"><a href="#时钟屏保" class="headerlink" title="时钟屏保"></a><a href="https://fliqlo.com/#/screensaver" target="_blank" rel="noopener">时钟屏保</a></h1><p><a href="https://fliqlo.com/#/screensaver" target="_blank" rel="noopener">https://fliqlo.com/#/screensaver</a></p>
<h1 id="精美5K壁纸"><a href="#精美5K壁纸" class="headerlink" title="精美5K壁纸"></a><a href="https://dynamicwallpaper.club/gallery" target="_blank" rel="noopener">精美5K壁纸</a></h1><p><a href="https://dynamicwallpaper.club/gallery" target="_blank" rel="noopener">https://dynamicwallpaper.club/gallery</a><br>将下载好的文件移动至 <code>/Library/Desktop Pictures</code>，然后在系统管理工具中就可见了。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2020/03/09/Markdown/</url>
    <content><![CDATA[<h1 id="md基本标记符号"><a href="#md基本标记符号" class="headerlink" title="md基本标记符号"></a>md基本标记符号</h1><ol>
<li><p>标题<br>支持六级标题，一般在#后跟个空格再写标题内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码</p>
</li>
</ol>
<ul>
<li>单行代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure></li>
<li>多行代码，代码之间分别用三个反引号包起来，且两边的反引号单独占一行。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>
注：为了防止转译，前后三个反引号处加了小括号</li>
</ul>
<ol start="3">
<li><p>字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*倾斜*</span><br><span class="line">**加粗**</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~加删除线~~</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>图片alt就是显示在图片下面的文字，相当于对图片内容的解释；</li>
<li>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可不加；</li>
<li>github和md文件关联的图片地址是有一定的格式的，不显示可将blob改为raw。</li>
</ul>
<ol start="5">
<li>表格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|--:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>第二行分割表头和内容；</li>
<li>- 有一个就行，为了对齐，多加了几个；</li>
<li>文字默认居左，-两边加：表示文字居中，-右边加：表示文字居右；</li>
<li>原生的语法两边都要用 <code>|</code> 包起来。</li>
</ul>
<ol start="6">
<li><p>引用<br>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p>
</li>
<li><p>分割线<br>三个或者三个以上的 - 或者 * 均可。</p>
</li>
<li><p>超链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br></pre></td></tr></table></figure>
<p>Markdown本身语法不支持链接在新页面中打开，可用html的a标签代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表</p>
</li>
</ol>
<ul>
<li>无序列表<br>无序列表用 <code>- + *</code> 任何一种均可，但与内容之间都要有一个空格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure></li>
<li>有序列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure></li>
<li>列表嵌套<br>上一级与下一级间加3个空格即可。</li>
</ul>
<ol start="10">
<li>流程图（GitHub貌似不支持）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装Matlab</title>
    <url>/2020/06/03/Ubuntu%E5%AE%89%E8%A3%85Matlab/</url>
    <content><![CDATA[<h1 id="Ubuntu-18-04安装Matlab2018b"><a href="#Ubuntu-18-04安装Matlab2018b" class="headerlink" title="Ubuntu 18.04安装Matlab2018b"></a>Ubuntu 18.04安装Matlab2018b</h1><h2 id="Matlab安装"><a href="#Matlab安装" class="headerlink" title="Matlab安装"></a>Matlab安装</h2><ol>
<li>进入下载文件存储路径，装载光盘1 <code>sudo mount -o loop R2018b_glnxa64_dvd1.iso matlab</code>；</li>
<li>启动程序 <code>sudo matlab/install</code>；</li>
<li>选择不联网激活，然后输入license<br>在”Use a File Installation Key”输入license <code>09806-07443-53955-64350-21751-41297</code>。</li>
<li>当弹出弹框时<code>Eject DVD1 and insert DVD 2 to continue</code>加载第2个光盘<br><code>ctrl+alt+t</code> 打开一个新的terminal:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mount -o loop R2018b_glnxa64_dvd2.iso matlab</span><br></pre></td></tr></table></figure>
在弹框点击ok继续安装，待加载完成unmount文件即可。</li>
</ol>
<h2 id="破解Matlab"><a href="#破解Matlab" class="headerlink" title="破解Matlab"></a>破解Matlab</h2><ol>
<li>替换 <code>libmwlmgrimpl.so</code> 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp -f &#x2F;home&#x2F;***&#x2F;Downloads&#x2F;Matlab&#x2F;MATLAB_R2018b_Linux64_Crack&#x2F;MATLAB\ R2018b\ Linux64\ Crack&#x2F;R2018b&#x2F;bin&#x2F;glnxa64&#x2F;matlab_startup_plugins&#x2F;lmgrimpl&#x2F;libmwlmgrimpl.so &#x2F;usr&#x2F;local&#x2F;MATLAB&#x2F;R2018b&#x2F;bin&#x2F;glnxa64&#x2F;matlab_startup_plugins&#x2F;lmgrimpl&#x2F;</span><br><span class="line">sudo &#x2F;usr&#x2F;local&#x2F;MATLAB&#x2F;R2018b&#x2F;bin&#x2F;matlab</span><br></pre></td></tr></table></figure></li>
<li>选择离线激活，选择破解文件license_standalone.lic，<br><code>/home/***/Downloads/Matlab/MATLAB_R2018b_Linux64_Crack/MATLAB R2018b Linux64 Crack/license_standalone.lic</code></li>
</ol>
<ul>
<li>如果不喜欢在terminal中看到 <code>Failed to load module &#39;canberra-gtk-module&#39;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libcanberra-gtk-module</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="创建Matlab快捷方式"><a href="#创建Matlab快捷方式" class="headerlink" title="创建Matlab快捷方式"></a>创建Matlab快捷方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;usr&#x2F;share&#x2F;applications&#x2F;Matlab2018b.desktop</span><br></pre></td></tr></table></figure>
<p>在文件中拷贝如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Categories&#x3D;Application;Development;</span><br><span class="line">Comment&#x3D;Matlab</span><br><span class="line">Encoding&#x3D;UTF-8</span><br><span class="line">Exec&#x3D;&#x2F;usr&#x2F;local&#x2F;MATLAB&#x2F;R2018b&#x2F;bin&#x2F;matlab -desktop -prefersoftwareopengl</span><br><span class="line">Icon&#x3D;&#x2F;usr&#x2F;local&#x2F;MATLAB&#x2F;R2018b&#x2F;toolbox&#x2F;shared&#x2F;dastudio&#x2F;resources&#x2F;MatlabIcon.png</span><br><span class="line">Name&#x3D;MATLAB R2018b</span><br><span class="line">StartupNotify&#x3D;true</span><br><span class="line">Terminal&#x3D;false</span><br><span class="line">Type&#x3D;Application</span><br></pre></td></tr></table></figure>
<p>如果打开Matlab提示”The desktop configuration was not saved successfully”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod a+w -R ~&#x2F;.matlab</span><br><span class="line">sudo chmod 777 &#x2F;home&#x2F;***&#x2F;.matlab</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置CUDA</title>
    <url>/2020/06/03/Ubuntu%E9%85%8D%E7%BD%AECUDA/</url>
    <content><![CDATA[<h1 id="Ubuntu-18-04安装cuda-10-1版本deb"><a href="#Ubuntu-18-04安装cuda-10-1版本deb" class="headerlink" title="Ubuntu 18.04安装cuda 10.1版本deb"></a>Ubuntu 18.04安装cuda 10.1版本deb</h1><ol>
<li>进入存储路径 <code>cd Downloads/cuda</code>；</li>
<li>安装库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg --install cuda-repo-ubuntu1804-10-1-local-10.1.168-418.67_1.0-1_amd64.deb</span><br><span class="line">sudo apt-key add &#x2F;var&#x2F;cuda-repo-10-1-local-10.1.168-418.67</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cuda</span><br></pre></td></tr></table></figure></li>
<li>重启Reboot；</li>
<li>配置环境变量 <code>sudo gedit ~/.bashrc</code><br>在bashrc末尾添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启环境变量 <code>source ~/.bashrc</code>；</li>
<li>验证。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cuda-install-samples-10.1.sh ~</span><br><span class="line">cd ~&#x2F;NVIDIA_CUDA-10.1_Samples&#x2F;5_Simulations&#x2F;nbody</span><br><span class="line">make</span><br><span class="line">.&#x2F;nbody</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="Ubuntu-18-04安装cudnn7-6-2版本deb"><a href="#Ubuntu-18-04安装cudnn7-6-2版本deb" class="headerlink" title="Ubuntu 18.04安装cudnn7.6.2版本deb"></a>Ubuntu 18.04安装cudnn7.6.2版本deb</h1><ol>
<li>安装库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i libcudnn7_7.6.2.24-1+cuda10.1_amd64.deb </span><br><span class="line">sudo dpkg -i libcudnn7-dev_7.6.2.24-1+cuda10.1_amd64.deb</span><br><span class="line">sudo dpkg -i libcudnn7-doc_7.6.2.24-1+cuda10.1_amd64.deb</span><br></pre></td></tr></table></figure></li>
<li>验证（”Test passed!”）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r &#x2F;usr&#x2F;src&#x2F;cudnn_samples_v7&#x2F; $HOME</span><br><span class="line">cd  $HOME&#x2F;cudnn_samples_v7&#x2F;mnistCUDNN</span><br><span class="line">make clean &amp;&amp; make</span><br><span class="line">.&#x2F;mnistCUDNN</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>VS-Code配置</title>
    <url>/2020/06/06/VSCode%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>配置C环境<br><a href="https://www.jianshu.com/p/83879b4aa3fe" target="_blank" rel="noopener">https://www.jianshu.com/p/83879b4aa3fe</a></p>
<p>Latex学习<br><a href="https://www.cnblogs.com/zyg123/category/1415008.html" target="_blank" rel="noopener">https://www.cnblogs.com/zyg123/category/1415008.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>brief特征</title>
    <url>/2020/06/04/brief%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="BRIEF"><a href="#BRIEF" class="headerlink" title="BRIEF"></a>BRIEF</h1><ol>
<li>平滑图像；</li>
<li>在特征点周围选择一个Patch，在这个Patch内通过一定方法挑选$n_d$个点对；</li>
<li>比较点对中两个像素的大小，并进行赋值：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/BRIEF%E8%B5%8B%E5%80%BC.png" alt="BRIEF赋值"></li>
<li>对所有$n_d$个点对，进行比较，生成一个长$n_d$的二进制串。</li>
</ol>
<h2 id="点对的生成方式："><a href="#点对的生成方式：" class="headerlink" title="点对的生成方式："></a>点对的生成方式：</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%82%B9%E5%AF%B9%E7%94%9F%E6%88%90.png" alt="点对生成"></p>
<ul>
<li>X和Y都服从在[-S/2,S/2]范围内的均匀分布，且相互独立；</li>
<li>X和Y都服从均值为0，方差为$\frac{S^2}{25}$的高斯分布，且相互独立。</li>
</ul>
<p><strong>点对的位置一旦随机选定，就不再更改。</strong></p>
<hr>
<h1 id="ORB特征描述"><a href="#ORB特征描述" class="headerlink" title="ORB特征描述"></a>ORB特征描述</h1><p>基于Fast角点的特征点检测和BRIEF特征描述技术。</p>
<ul>
<li><p>Fast角点检测缺点：</p>
<ul>
<li>缺乏尺度不变性；</li>
<li>通过构建高斯金字塔，在每一层金字塔图像上检测角点，来实现尺度不变性。</li>
</ul>
</li>
<li><p>BRIEF缺点：</p>
<ul>
<li>缺乏旋转不变性；</li>
<li>给Brief添加旋转不变性。</li>
</ul>
</li>
</ul>
<h2 id="ORB对BRIEF的改进"><a href="#ORB对BRIEF的改进" class="headerlink" title="ORB对BRIEF的改进"></a>ORB对BRIEF的改进</h2><ul>
<li><p>在计算描述子时建立的坐标系，以关键点为圆心，以关键点和取点区域的形心(圆心)的连线为X轴建立坐标系；</p>
</li>
<li><p>计算形心时，圆形区域上每个点的质量是其对应的像素值。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>conda</title>
    <url>/2020/03/09/conda/</url>
    <content><![CDATA[<h1 id="Anaconda-miniconda-个性化设置"><a href="#Anaconda-miniconda-个性化设置" class="headerlink" title="Anaconda/miniconda 个性化设置"></a>Anaconda/miniconda 个性化设置</h1><h2 id="更换国内镜像源"><a href="#更换国内镜像源" class="headerlink" title="更换国内镜像源"></a>更换国内镜像源</h2><p>具体替换方式在官方网站中均有提示，<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华镜像源网站</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阿里云 https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line">中国科技大学 https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;</span><br><span class="line">豆瓣(douban) http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br><span class="line">清华大学 https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;</span><br><span class="line">中国科学技术大学 http:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="jupyter个性化设置"><a href="#jupyter个性化设置" class="headerlink" title="jupyter个性化设置"></a>jupyter个性化设置</h2><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><ul>
<li>下载主题文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure></li>
<li>查看主题列表 <code>jt -l</code></li>
<li>设置主题 <code>jt -t * -f * -fs 14 -cellw 90% -ofs 12 -T -N</code></li>
<li>t：字体；-fs：字体大小；-cellw：屏占比；-ofs：输出段字号；-T：显示工具栏；-N：显示主机名</li>
<li>查看帮助 <code>jt -h</code></li>
<li>还原默认主题 <code>jt -r</code></li>
</ul>
<h3 id="快速切换环境"><a href="#快速切换环境" class="headerlink" title="快速切换环境"></a>快速切换环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --name ***</span><br></pre></td></tr></table></figure>

<p>当出现 <code>kernel error</code> 时：</p>
<ol>
<li>使用<code>jupyter kernelspec list</code>查看内核是否正确；</li>
<li>删除掉不正确的内核<code>jupyter kernelspec remove 内核名</code>，重新安装内核即可。</li>
</ol>
<h2 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h2><p>在安装anaconda/miniconda后，终端默认会显示当前环境名称，<br>若感觉影响美观，可设置忽略(base)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.condarc</span><br></pre></td></tr></table></figure>
<p>在文末添加 <code>changeps1: False</code> 即可。</p>
<hr>
<h1 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h1><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><ol>
<li>创建虚拟环境<br><code>conda create -n xxxx python=版本号</code></li>
<li>移除该虚拟环境<br><code>conda remove -n xxxx --all</code></li>
<li>开启xxxx环境/激活虚拟环境<br><code>conda activate xxxx</code> 或 <code>source activate xxxx</code></li>
<li>关闭虚拟环境<br><code>conda deactivate</code></li>
<li>查看所创建的虚拟环境列表<br><code>conda env list</code></li>
<li>克隆环境<br><code>conda create -n *** --clone ***</code></li>
<li>导出环境，进入到要导出的环境（激活）<br><code>conda env export --file ***.yml</code></li>
<li>导入环境<br><code>conda env create -f ***.yml</code></li>
</ol>
<h2 id="更新conda"><a href="#更新conda" class="headerlink" title="更新conda"></a>更新conda</h2><p><code>conda update conda</code><br><code>conda update anaconda</code><br><code>conda update anaconda-navigator</code></p>
<h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><ol>
<li>查看安装的包<br><code>conda list</code></li>
<li>卸载安装的包<br><code>conda uninstall xxx</code></li>
<li>删除无用的包（自动清理）<br><code>conda clean -p</code></li>
<li>tar打包<br><code>conda clean -t</code></li>
</ol>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>hog特征</title>
    <url>/2020/06/04/hog%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h1><ul>
<li><p>梯度计算</p>
<ul>
<li>分别计算水平、垂直梯度（将二维卷积转换为两个一维卷积）的幅值、方向；</li>
<li>对于彩色图，选取梯度幅值最大的通道。</li>
</ul>
</li>
<li><p>Block拆分</p>
<ul>
<li><p>16*16的Block，步长为8，50%的重合；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/block.png" alt="block"></p>
</li>
<li><p>包含2*2个Cell；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/cell.png" alt="cell"></p>
</li>
<li><p>每个Cell为8*8大小。</p>
</li>
</ul>
</li>
<li><p>计算每个Cell的梯度方向直方图</p>
<ul>
<li><p>9个方向bin(0-180)；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/bin.png" alt="bin"></p>
</li>
<li><p>积累梯度幅值；<br>  <em>易受前景/背景对比度及局部光照影响</em>，需对局部细胞单元进行对比度归一化处理：将各Cell组合成大的、空间上连通的区间block，再进行归一化。</p>
<p>  <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/hog%E5%BD%92%E4%B8%80%E5%8C%96%E5%A4%84%E7%90%86.png" alt="hog归一化处理"></p>
</li>
<li><p>使用位置高斯加权；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BD%8D%E7%BD%AE%E9%AB%98%E6%96%AF%E5%8A%A0%E6%9D%83.png" alt="位置高斯加权"></p>
</li>
<li><p>相邻bin使用线性插值。</p>
</li>
</ul>
</li>
<li><p>串联所有Block直方图</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%B8%B2%E8%81%94Block.png" alt="串联Block"></p>
<ul>
<li>64*128大小图片；</li>
<li>7*15=105个Block；</li>
<li>105<em>(2</em>2)*9=3780维。</li>
</ul>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/HOG%E6%AD%A5%E9%AA%A4.png" alt="HOG步骤"></p>
<ol>
<li>将整个图像进行Gamma空间、颜色归一化；</li>
<li>计算图像梯度；</li>
<li>构建方向的直方图；</li>
<li>将细胞单元组成大的区间；</li>
<li>收集HOG特征。</li>
</ol>
<p><em>行人HOG特征：</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%A1%8C%E4%BA%BAHOG%E7%89%B9%E5%BE%81.png" alt="行人HOG特征"></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>kmeans聚类</title>
    <url>/2020/06/06/kmeans%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/K-means.png" alt="K-means"></p>
<p>算法流程：</p>
<ol>
<li>选取k个类中心（首次随机选取）；</li>
<li>计算每个点到k个类中心的距离；</li>
<li>将数据点分配给距离最近的一个类中心；</li>
<li>计算新的类中心（对该类中所有点取均值）；</li>
<li>重复2-4，直到满足终止条件：<ul>
<li>不再有重新分配；</li>
<li>最大迭代数；</li>
<li>所有类中心移动小于某一个值。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>image</category>
      </categories>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/03/09/mysql/</url>
    <content><![CDATA[<h1 id="mysql常用命令"><a href="#mysql常用命令" class="headerlink" title="mysql常用命令"></a>mysql常用命令</h1><h2 id="进入mysql："><a href="#进入mysql：" class="headerlink" title="进入mysql："></a>进入mysql：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>输入密码登录。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>显示已存在数据库：<br><code>show databases;</code></li>
<li>创建新数据库：<br><code>create database 数据库名称;</code></li>
<li>切换到某数据库：<br><code>use 数据库名称;</code></li>
<li>删除数据库：<br><code>drop database 数据库名称;</code></li>
<li>退出数据库：<br><code>use mysql;</code></li>
</ol>
<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><ol>
<li>显示数据库中所有表：<br><code>show tables;</code></li>
<li>创建新数据库表：<br><code>create table</code>数据库名称<code>(</code>列名<code>类型 ... , ...);</code></li>
<li>查看某表结构：<br><code>show columns from 表名;</code> 或 <code>DESCRIBE 表名;</code></li>
<li>删除数据库表：<br><code>drop tables 表名;</code></li>
</ol>
<hr>
<h1 id="导入txt格式文件到MySQL8-0"><a href="#导入txt格式文件到MySQL8-0" class="headerlink" title="导入txt格式文件到MySQL8.0"></a>导入txt格式文件到MySQL8.0</h1><h2 id="命令行方式导入："><a href="#命令行方式导入：" class="headerlink" title="命令行方式导入："></a>命令行方式导入：</h2><p><strong>利用navicat中的查询语句进行命令操作</strong></p>
<ol>
<li>新建一个car_operation数据库：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;car_operation&#96; (</span><br><span class="line">  &#96;car_id&#96; varchar(6) NOT NULL COMMENT &#39;车辆标识&#39;,</span><br><span class="line">  &#96;clicking&#96; int(2) NOT NULL COMMENT &#39;触发事件：0&#x3D;变空车，1&#x3D;变载客，2&#x3D;设防，3&#x3D;撤防，4&#x3D;其它&#39;,</span><br><span class="line">  &#96;operation_status&#96; int(2) NOT NULL COMMENT &#39;运营状态：0&#x3D;空车，1&#x3D;载客，2&#x3D;驻车，3&#x3D;停运，4&#x3D;其它&#39;,</span><br><span class="line">  &#96;gps_time&#96; date NOT NULL COMMENT &#39;GPS时间：格式yyyymmddhhnnss，北京时间&#39;,</span><br><span class="line">  &#96;gps_longitude&#96; float(12, 8) NOT NULL COMMENT &#39;GPS经度：格式ddd.ddddddd，以度为单位&#39;,</span><br><span class="line">  &#96;gps_latitude&#96; float(12, 8) NOT NULL COMMENT &#39;GPS纬度：格式dd.ddddddd，以度为单位&#39;,</span><br><span class="line">  &#96;gps_speed&#96; int(4) NOT NULL COMMENT &#39;GPS速度：格式ddd，取值000-255内整数，以公里&#x2F;小时为单位&#39;,</span><br><span class="line">  &#96;gps_direction&#96; int(4) NOT NULL COMMENT &#39;GPS方位：格式ddd，取值000-360内整数，以度为单位&#39;,</span><br><span class="line">  &#96;gps_status&#96; int(2) NOT NULL COMMENT &#39;GPS状态：0&#x3D;无效，1&#x3D;有效&#39;</span><br><span class="line">) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>因使用MySQL8.0，需要修改my.ini配置文件:</strong><br>在[mysqld]下添加一行 <code>secure_file_priv=&#39;&#39;</code>，重启MySQL服务器。</p>
<ol start="2">
<li><p>使用样例数据导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA INFILE &#39;F:&#x2F;CQUPT&#x2F;Y81201&#x2F;SuperDatabase&#x2F;ADB&#x2F;20121130000001.txt&#39; REPLACE </span><br><span class="line">INTO TABLE car_operation </span><br><span class="line">FIELDS TERMINATED by&#39;,&#39; </span><br><span class="line">ENCLOSED by&#39;&quot;&#39;</span><br><span class="line">LINES TERMINATED by &#39;\r\n&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用全部数据导入：（因数据有重复，删除car_id主键中的主键设置）</p>
</li>
</ol>
<h2 id="通过GUI方式导入（速度超级慢）"><a href="#通过GUI方式导入（速度超级慢）" class="headerlink" title="通过GUI方式导入（速度超级慢）"></a>通过GUI方式导入（速度超级慢）</h2><ol>
<li><p>创建<code>car_op_gui</code>数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;car_op_gui&#96;(</span><br><span class="line">	&#96;car_id&#96; varchar(6) NOT NULL COMMENT &#39;车辆标识&#39;,</span><br><span class="line">  &#96;clicking&#96; int(2) NOT NULL COMMENT &#39;触发事件：0&#x3D;变空车，1&#x3D;变载客，2&#x3D;设防，3&#x3D;撤防，4&#x3D;其它&#39;,</span><br><span class="line">  &#96;operation_status&#96; int(2) NOT NULL COMMENT &#39;运营状态：0&#x3D;空车，1&#x3D;载客，2&#x3D;驻车，3&#x3D;停运，4&#x3D;其它&#39;,</span><br><span class="line">  &#96;gps_time&#96; date NOT NULL COMMENT &#39;GPS时间：格式yyyymmddhhnnss，北京时间&#39;,</span><br><span class="line">  &#96;gps_longitude&#96; float(12, 8) NOT NULL COMMENT &#39;GPS经度：格式ddd.ddddddd，以度为单位&#39;,</span><br><span class="line">  &#96;gps_latitude&#96; float(12, 8) NOT NULL COMMENT &#39;GPS纬度：格式dd.ddddddd，以度为单位&#39;,</span><br><span class="line">  &#96;gps_speed&#96; int(4) NOT NULL COMMENT &#39;GPS速度：格式ddd，取值000-255内整数，以公里&#x2F;小时为单位&#39;,</span><br><span class="line">  &#96;gps_direction&#96; int(4) NOT NULL COMMENT &#39;GPS方位：格式ddd，取值000-360内整数，以度为单位&#39;,</span><br><span class="line">  &#96;gps_status&#96; int(2) NOT NULL COMMENT &#39;GPS状态：0&#x3D;无效，1&#x3D;有效&#39;</span><br><span class="line">)ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该数据库右键选择导入向导<br> -&gt;选择txt格式<br> -&gt;选择数据源<br> -&gt;更改字段分隔符为“逗号，”<br> -&gt;下一步<br> -&gt;下一步<br> -&gt;更改目标字段<br> -&gt;追加，下一步<br> -&gt;开始</p>
</li>
<li><p>导入全部数据：（采用追加方式，目的删除之前样例数据）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>haar特征</title>
    <url>/2020/06/04/haar%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="Haar-like特征"><a href="#Haar-like特征" class="headerlink" title="Haar-like特征"></a>Haar-like特征</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Haar%E7%89%B9%E5%BE%81.png" alt="Haar特征"></p>
<p>Haar-like模版可以表示出人脸的某些特征，如中间图表示眼睛区域的颜色比脸颊区域的颜色要深；<br>右图表示鼻梁两侧比鼻梁的颜色要深。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/haar-like%E4%BA%BA%E8%84%B8.png" alt="haar-like人脸"></p>
<h1 id="特征模版"><a href="#特征模版" class="headerlink" title="特征模版"></a>特征模版</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/haar-like.png" alt="haar-like"></p>
<p>Haar-like特征模版：</p>
<ul>
<li>边缘特征；</li>
<li>线性特征；</li>
<li>中心特征；</li>
<li>对角线特征。</li>
</ul>
<p>该模版的特征值为：白色矩形像素和 - 黑色矩形像素和。</p>
<p>特征数量：要考虑模版、位置、缩放 etc.</p>
<h2 id="快速计算-积分图"><a href="#快速计算-积分图" class="headerlink" title="快速计算-积分图"></a>快速计算-积分图</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%A7%AF%E5%88%86%E5%9B%BE.png" alt="积分图"></p>
<p>根据四个角点计算区域内像素和：$A_{ABCD} = A_C - (A_B + A_D - A_A)$。</p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/03/09/git/</url>
    <content><![CDATA[<h1 id="基本配置："><a href="#基本配置：" class="headerlink" title="基本配置："></a>基本配置：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;***@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<p>确保已经有生成有SSH公钥：<br>进入 <code>~/.ssh</code> 可看到有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> ，其中 <code>id_rsa.pub</code> 为公钥。<br>若没有，运行：<code>ssh-keygen -t rsa -C “***@gmail.com&quot;</code> 或 <code>ssh-keygen</code>。<br>将公钥添加到GitHub等远程仓库设置中。</p>
<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><ul>
<li>初始化仓库 <code>git init</code></li>
<li>添加文件到仓库 <code>git add ***</code></li>
<li>提交文件到仓库 <code>git commit -m &quot;comments&quot;</code><br>若不想添加备注信息，可直接<code>git commit</code></li>
<li>将本地仓库与远程仓库进行关联 <code>git remote add origin *URL*</code></li>
<li>提交更改到远程仓库 <code>git push -u origin master</code></li>
<li>克隆远程仓库 <code>git clone *URL*</code></li>
<li>查看提交日志 <code>git log</code><br>简洁版本：<code>git log --pretty=oneline</code></li>
<li>查看当前文件状态 <code>git status</code></li>
<li>回退至上一版本 <code>git reset --hard HEAD^</code></li>
<li>放弃对工作区的修改 <code>git checkout -- ***</code><br>回退至版本库文件替换工作区文件（就是 <code>git add</code>）之前</li>
<li>查看记录版本号 <code>git reflog</code></li>
<li>回退至具体某一版本 <code>git reset --hard *版本号*</code></li>
<li>从版本库删除文件 <code>git rm ***</code></li>
</ul>
<p><em>对于git相关内容，以上对于个人自用足够了，若要团队使用，需要对分支进行设置管理，暂不概述。</em></p>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>svm</title>
    <url>/2020/06/02/svm/</url>
    <content><![CDATA[<h1 id="basic-linear-SVM"><a href="#basic-linear-SVM" class="headerlink" title="basic linear SVM"></a>basic linear SVM</h1><p>最优分界面条件：</p>
<ul>
<li>支持向量机基本模型，是针对<strong>线性可分</strong>的情况下的<strong>最优分界面</strong>提出的；</li>
<li>正类与反类训练样本<strong>可用超平面完全正确分开</strong>。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/svm%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B.png" alt="svm基本模型"></p>
<p>支持向量：经过两类样本中距离最优分类面最近的点，且平行于最优分界面H1、H2(边界超平面)上的训练样本，即图中带圈的点。</p>
<p>带约束的极值问题：<br>$$ min_{w,b} \frac{1}{2} {\Vert w \Vert}^2 $$<br>$$ s.t. y_i(w \cdot x_i + b) \geq 1 $$</p>
<p><em>可通过拉格朗日乘数法并引入拉格朗日乘数，将该约束转化为一个对偶问题，通过寻求该对偶问题的最优解，可得原问题的最优解。</em></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="松弛变量"><a href="#松弛变量" class="headerlink" title="松弛变量"></a>松弛变量</h3><p>由于噪声或其它因素影响，两类数据可能有较少的融合或交叉。<br>引入松弛变量X使得分类器在训练后仍可存在一些错分样本，但要使两类样本间的间隔尽量大，使错分样本的松弛变量之和尽可能小。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.png" alt="松弛变量"></p>
<p>$$ min_{w,b} \frac{1}{2} {\Vert w \Vert}^2 + C \sum_i \xi_i $$<br>$$ s.t. y_i (w \cdot x_i + b) \geq 1 - \xi_i $$</p>
<p>其中，x为松弛变量，满足$x_i \geq 0$；C为大于0的折衷因子，调和来间隔距离和错分样本数之间的关系。</p>
<h3 id="映射到高维空间"><a href="#映射到高维空间" class="headerlink" title="映射到高维空间"></a>映射到高维空间</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%AB%98%E7%BB%B4%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%841.png" alt="高维空间映射1"></p>
<p>为解决线性不可分数据问题，将低维空间的线性不可分数据映射到高维的线性可分空间中。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%AB%98%E7%BB%B4%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%842.png" alt="高维空间映射2"></p>
<p>SVM通过非线性映射f(x)把数据由低维空间向高维空间映射，在高维空间为低维数据构造线性分离超平面。</p>
<p>该分离超平面对应原特征空间上的一个分割超曲面。</p>
<h2 id="用SVM区分行人与非行人HOG特征"><a href="#用SVM区分行人与非行人HOG特征" class="headerlink" title="用SVM区分行人与非行人HOG特征"></a>用SVM区分行人与非行人HOG特征</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/svm_hog.png" alt="svm_hog"></p>
<h1 id="Multiple-instance-SVM"><a href="#Multiple-instance-SVM" class="headerlink" title="Multiple-instance SVM"></a>Multiple-instance SVM</h1><p>将标准SVM的最大化样本间距扩展为最大化样本集间距，即选取<strong>正样本集中最像正样本</strong>的样本用作训练，<strong>负样本中离分界面最近</strong>的负样本作为负样本。</p>
<p>$$ min_{w,b,\xi} \frac{1}{2} {\Vert w \Vert}^2 + C \sum_I {\xi_I} $$<br>$$ s.t. \forall I : Y_I max_{i \in I}(&lt;w,x_i&gt;+b) \geq 1-\xi_I, \xi_I \geq 0 $$</p>
<h1 id="Latent-SVM"><a href="#Latent-SVM" class="headerlink" title="Latent-SVM"></a>Latent-SVM</h1><p><em>Latent-SVM实质上与MI-SVM是一样的，只是扩展了Latent变量。</em></p>
<p>Latent变量：MI-SVM决定正样本集中哪一个样本作为正样本，即一个latent变量，但这个变量的取值是正样本集中的序号。</p>
<p>参考：<br><a href="https://blog.csdn.net/loadstar_kun/article/details/41145665" target="_blank" rel="noopener">https://blog.csdn.net/loadstar_kun/article/details/41145665</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>分类器</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分割</title>
    <url>/2020/05/28/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><p>图像分割：根据灰度、颜色、纹理、形状等特征，将图像划分为若干互不交叠的区域，并使这些特征在同一区域内呈现出相似性，在不同区域间呈现出明显的差异。</p>
<p>经典数字图像分割算法一般基于灰度值的两个基本特性：</p>
<ul>
<li>不连续性；</li>
<li>相似性。</li>
</ul>
<p>前景/背景分割：</p>
<ul>
<li>前景一般包含物体；</li>
<li>需要交互提供初始标记。</li>
</ul>
<h2 id="基于阈值的分割方法"><a href="#基于阈值的分割方法" class="headerlink" title="基于阈值的分割方法"></a>基于阈值的分割方法</h2><p>基本思想：基于图像的灰度特征来计算一个或多个灰度阈值，并将图像中每个像素的灰度值与阈值相比较，最后将像素根据比较结果分到合适的类别中。</p>
<p>设定某一灰度阈值T，将图像分为两部分：大于T的像素群和小于T的像素群，选定一个<strong>合适的阈值</strong>即可将图像准确地分割开。</p>
<h2 id="基于边缘的分割方法"><a href="#基于边缘的分割方法" class="headerlink" title="基于边缘的分割方法"></a>基于边缘的分割方法</h2><p>边缘，是指图像中两个不同区域的边界线上连续的像素点的集合，是图像局部特征不连续性的反映，体现了灰度、颜色、纹理等图像特性的<strong>突变</strong>。</p>
<p>基本思路：先确定图像中的边缘像素，然后再把这些像素连接在一起构成所需的区域边界。</p>
<hr>
<h1 id="传统图像分割方法"><a href="#传统图像分割方法" class="headerlink" title="传统图像分割方法"></a>传统图像分割方法</h1><h2 id="基于区域的分割方法"><a href="#基于区域的分割方法" class="headerlink" title="基于区域的分割方法"></a>基于区域的分割方法</h2><p>将图像按照相似性准则分成不同的区域。</p>
<h3 id="区域生长法"><a href="#区域生长法" class="headerlink" title="区域生长法"></a>区域生长法</h3><p>根据一种事先定义的准则，将像素或子区域聚合成更大区域的过程，并且要充分保证分割后的区域满足以下条件：</p>
<ul>
<li>内部连通、互斥；</li>
<li>各子集的并集能构成全集。</li>
</ul>
<p>区域生长的条件：根据像素灰度间的连续性定义的一些相似性准则；<br>区域生长停止的条件：一个终止规则。</p>
<p>区域生长法定义了最大像素灰度值距离，当待加入像素点的灰度值和已分割好的区域所有像素点的平均灰度的差的绝对值不大于最大像素灰度值距离时，该像素点加入到该分割区域；相反，则区域生长算法停止。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF.png" alt="区域生长"></p>
<h3 id="分水岭方法"><a href="#分水岭方法" class="headerlink" title="分水岭方法"></a>分水岭方法</h3><p>将图像中的<strong>边缘</strong>转化为<strong>山脉</strong>，将<strong>均匀区域</strong>转化为<strong>山谷</strong>。</p>
<p>在分割过程中，该方法会将临近像素间的相似性作为重要的参考依据，从而将在<strong>空间位置上相近</strong>，并且<strong>灰度值相近</strong>的像素点互相连接起来，构成一个封闭的轮廓。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%88%86%E6%B0%B4%E5%B2%AD.png" alt="分水岭"></p>
<p>操作步骤：</p>
<ol>
<li>彩色图像灰度化；</li>
<li>求梯度图；</li>
<li>进行分水岭算法，求得分段图像的边缘线。</li>
</ol>
<h2 id="基于图论的分割方法"><a href="#基于图论的分割方法" class="headerlink" title="基于图论的分割方法"></a>基于图论的分割方法</h2><p>将图像分割问题与图的最小割mincut问题联系。将图像映射为带权无向图，图中每个节点对应于图像中的每个像素，每条边的权值对应相邻像素间在灰度、颜色、纹理等方面的非负相似度。</p>
<a href="/2020/06/06/GraphCuts%E5%88%86%E5%89%B2/" title="GraphCuts分割">GraphCuts分割</a>

<a href="/2020/06/06/GrabCut%E5%88%86%E5%89%B2/" title="GrabCut分割">GrabCut分割</a>]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/2020/06/08/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="CNN基本组件"><a href="#CNN基本组件" class="headerlink" title="CNN基本组件"></a>CNN基本组件</h1><h2 id="卷积层-Convolutional-layer"><a href="#卷积层-Convolutional-layer" class="headerlink" title="卷积层 Convolutional_layer"></a>卷积层 Convolutional_layer</h2><p>用一个采样器从输入数据中采集关键数据内容；</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CNN%E5%8D%B7%E7%A7%AF%E5%8E%9F%E7%90%86.png" alt="CNN卷积原理"></p>
<p>3D滤波器/卷积核：</p>
<ul>
<li>以扫描窗的方式，对图像做卷积；</li>
<li><strong>每层包含多个卷积核，每个核对应一个输出通道</strong>；</li>
<li>用于提取局部特征；</li>
<li>权重参数根据训练学习获得。</li>
</ul>
<p>通过代码看卷积核的超参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nn.Conv2d(self, in_channels, out_channels, kernel_size, stride&#x3D;1, padding&#x3D;0, dilation&#x3D;1, groups&#x3D;1, bias&#x3D;True))</span><br></pre></td></tr></table></figure>
<ul>
<li>in_channel：输入数据的通道数;</li>
<li>out_channel：输出数据的通道数，根据模型调整，对应<strong>滤波器/卷积核的数量</strong>；</li>
<li>kennel_size：卷积核大小；</li>
<li>Stride：步长，默认为1；</li>
<li>padding：zero padding。</li>
</ul>
<p><em>卷积操作一般要把卷积核旋转$180^\circ$再相乘的(反向传播)。</em></p>
<a href="/2020/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" title="激活函数">激活函数</a>

<h2 id="池化层-Pooling-layer"><a href="#池化层-Pooling-layer" class="headerlink" title="池化层 Pooling_layer"></a>池化层 Pooling_layer</h2><p>对卷积层结果进行压缩，得到更加重要的特征，并有效控制过拟合。</p>
<p>计算类别：</p>
<ul>
<li>平均池化</li>
<li>最大池化</li>
</ul>
<p>通过代码查看最大池化层的超参数设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nn.MaxPool2d(kernel_size, stride&#x3D;None, padding&#x3D;0, dilation&#x3D;1, return_indices&#x3D;False, ceil_mode&#x3D;False)</span><br></pre></td></tr></table></figure>
<ul>
<li>kernel_size(int or tuple)：max pooling的窗口大小；</li>
<li>stride(int or tuple, optional)：max pooling的窗口移动的步长，默认kernel_size；</li>
<li>padding(int or tuple, optional)：输入的每一条边补充0的层数；</li>
<li>dilation(int or tuple, optional)：一个控制窗口中元素步幅的参数；</li>
<li>return_indices：若为True，返回输出最大值的序号，对于上采样操作有帮助；</li>
<li>ceil_mode：若为True，计算输出信号大小时，会使用向上取整，默认向下取整。</li>
</ul>
<h3 id="池化层的误差反向传播"><a href="#池化层的误差反向传播" class="headerlink" title="池化层的误差反向传播"></a>池化层的误差反向传播</h3><p>对pooling进行填充后，将卷积核旋转$180^\circ$，进行反向传播计算。</p>
<ol>
<li>mean-pooling</li>
</ol>
<ul>
<li>使用等值复制方式，将[[1,2],[3,4]]变为[[1,1,2,2],[1,1,2,2],[3,3,4,4],[3,3,4,4]];</li>
<li>需要满足反向传播时各层间残差总和不变，所以对卷积层对应的每个值需要平摊。</li>
</ul>
<ol start="2">
<li>max-pooling</li>
</ol>
<ul>
<li>前向传播过程中<strong>需要记录pooling区域中最大值的位置</strong>；</li>
<li>将[[1,2],[3,4]]放入对应的最大值位置，如[[1,0,0,2],[0,0,0,0],[0,0,0,0],[3,0,0,4]];</li>
</ul>
<h2 id="全连接层-Fully-Connected-layer"><a href="#全连接层-Fully-Connected-layer" class="headerlink" title="全连接层 Fully-Connected_layer"></a>全连接层 Fully-Connected_layer</h2><p>对卷积后高度抽象化的特征进行整合，然后归一化，对各种分类情况输出一个概率，之后的分类器Classifier根据全连接得到的概率进行分类。</p>
<a href="/2020/06/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="SoftMax">SoftMax</a>

<p>FCL对接n维的software层，得到n类标签的概率，用于构建loss。</p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>swift</title>
    <url>/2020/06/30/swift/</url>
    <content><![CDATA[<h1 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h1><p><em>所见及所得，可快速查看语法更改</em></p>
<h1 id="Cocoa框架"><a href="#Cocoa框架" class="headerlink" title="Cocoa框架"></a>Cocoa框架</h1><p>Cocoa是<code>OS X</code>和<code>ios</code>操作系统的程序的运行环境。</p>
<p>Cocoa拥有众多框架：Application、<strong>UIKit</strong>、Cocoa Touch、Media、Core Services/<strong>Foundation</strong>、Core OS。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Cocoa.png" alt="Cocoa"></p>
<p>Foundation框架：</p>
<h1 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h1><h2 id="SandBox"><a href="#SandBox" class="headerlink" title="SandBox"></a>SandBox</h2><p>ios中的沙盒机制是一种安全体系。每个app都有一个单独的文件系统/存储空间，而且只能在对应的文件系统中进行操作，即沙盒。所有的非代码文件（资源文件等）都保存在此。</p>
<p>沙盒包含的目录：</p>
<ul>
<li>/AppName.app<ul>
<li>应用程序的程序包目录；</li>
<li>由于应用程序必须经过<strong>签名</strong>，所以不能在运行时对这个目录中的内容进行修改，否则会导致应用程序无法启动。</li>
</ul>
</li>
<li>/Documents/<ul>
<li>保存<strong>应用程序的重要数据文件和用户数据文件</strong>等；</li>
<li>iTunes<strong>同步</strong>时会<strong>备份</strong>该目录。</li>
</ul>
</li>
<li>/Library/Caches<ul>
<li>保存应用程序使用时产生的支持文件和缓存文件，还有日志文件最好也放在这个目录；</li>
<li>iTunes同步时<strong>不备份</strong>该目录。</li>
</ul>
</li>
<li>/Library/Preferences<ul>
<li>保存应用程序的偏好设置文件；</li>
<li>使用<code>NSUserDefaults</code>类设置时创建，不应手动创建。</li>
</ul>
</li>
<li>/tmp/<ul>
<li>保存应用运行时所需要的临时数据；</li>
<li>iphone<strong>重启时会清空</strong>该目录下所有文件。</li>
</ul>
</li>
</ul>
<p>查询app沙盒路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在项目中执行代码打印获取</span><br><span class="line">let homeDir &#x3D; NSHomeDirectory() as Stringprintln(homeDir)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1、获取沙盒根目录</span><br><span class="line">let homeDir &#x3D; NSHomeDirectory() as String</span><br><span class="line">&#x2F;&#x2F; 2、获取 Documents 目录</span><br><span class="line">let docDirs &#x3D; NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true) as NSArraylet docDir &#x3D; docDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 3、获取 Caches 目录</span><br><span class="line">let cachesDirs &#x3D; NSSearchPathForDirectoriesInDomains(.CachesDirectory, .UserDomainMask, true) as NSArraylet cachesDir &#x3D; cachesDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 4、获取 Library 目录</span><br><span class="line">let libDirs &#x3D; NSSearchPathForDirectoriesInDomains(.LibraryDirectory, .UserDomainMask, true) as NSArraylet libDir &#x3D; libDirs[0] as String</span><br><span class="line">&#x2F;&#x2F; 5、获取 tmp 目录</span><br><span class="line">let tmpDir &#x3D; NSTemporaryDirectory() as String</span><br></pre></td></tr></table></figure>

<h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><p>通过<code>fileManager</code>对沙盒中的目录/文件进行操作。</p>
<h3 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h3><p>app都是通过<code>bundle</code>进行封装的，可以将<code>bundle</code>理解为上述沙盒中的<code>AppName.app</code>文件。</p>
<p>在<code>Finder</code>中，会把<code>bundle</code>当做文件显示，防止用户误操作，但其内部是一个目录，包含图像、媒体资源、编译的代码、nib文件等，这个目录称为<code>main bundle</code>。</p>
<p><code>Cocaoa</code>提供了<code>NSBundle类</code>封装了<code>bundle</code>操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取应用程序的 main bundle</span><br><span class="line">var mainBundle &#x3D; NSBundle.mainBundle()</span><br><span class="line">&#x2F;&#x2F; 使用 main bundle 获取资源路径</span><br><span class="line">var testFilePath &#x3D; mainBundle.pathForResource(&quot;logo&quot;, ofType: &quot;png&quot;)</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/" target="_blank" rel="noopener">https://numbbbbb.gitbooks.io/-the-swift-programming-language-/</a></li>
<li><a href="https://www.cnblogs.com/zjoch/p/4702873.html" target="_blank" rel="noopener">https://www.cnblogs.com/zjoch/p/4702873.html</a></li>
<li><a href="https://blog.csdn.net/Listron/article/details/80197347" target="_blank" rel="noopener">https://blog.csdn.net/Listron/article/details/80197347</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>图像增强</title>
    <url>/2020/04/13/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h1 id="图像增强目标"><a href="#图像增强目标" class="headerlink" title="图像增强目标"></a>图像增强目标</h1><ul>
<li>改善图像视觉效果；</li>
<li>抑制无用信息，提高图像的使用价值；</li>
<li>转换为更适合人或机器分析处理的形式。</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>图像增强</tag>
      </tags>
  </entry>
  <entry>
    <title>图像特征</title>
    <url>/2020/05/25/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="颜色特征"><a href="#颜色特征" class="headerlink" title="颜色特征"></a>颜色特征</h1><p>RGB图像3通道分解：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/3Dtensor.png" alt="3Dtensor"></p>
<h2 id="量化颜色直方图"><a href="#量化颜色直方图" class="headerlink" title="量化颜色直方图"></a>量化颜色直方图</h2><p>RGB、HSV等颜色空间适用。</p>
<h2 id="聚类颜色直方图"><a href="#聚类颜色直方图" class="headerlink" title="聚类颜色直方图"></a>聚类颜色直方图</h2><p>Lab等颜色空间适用。</p>
<hr>
<h1 id="几何特征"><a href="#几何特征" class="headerlink" title="几何特征"></a>几何特征</h1><h2 id="边缘Edge"><a href="#边缘Edge" class="headerlink" title="边缘Edge"></a>边缘Edge</h2><p>像素明显变化的区域 -&gt; 一阶导数的极值区域。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BE%B9%E7%BC%98%E7%89%B9%E5%BE%81.png" alt="边缘特征"></p>
<h3 id="边缘提取"><a href="#边缘提取" class="headerlink" title="边缘提取"></a>边缘提取</h3><p>导数对噪声敏感 -&gt; 先高斯去噪，再使用一阶导数获取极值。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96.png" alt="边缘提取"></p>
<ul>
<li>高斯滤波一阶导：<br>  $$ h_x(x,y) = \frac{\partial h(x,y)}{\partial x} = \frac{-x}{2\Pi \sigma^4} e^{-\frac{x^2+y^2}{2\sigma^2}} $$<br>  $$ h_y(x,y) = \frac{\partial h(x,y)}{\partial y} = \frac{-y}{2\Pi \sigma^4} e^{-\frac{x^2+y^2}{2\sigma^2}} $$</li>
<li>梯度幅值/强度：<br>  $$ h_x(x,y)^2 + h_y(x,y)^2 $$</li>
<li>梯度增加最快的方向：<br>  $$ \arctan(\frac{h_y(x,y)}{h_x(x,y)}) $$</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BE%B9%E7%BC%98%E6%A2%AF%E5%BA%A6%E8%A7%A3%E6%9E%90.png" alt="边缘梯度解析"></p>
<h3 id="Gabor"><a href="#Gabor" class="headerlink" title="Gabor"></a>Gabor</h3><p>Gabor是一个<strong>用于边缘提取的线性滤波器</strong>，其频率和方向表达与人类视觉系统类似，能够提供<strong>良好的方向选择和尺度选择特性，而且对光照变化不敏感</strong>，适用于纹理分析。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Gabor.png" alt="Gabor"></p>
<p>使用一个三角函数与一个高斯函数叠加即可得到一个Gabor滤波器。</p>
<p>Gabor滤波器组：多频域/尺度、多方向<br>  <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/3%E5%B0%BA%E5%BA%A68%E6%96%B9%E5%90%91.png" alt="3尺度8方向"></p>
<ul>
<li><p>频域：属于加窗傅立叶变换</p>
</li>
<li><p>空域：一个高斯核函数和正弦平面波的乘积</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/gabor%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%BB%84.png" alt="gabor滤波器组"></p>
</li>
</ul>
<h2 id="角点"><a href="#角点" class="headerlink" title="角点"></a>角点</h2><h3 id="Harris角点"><a href="#Harris角点" class="headerlink" title="Harris角点"></a>Harris角点</h3><p>在任何方向上移动小观察窗，导致大的像素变动。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Harris%E8%A7%92%E7%82%B9.png" alt="Harris角点"><br>$ E(u,v) = \sum_{x,y} w(x,y)[I(x+u,y+v)-I(x,y)]^2 $</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Harris%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B.png" alt="Harris角点检测"></p>
<p>$$ E(u,v) \cong [u,v] M [u,v]^T<br>M = \sum_{x,y} w(x,y)[I(x+u,y+v)-I(x,y)]^2<br>M \rightarrow \lambda_{max},\lambda_{min} $$</p>
<ul>
<li>图像中直线：一个特征值大，一个特征值小；</li>
<li>图像中平面：两个特征值都小，且近似相等；</li>
<li>图像中角点：两个特征值都大，且近似相等。</li>
</ul>
<h3 id="Fast角点（快速角点特征检测）"><a href="#Fast角点（快速角点特征检测）" class="headerlink" title="Fast角点（快速角点特征检测）"></a>Fast角点（快速角点特征检测）</h3><p>对兴趣点所在圆上的16个像素点进行判断，若判断后的当前中心像素点为暗或亮，将决定其是否为角点。</p>
<ul>
<li>确定一个阈值t，观察某像素点为中心的一个半径为3像素的离散化的圆，该圆边界上有16个像素；</li>
<li>若在这个圆的边界上有n（一般取12）个连续的像素点，它们的像素值比$ I_p + t $大/小，则p就是一个角点。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/fast%E8%A7%92%E7%82%B9.png" alt="fast角点"></p>
<p>特点：</p>
<ul>
<li>时间复杂度小，检测效果好；</li>
<li>不产生多尺度特征，没有方向信息，失去旋转不变性。</li>
</ul>
<h2 id="斑点（二阶导）"><a href="#斑点（二阶导）" class="headerlink" title="斑点（二阶导）"></a>斑点（二阶导）</h2><p>Laplace梯度：<br>    一阶导极值点-&gt;二阶导零点，对噪声敏感</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Laplace%E6%A2%AF%E5%BA%A6.png" alt="Laplace梯度"></p>
<h3 id="高斯拉普拉斯LoG"><a href="#高斯拉普拉斯LoG" class="headerlink" title="高斯拉普拉斯LoG"></a>高斯拉普拉斯LoG</h3><p>Laplacian of Gaussian：先对图像进行高斯卷积滤波($\sigma$小)降噪，再采用Laplace蒜子进行边缘检测(细节)。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/LoG.png" alt="LoG"></p>
<p>LoG -&gt; 极值点 -&gt; 斑点</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/blob.png" alt="blob"></p>
<p>参考：<br><a href="https://blog.csdn.net/Zachary_Co/article/details/78831806" target="_blank" rel="noopener">https://blog.csdn.net/Zachary_Co/article/details/78831806</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>图像格式</title>
    <url>/2020/06/05/%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="图片存储格式"><a href="#图片存储格式" class="headerlink" title="图片存储格式"></a>图片存储格式</h1><p>常用存储格式：<br>  bmp,jpg,png,tiff,gif,<br>  pcx,tga,exif,fpx,svg,<br>  psd,cdr,pcd,dxf,ufo,<br>  eps,ai,raw,WMF,webp等。</p>
<ul>
<li>BMP：采用位映射存储，占用空间大。</li>
<li>JPG：常用有损压缩格式，压缩比例可达10:1-40:1。</li>
<li>PNG：无损压缩图像文件格式，比GIF小30%。</li>
<li>GIF：基于LZW算法的连续色调的无损压缩格式，压缩率一般在50%左右。</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
  </entry>
  <entry>
    <title>图像特征表示</title>
    <url>/2020/04/13/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="基于关键点的特征描述子"><a href="#基于关键点的特征描述子" class="headerlink" title="基于关键点的特征描述子"></a>基于关键点的特征描述子</h1><h2 id="特征点-关键点-兴趣点"><a href="#特征点-关键点-兴趣点" class="headerlink" title="特征点/关键点/兴趣点"></a>特征点/关键点/兴趣点</h2><p>不同视角图片之间的映射；<br>稳定局部特征点：</p>
<ul>
<li>显著性、可重复性(同一特征有足够相似描述子)；</li>
<li>抗图片变换（外貌：亮度、光照、几何：平移、尺度）</li>
</ul>
<h2 id="SIFT特征：局部特征"><a href="#SIFT特征：局部特征" class="headerlink" title="SIFT特征：局部特征"></a>SIFT特征：局部特征</h2><p>SIFT算法在不同尺度空间(高斯模糊获取)上查找关键点；高斯卷积核是实现尺度变换的唯一变换核，且是唯一的线性核。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>通过对关键点周围图像区域分块，计算块内梯度直方图，生成具有独特性的向量，这个向量是该区域图像信息的一种抽象，具有唯一性。</p>
<ol>
<li><p>在高斯差分DoG空间进行极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于<strong>尺度和旋转不变</strong>的兴趣点。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%9E%81%E5%80%BC%E6%A3%80%E6%B5%8B.png" alt="极值检测"></p>
<ul>
<li>关键点是由DoG空间的局部极值点组成的，关键点的初步探查是通过同一组内各DoG相邻两层图像之间比较完成的。为了寻找DoG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。</li>
<li>中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。最上下两层需在不同组中进行比较。</li>
<li>为了在每组中检测S个尺度的极值点，则DoG金字塔每组需S+2层图像，而DoG金字塔由高斯金字塔相邻两层相减得到，则高斯金字塔每组需S+3层图像，实际计算时S在3到5之间。</li>
<li>在最开始建立高斯金字塔时，要预先模糊输入图像来作为第0个组的第0层的图像，这时相当于丢弃了最高的空域的采样率。因此通常的做法是先将图像的尺度扩大一倍来生成第-1组。</li>
</ul>
</li>
<li><p>关键点定位：在每个候选的位置上，通过一个拟合精细的模型(三维二次函数)来确定位置和尺度。关键点的选择依据于它们的稳定程度。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%85%B3%E9%94%AE%E7%82%B9%E5%AE%9A%E4%BD%8D.png" alt="关键点定位"></p>
<p>为了提高关键点的稳定性，需要对尺度空间DoG函数进行曲线拟合。（泰勒展开式）</p>
<ul>
<li>在新的位置上反复插值直到收敛；也有可能超出所设定的迭代次数或者超出图像边界的范围，删除该点。</li>
<li>距离过小的点易受噪声的干扰而变得不稳定，这样的极值点也应删除。<br>一个定义不好的DoG的极值在横跨边缘的地方有较大的主曲率，而在垂直边缘的方向有较小的主曲率。DoG算子会产生较强的边缘响应，需要剔除不稳定的边缘响应点。主曲率可通过一个$2*2$的Hessian矩阵求出。主曲率值越大，说明两个特征值的比值越大，即在某一个方向的梯度值越大，而在另一个方向的梯度值越小，而边缘恰恰就是这种情况。所以为了剔除边缘响应点，需要让该比值小于一定的阈值。</li>
</ul>
</li>
<li><p>方向确定：<br>基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。最大值方向为主方向，超过最大值80%的方向称为辅方向。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%B8%BB%E6%96%B9%E5%90%91.png" alt="主方向"><br>使用直方图统计邻域内像素的梯度和方向。梯度直方图将$0\thicksim360^{\circ}$的方向范围分为36个柱(bins)，其中每柱10度。直方图的峰值方向代表了关键点的主方向。<br><em>离散的梯度方向直方图要进行插值拟合处理，来求得更精确的方向角度值。</em></p>
<p>所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些<strong>变换的不变性</strong>。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%96%B9%E5%90%91%E4%B8%8D%E5%8F%98%E6%80%A7.png" alt="方向不变性"></p>
</li>
<li><p>关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%85%B3%E9%94%AE%E7%82%B9%E6%8F%8F%E8%BF%B0.png" alt="关键点描述"><br>以特征点为中心取16×16的邻域作为采样窗口，将采样点与特征点的相对方向通过高斯加权后归入包含8个bin的方向直方图，最后获得4×4×8的128维特征描述子。</p>
</li>
</ol>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol>
<li>确定计算描述子所需的图像区域；</li>
<li>将坐标轴旋转为关键点的方向，以确保旋转不变性；</li>
<li>将邻域内的采样点分配到对应的子区域内，将子区域内的梯度值分配到8个方向上，计算其权值；</li>
<li>插值计算每个种子点八个方向的梯度（统计的4*4*8=128个梯度信息即为该关键点的特征向量）；</li>
<li>特征向量形成后，为了去除光照变化的影响，需要对它们进行归一化处理，对于图像灰度值整体漂移，图像各点的梯度是邻域像素相减得到，可去除；</li>
<li>描述子向量门限：非线性光照，相机饱和度变化对造成某些方向的梯度值过大，而对方向的影响微弱。因此设置门限值(向量归一化后，一般取0.2)截断较大的梯度值。然后，再进行一次归一化处理，提高特征的鉴别性。</li>
<li>按特征点的尺度对特征描述向量进行排序。</li>
</ol>
<h3 id="SIFT特征向量的匹配"><a href="#SIFT特征向量的匹配" class="headerlink" title="SIFT特征向量的匹配"></a>SIFT特征向量的匹配</h3><p>当两幅图像的SIFT特征向量生成以后，通过采用关键点特征向量的欧式距离来作为两幅图像中关键点的相似性判定度量。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>具有良好的不变性，其对旋转、尺度缩放、亮度变化保持不变性，对视角变化、仿射变换、噪声也保持一定程度的稳定性；</li>
<li>区分性（Distinctiveness）好，信息量丰富，适用于在海量特征数据库中进行快速、准确的匹配；</li>
<li>多量性，即使少数的几个物体也可以产生大量的SIFT特征向量；</li>
<li>高速性，经优化的SIFT匹配算法甚至可以达到实时的要求；</li>
<li>可扩展性，可以很方便的与其他形式的特征向量进行联合。<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>计算量大；</li>
<li>特征点有时较少；</li>
<li>对边缘光滑的目标无法准确提取特征点。</li>
</ul>
<h2 id="SURF：局部特征"><a href="#SURF：局部特征" class="headerlink" title="SURF：局部特征"></a>SURF：局部特征</h2><p>Herbert等2006年提出的，对SIFT的改进，速度快3倍。</p>
<p>改进：</p>
<ul>
<li>对高斯二阶微分模版进行简化，使卷积平滑操作转换为加减运算；</li>
<li>确定方向时，在圆形区域计算x，y方向的haar小波响应，找到模最大的扇形方向；</li>
</ul>
<ol>
<li>对原图进行变换，使原图每个像素的Hessian矩阵行列式的近似值构成；</li>
<li>高斯平滑-&gt;求二阶导-&gt;求Hessian矩阵；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/haar.png" alt="haar"><br>对于离散像素点，使用haar模版进行卷积。</li>
<li>统计特征点领域内的haar小波特征，以保证旋转不变性；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/surf%E4%B8%BB%E6%96%B9%E5%90%91.png" alt="surf主方向"><br>以特征点为中心，计算半径为6s(s为特征点所在的尺度值)的领域内，<br>统计60度扇形内所有点在x和y方向的haar小波响应总和；<br>该扇形以一定间隔进行旋转，将最大值那个扇形的方向作为该特征点的主方向。</li>
<li>在特征点周围去一个变长为20s的正方形框，该框方向即为检测出来的主方向；</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/surf64d.png" alt="surf64d"><br>SURF特征点特征向量维度为64D，将该框分为16个子区域，每个子区域统计25个像素的水平方向和垂直方向的haar小波特征。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>速度快3倍；</li>
<li>亮度变化效果好；</li>
<li>模糊方面优于SIFT；</li>
<li>尺度不变不及SIFT；</li>
<li>旋转不变与SIFT近似。</li>
</ul>
<p>参考：</p>
<p><a href="https://baike.baidu.com/item/SIFT/1396275?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/SIFT/1396275?fr=aladdin</a><br><a href="https://blog.csdn.net/u010440456/article/details/81483145" target="_blank" rel="noopener">https://blog.csdn.net/u010440456/article/details/81483145</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>图像颜色空间</title>
    <url>/2020/04/25/%E5%9B%BE%E5%83%8F%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h1><h2 id="RGB颜色空间"><a href="#RGB颜色空间" class="headerlink" title="RGB颜色空间"></a>RGB颜色空间</h2><p>三颜色通道：</p>
<ul>
<li>Red通道；</li>
<li>Green通道；</li>
<li>Blue通道。<br>一个像素颜色值为(b,g,r)，取值范围[0,255]或[0.0,1.0]<br>加法混色，用于彩色显示器。</li>
</ul>
<h2 id="CMY-K-颜色空间"><a href="#CMY-K-颜色空间" class="headerlink" title="CMY(K)颜色空间"></a>CMY(K)颜色空间</h2><p>四通道：</p>
<ul>
<li>Cyan通道；</li>
<li>Magenta通道；</li>
<li>Yellow通道；</li>
<li>Key通道。<br>一个像素颜色值为(c,m,y,k)，取值范围[0,255]或[0.0,1.0]<br>减法混色，用于印刷。</li>
</ul>
<h2 id="HSV颜色空间"><a href="#HSV颜色空间" class="headerlink" title="HSV颜色空间"></a>HSV颜色空间</h2><p>三要素：</p>
<ul>
<li>H/Hue：色调，颜色种类；</li>
<li>S/Saturation：饱和度，颜色纯度；</li>
<li>V/Value：明亮度，颜色明亮度。<br>一个像素颜色值为(h,s,v)，取值范围[0,255]或[0.0,1.0]<br>符合人类视觉概念，用于画家调色。</li>
</ul>
<h2 id="CIE-XYZ颜色空间"><a href="#CIE-XYZ颜色空间" class="headerlink" title="CIE-XYZ颜色空间"></a>CIE-XYZ颜色空间</h2><p>基于人类颜色视觉的直接测定，是其他颜色空间的基础。于1931年由国际照明协会定义。</p>
<p>3颜色刺激值通道：</p>
<ul>
<li>X，Y，Z：基本对应R，G，B；</li>
<li>一种波的刺激等于几种波的刺激整合。</li>
</ul>
<p>人类视觉系统（视锥细胞）：</p>
<ul>
<li>短波（S,420-440nm）；</li>
<li>中波（M,530-540nm）；</li>
<li>长波（L,560-580nm）。</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2020/07/01/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="深度优先遍历DFS"><a href="#深度优先遍历DFS" class="headerlink" title="深度优先遍历DFS"></a>深度优先遍历DFS</h1><p>思想：</p>
<ol>
<li>找一个未被访问过的顶点作为起始顶点，沿着当前顶点的边走到未访问过的顶点；</li>
<li>当没有找到未访问过的结点时，回到上一个顶点，继续寻找未访问结点；</li>
<li>直到所有顶点都被访问。</li>
</ol>
<h1 id="广度优先遍历BFS"><a href="#广度优先遍历BFS" class="headerlink" title="广度优先遍历BFS"></a>广度优先遍历BFS</h1><p>思想：类似于树的层次遍历</p>
<ol>
<li>找一个未被访问过的顶点作为起始顶点；</li>
<li>找到顶点的所有的邻接点，放入队列中；</li>
<li>从队列中依次取出结点，查找该结点的所有未被访问过的邻接点，存放到队列中；</li>
<li>直到队列为空。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>小波变换</title>
    <url>/2020/06/06/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="连续小波变换CWT"><a href="#连续小波变换CWT" class="headerlink" title="连续小波变换CWT"></a>连续小波变换CWT</h1><p>将无限长的三角函数基转换为有限长的会衰减的小波基，不仅能获取频率，还可定位到时间。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2.png" alt="小波变换"></p>
<p>思路：</p>
<ol>
<li>取一个小波，将其与原始信号的开始一节进行比较；</li>
<li>计算数值F，F表示小波与所取一节信号的相似程度，计算结果取决于所选小波的形状；</li>
<li>向右移动小波，重复步骤1和步骤2，直至覆盖整个信号；</li>
<li>伸展小波，重复步骤1-3，对齐；</li>
<li>对于所有缩放，重复步骤1-4，进行压缩。</li>
</ol>
<h1 id="离散小波变换DWT"><a href="#离散小波变换DWT" class="headerlink" title="离散小波变换DWT"></a>离散小波变换DWT</h1><p>离散小波变换的有效方法是使用滤波器，由Mallat于1988年提出。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%A4%9A%E5%B1%82%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E5%92%8C%E9%87%8D%E6%9E%84.png" alt="多层小波分解和重构"></p>
<h2 id="小波分解"><a href="#小波分解" class="headerlink" title="小波分解"></a>小波分解</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%A6%BB%E6%95%A3%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="离散小波分解示意图"></p>
<p>S表示原始的输入信号，通过两个互补的滤波器组，一个低通滤波器，得到信号的近似值A，另一个高通滤波器，得到该滤波器的细节值D。</p>
<h2 id="小波重构"><a href="#小波重构" class="headerlink" title="小波重构"></a>小波重构</h2><p>利用小波分解的系数还原出原始信号，也叫逆离散小波变换IDWT/小波合成。</p>
<h1 id="二维离散小波变换"><a href="#二维离散小波变换" class="headerlink" title="二维离散小波变换"></a>二维离散小波变换</h1><p>将二维信号在不同尺度进行分解，得到原始信号的近似值和细节。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BA%8C%E7%BB%B4%E5%B0%8F%E6%B3%A2%E5%88%86%E8%A7%A3%E5%92%8C%E9%87%8D%E6%9E%84.png" alt="二维小波分解和重构"></p>
<p>分解的结果为**近似分量cA、水平细节分量cH、垂直细节分量cV、对角细节分量cD。</p>
<h1 id="常见小波函数"><a href="#常见小波函数" class="headerlink" title="常见小波函数"></a>常见小波函数</h1><p>Haar系列，Daubechies系列，Moret系列，Sym系列，Meyer系列，Coif系列</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%B3%A2%E5%87%BD%E6%95%B0.png" alt="常用小波函数"></p>
<p>参考：<br><a href="https://www.cnblogs.com/keye/p/7809207.html" target="_blank" rel="noopener">https://www.cnblogs.com/keye/p/7809207.html</a><br><a href="https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>多尺度变换</tag>
      </tags>
  </entry>
  <entry>
    <title>常识</title>
    <url>/2020/03/16/%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h1 id="常见缩写"><a href="#常见缩写" class="headerlink" title="常见缩写"></a>常见缩写</h1><table>
<thead>
<tr>
<th align="center">缩写</th>
<th align="center">全称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i.e.</td>
<td align="center"></td>
<td>即，也就是说</td>
</tr>
<tr>
<td align="center">e.g.</td>
<td align="center"></td>
<td>例如，举个例子</td>
</tr>
<tr>
<td align="center">etc.</td>
<td align="center"></td>
<td>等，等等</td>
</tr>
<tr>
<td align="center">s.t.</td>
<td align="center">subject to</td>
<td>使满足。。。条件</td>
</tr>
<tr>
<td align="center">arg min</td>
<td align="center">Argument  of a complex number</td>
<td>元素变元</td>
</tr>
<tr>
<td align="center">row</td>
<td align="center"></td>
<td>行</td>
</tr>
<tr>
<td align="center">col</td>
<td align="center"></td>
<td>列</td>
</tr>
<tr>
<td align="center">sqrt</td>
<td align="center"></td>
<td>求平方根</td>
</tr>
<tr>
<td align="center">floor</td>
<td align="center"></td>
<td>向上取整</td>
</tr>
<tr>
<td align="center">ceil</td>
<td align="center"></td>
<td>四舍五入</td>
</tr>
<tr>
<td align="center">mod</td>
<td align="center"></td>
<td>做除法</td>
</tr>
</tbody></table>
<hr>
<h1 id="公司职称"><a href="#公司职称" class="headerlink" title="公司职称"></a>公司职称</h1><h2 id="决策级"><a href="#决策级" class="headerlink" title="决策级"></a>决策级</h2><table>
<thead>
<tr>
<th align="center">称谓</th>
<th align="center">英文</th>
<th align="center">缩写</th>
<th align="center">主要工作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">董事会</td>
<td align="center">board of directors</td>
<td align="center"></td>
<td align="center">制定政策</td>
</tr>
<tr>
<td align="center">董事会主席/董事长</td>
<td align="center">chairman of the board</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">首席执行官/总经理</td>
<td align="center">chief executive officer</td>
<td align="center">CEO</td>
<td align="center">行政级别最高领导人，负责公司重大执行权</td>
</tr>
<tr>
<td align="center">总裁</td>
<td align="center">president</td>
<td align="center"></td>
<td align="center">主要负责公司日常执行权</td>
</tr>
</tbody></table>
<h2 id="管理级"><a href="#管理级" class="headerlink" title="管理级"></a>管理级</h2><table>
<thead>
<tr>
<th>称谓</th>
<th>缩写</th>
<th>主要工作</th>
</tr>
</thead>
<tbody><tr>
<td>首席运营官</td>
<td>COO</td>
<td>负责公司管理</td>
</tr>
<tr>
<td>首席技术官</td>
<td>CTO</td>
<td>负责公司技术</td>
</tr>
<tr>
<td>首席财务官</td>
<td>CFO</td>
<td>管理公司财务</td>
</tr>
</tbody></table>
<h2 id="部门管理级"><a href="#部门管理级" class="headerlink" title="部门管理级"></a>部门管理级</h2><table>
<thead>
<tr>
<th align="center">称谓</th>
<th align="center">主要工作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">总监</td>
<td align="center">某项领域高级管理人员</td>
</tr>
<tr>
<td align="center">项目经理</td>
<td align="center">公司的日常经营管理和行政事务的负责人</td>
</tr>
<tr>
<td align="center">主管</td>
<td align="center">主持管理某种专门事务的的人员</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Manual</category>
      </categories>
  </entry>
  <entry>
    <title>多尺度变换</title>
    <url>/2020/04/09/%E5%A4%9A%E5%B0%BA%E5%BA%A6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="空间域处理：卷积"><a href="#空间域处理：卷积" class="headerlink" title="空间域处理：卷积"></a>空间域处理：卷积</h1><h2 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h2><h3 id="直方图（特征提取方法）"><a href="#直方图（特征提取方法）" class="headerlink" title="直方图（特征提取方法）"></a>直方图（特征提取方法）</h3><p>是对图片数据/特征分布的一种统计，对数据区间/空间进行量化。<br><em>全黑为0</em></p>
<a href="/2020/06/06/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/" title="直方图均衡化">直方图均衡化</a>

<h2 id="形态学运算"><a href="#形态学运算" class="headerlink" title="形态学运算"></a>形态学运算</h2><ul>
<li><p>膨胀：图像中高亮部分进行膨胀，类似于领域扩展；</p>
</li>
<li><p>腐蚀：源图像高亮部分被腐蚀，类似于被蚕食。</p>
</li>
<li><p>开运算：先腐蚀再膨胀，可去除目标外的孤立点；</p>
</li>
<li><p>闭运算：先膨胀再腐蚀，可去除目标内的孔。</p>
</li>
</ul>
<h2 id="临域运算"><a href="#临域运算" class="headerlink" title="临域运算"></a>临域运算</h2><h3 id="滤波-卷积"><a href="#滤波-卷积" class="headerlink" title="滤波/卷积"></a>滤波/卷积</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%8D%B7%E7%A7%AF.gif" alt="卷积"><br>使用模版，对源图像中的每个位置进行卷积计算，按照一定步长进行滑动，可进行padding填充。</p>
<p>padding边界填充策略：</p>
<ul>
<li>zero-padding补零；</li>
<li>replication边界复制；</li>
<li>reflection镜像；</li>
<li>wraparound块复制。</li>
</ul>
<h4 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h4><ul>
<li>计算卷积内的像素值</li>
<li>取平均值作为卷积输出。</li>
</ul>
<p>既没有很好的去除噪声点，也破坏了图像的细节，使图像变得模糊。</p>
<h4 id="平滑中值滤波"><a href="#平滑中值滤波" class="headerlink" title="平滑中值滤波"></a>平滑中值滤波</h4><ul>
<li>卷积内的像素值从小到达排序；</li>
<li>取中间值作为卷积输出。</li>
</ul>
<p>可有效去除椒盐噪声(黑白点)。</p>
<h4 id="平滑高斯滤波"><a href="#平滑高斯滤波" class="headerlink" title="平滑高斯滤波"></a>平滑高斯滤波</h4><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2.png" alt="高斯滤波"><br>$$ G_{\sigma}=\frac{1}{2\Pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}} $$<br>$ \sigma $ 越小，关注区域越集中。</p>
<p>可有效去除高斯噪声，模拟人眼，关注于中心区域。</p>
<p><strong>分解特性/级联高斯</strong><br>将2D卷积拆分成两个1D卷积，可提高计算效率。</p>
<h4 id="梯度Prewitt滤波-卷积"><a href="#梯度Prewitt滤波-卷积" class="headerlink" title="梯度Prewitt滤波/卷积"></a>梯度Prewitt滤波/卷积</h4><ul>
<li>水平梯度/垂直边缘：$ [-1,0,1] * {[1,1,1]}^T $</li>
<li>垂直梯度/水平边缘：$ [1,1,1] * {[-1,0,1]}^T $</li>
</ul>
<h4 id="梯度Sobel滤波-卷积"><a href="#梯度Sobel滤波-卷积" class="headerlink" title="梯度Sobel滤波/卷积"></a>梯度Sobel滤波/卷积</h4><ul>
<li>水平梯度/垂直边缘：$ [-1,0,1] * {[1,2,1]}^T $</li>
<li>垂直梯度/水平边缘：$ [1,2,1] * {[-1,0,1]}^T $</li>
</ul>
<h4 id="梯度Laplacian滤波-卷积"><a href="#梯度Laplacian滤波-卷积" class="headerlink" title="梯度Laplacian滤波/卷积"></a>梯度Laplacian滤波/卷积</h4><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A2%AF%E5%BA%A6Laplacian%E6%BB%A4%E6%B3%A2.png" alt="梯度Laplacian滤波"></p>
<ul>
<li>使用二阶微分蒜子；</li>
<li>团块检测：周边高于/低于中心点；</li>
<li>边缘检测：像素值快速变化的区域。</li>
</ul>
<h3 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h3><a href="/2020/05/14/%E9%87%91%E5%AD%97%E5%A1%94%E5%8F%98%E6%8D%A2/" title="金字塔变换">金字塔变换</a>

<hr>
<h1 id="频率域处理-提高卷积效率-：乘法"><a href="#频率域处理-提高卷积效率-：乘法" class="headerlink" title="频率域处理(提高卷积效率)：乘法"></a>频率域处理(提高卷积效率)：乘法</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2.png" alt="傅立叶变换"></p>
<p>一个信号可由足够多个不同频率和幅值的正余弦波组成。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BF%A1%E5%8F%B7%E5%88%86%E8%A7%A3.png" alt="信号分解"></p>
<h2 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a>傅立叶变换</h2><p>一系列符合欧拉公式$e^{ix} = \cos{x} + i\sin{x}$的点的运动叠加。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E6%AC%A7%E6%8B%89%E5%8F%A0%E5%8A%A0.png" alt="傅立叶变换欧拉叠加"></p>
<p>矩形波/傅立叶逆变换：$f(t)=\frac{1}{2\Pi} \int_{-\infty}^{\infty} F(\omega)e^{i \omega t}d{\omega}$</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%9F%A9%E5%BD%A2%E6%B3%A2.png" alt="矩形波"></p>
<table>
<thead>
<tr>
<th align="center">傅立叶</th>
<th align="center">公式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">连续傅立叶变换</td>
<td align="center">$$H(\omega)= \int_{-\infty}^{\infty} h(x)e^{-j \omega x} d{x} = \int_{-\infty}^{\infty} h(x)[\cos{x} - {j\omega}\sin{x}] d{x}$$</td>
</tr>
<tr>
<td align="center">离散傅立叶变换</td>
<td align="center">$$X(\omega)=\sum_{-\infty}^{\infty}x_n e^{-i \omega n}$$</td>
</tr>
<tr>
<td align="center">二维离散傅立叶变换</td>
<td align="center">$$F(u,v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x,y)e^{-j2\Pi(\frac{ux}{M} = \frac{vy}{N})}$$</td>
</tr>
</tbody></table>
<p><strong>低通滤波器获取图像的概貌</strong>，去除了图像的高频部分/细节信息，如中值滤波。<br><strong>高通滤波获取图像的边缘信息</strong>，如拉普拉斯滤波。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%BB%A4%E6%B3%A2.png" alt="滤波"></p>
<h3 id="基于傅立叶变换的滤波"><a href="#基于傅立叶变换的滤波" class="headerlink" title="基于傅立叶变换的滤波"></a>基于傅立叶变换的滤波</h3><p>傅里叶变换处理非平稳信号有天生缺陷，它只能获取一段信号总体上包含哪些频率的成分，但是对各成分出现的时刻并无所知。因此时域相差很大的两个信号，可能频谱图一样。</p>
<h4 id="相位滤波"><a href="#相位滤波" class="headerlink" title="相位滤波"></a>相位滤波</h4><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%9B%B8%E4%BD%8D%E6%BB%A4%E6%B3%A2.png" alt="相位滤波"></p>
<h4 id="频谱滤波"><a href="#频谱滤波" class="headerlink" title="频谱滤波"></a>频谱滤波</h4><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%A2%91%E8%B0%B1%E6%BB%A4%E6%B3%A2.png" alt="频谱滤波"></p>
<h3 id="短时傅立叶变换STFT"><a href="#短时傅立叶变换STFT" class="headerlink" title="短时傅立叶变换STFT"></a>短时傅立叶变换STFT</h3><p>对傅立叶变换添加窗格（添加时域信息），默认窗格内的信号是平稳的。<br>对窗格内的信号分段进行傅立叶变换，但窗格大小难以设置。</p>
<p>特点：</p>
<ul>
<li>窄窗口时间分辨率高、频率分辨率低；</li>
<li>宽窗口时间分辨率低、频率分辨率高；</li>
<li>对时变的非稳态信号，高频适合小窗口，低频适合大窗口；</li>
<li>STFT窗口固定。</li>
</ul>
<p><em>绝对意义的瞬时频率其实是不存在的，只是时间分辨率有限的近似分析结果。</em></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a href="/2020/06/06/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/" title="小波变换">小波变换</a></h2><p>reference:<br><a href="https://blog.csdn.net/asd20172016/article/details/80904634" target="_blank" rel="noopener">https://blog.csdn.net/asd20172016/article/details/80904634</a><br><a href="https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/5b1abd048e9951e79b8927de.html</a><br><a href="https://zhuanlan.zhihu.com/p/23607336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23607336</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>多尺度变换</tag>
      </tags>
  </entry>
  <entry>
    <title>我与世界只差一个你</title>
    <url>/2020/03/09/%E6%88%91%E4%B8%8E%E4%B8%96%E7%95%8C%E5%8F%AA%E5%B7%AE%E4%B8%80%E4%B8%AA%E4%BD%A0/</url>
    <content><![CDATA[<blockquote><p>世界说大很大，说小很小。大到走了那么久，还没跟对的人相遇，小到围着喜欢的人绕了一圈，就看到了全世界。</p>
<p>愿你能因为某个人的出现而让世界丰盈，愿你的生活如同贺卡上烫金的祝辞欢脱，愿这悠长岁月温柔安好，有回忆煮酒，愿你没有软肋，也不需要铠甲，愿我们和爱的人一起浪费人生，热泪盈框，长生不老。我与世界只差一个你，因为是你，晚一点没关系。</p>
<p>一个有了女朋友的人就不应该再出去混局了，女人如衣服，兄弟如手足，那是古人说的话，不给你衣服穿，你还有脸出门吗。</p>
<p>你先闭嘴，我说咱能不那么作么，有时间列那么多不平等条约，好好让脑袋多装点实在东西吧，别把矫情当优点，长那么低调活得这么得瑟，以为全天下都欠着你呀。人一大好青年，被你训得话都说不出一句，这么个谈恋爱法，智商是往负250上靠吗，中情局怎么没抓你啊！</p>
<p>你的过去怎样我不想知道，你的未来如何我也不想参与。你难道一点都看不出来我不想理你吗？你还犯着贱得把脸贴过来。干吗，我屁股上装了一整个南极你感觉不到冷啊。</p>
<p>银行司机兼保镖，行动人形立牌，抗压人肉沙包</p>
<p>她不是霸道，只是有主见；她不是强势，只是给自己安全感；她不是神勇铁金刚，那点脾气只是用来掩饰她心底的脆弱罢了。如果你懂她，就该让她去决定她能决定的，放弃她可以放弃的，在她有所期待的时候不要让她失望，在她脆弱的时候扶她一把，在她每次说她很好的时候就别真的离开了，就该知道她能一直欺负你霸占你所有的时间，是因为她爱你！</p>
<p>要有多幸运，两个人才能健康无事地执手偕老。平行时空里，飞机上的人都回了家，自此谁都别忘了，能拥抱到身边的人才是最奢侈的事。</p>
<p>一百个人，有一百个对爱情的态度。我们谁都会受伤，也都会在爱里成熟，不依赖天长地久的承诺，不抱有唯我独尊的自负，在一百次冲动之前，看看自己在这段感情里的收获，别轻易觉得爱可弃，心可医，一个人能行。最好能记着，别人给的爱，都是无辜的。</p>
<footer><strong>随手转发正能量</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>我送了你那么多的巧克力，你都给我退回来了，就跟数学最后一道选择题我辛辛苦苦算了好几页草稿纸，结果ABCD里都没有我要的答案。我喜欢你这么久，明知道是死路，也还是硬着头皮走，马上就要毕业了，我觉得如果不再争取一下久永远失去你了。</p>
<p>有时我会想，我们明明是见面就互掐，特别见不得彼此好的人啊，但为什么现在会有种期待感呢，我好期待我骂你一句后你会回什么，期待我们再比一项东西我输给你后你那得意洋洋的样子，期待你今天会走哪条路，校服里面会穿哪件衣服。慢慢地，我就想迫不及待在人群里找到你，但后来我发现，不用找，我一眼就能看到你。</p>
<p>每个人的青春其实都是一本精彩的书，残酷的，悲伤的，幸运的，幸福的，要说尽其中的遗憾，怎么能用几句话说得清。只是那时的我们啊，以为只要对饮一杯酒，一起吃一碗三块钱的面，就可以永远。后来才发现，时间是永恒的敌人，永远跟有没有勇气没关系，跟牵了多久的手也没有关系，它能给人无穷尽的生命，也能给两个人最长的距离，能让你忘记所有快乐的细节，却偏偏记得痛是多么的苦骨铭心。</p>
<p>我们一起追过的剧里，江直树是真的爱着袁湘琴，李大仁是真的爱着程又青，志明是真的爱着春娇。但你别忘了，那时的我，是真的爱着你。</p>
<footer><strong>念念 相忘</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>人一生会遇到约2920万人，两个人相爱的概率是0.000049，所以你不爱我，我不怪你。</p>
<p>爱一个人的时候，多巴胺分泌旺盛，我们都会不自觉地把对方完美化，但最后真正在一起了，就会发现对方身上漏洞百出，累感不爱。择偶靠来电，但恋爱，必须要靠信任。</p>
<p>看着光影里的…，卸下那一身精致后，留下的跟凡人一样的血肉，冷的时候需要人为她添一件衣服，热了要人牵着她冲进灌满冷气的商场，她一个人那么久，其实根本不行。</p>
<p>从喜欢到愿意共同面对生活还是有很长的一段距离的。我们的生活，需要为五斗米折腰，灾难频现，要经得起时间考验，还不能放任自流，随时要踩死一只只小强以及小三小四小五，明明那么辛苦，最后，你还得说一句，爱情该走下神坛，要走向最普通的生活。确实，当你神经百战之后，再经历这些，就会觉得太微不足道了，这些连年征战就是你的油盐酱醋茶。</p>
<p>我的身旁总有健，我的回忆里也总是他的身影，而他的温柔总像无意间在哪绕了点路，要稍稍慢一拍才回传达给我，如今的我才能慢慢察觉到那份笨拙的温柔，当时的自己总是无法那么坦率，害怕被伤害而没能坚持到最后的人，是我；没能相信他的温柔就中途放弃的人，是我；决定单方面闭上眼睛就不再回头的人，是我；他一直在认真的投球，没能好好接住的人，是我。</p>
<p>别轻易弄丢那个最适合你的人，后悔了？别怕，反正爱啊，总是有遗憾，干了这杯，无醉不欢。</p>
<p>现实无法倒流，没那么多机会给你重来。</p>
<footer><strong>无醉 不欢</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>处女龟毛男：形容斤斤计较、做事拖泥带水的人。一般处女座、摩羯座居多。</p>
<p>平时见不到面的时候迟迟不回我信息，跟他见面了却能一直玩弄手机，都说人在爱情里智商为零，但他却很清醒，知道承诺就是嘴上功夫，不用去兑现的，他也知道什么时候该热情什么时候该冷静。我又不傻，男人就两样东西给你，钱给不了，那就给时间，时间都不给，那就是不爱啊，我有心理准备的。</p>
<p>这个吻，是我每天工作的一部分。感情用事是种心理缺陷，所谓粉丝，不过是指望着别人幸福来意淫自己的美好生活。</p>
<p>Tony在糖糖面前彻底现了原形，他并不是暖男，而是彻头彻尾的渣男，全身注满了人前一套背后一套的负能量，嘴上说不在意网上的恶意评论，但背地里刷着微博骂人家全家。</p>
<p>从Tony参加选秀比赛出道，顾涛就一直带着他，八年来，看着他从一个默默无闻的新人到现在成了别人眼里的风景，两个人一起受过欺负排挤，吃过常人没吃过的苦，睡过清贫的小房子，最苦时抱头痛哭过，也因为一部戏爆红而酩酊大醉过。所以他自负，他知道；他心机满腹，他知道；他要强，他也知道；他害怕失败，他更知道。Tony最红的时候说过不会亏待他，但每年只送他一部最新的iPhone，顾涛从没在Tony身上赚过什么大钱，也没跟他提过任何需求，拿着经纪公司给的薪水，在所有人都以为一人得道、鸡犬升天的时候，却靠着老母亲留下的房子维持着普通人的生活。</p>
<p>如若最后遇到下像是黑夜中静谧的星空，那当初跋涉的这一路，崴脚的石子，走过冒失的风雪，在此刻都成了过眼烟云。夜风徐徐，望着那片星空，心里有一个可以想念的人。–《唐顿庄园》有感</p>
<footer><strong>Ctrl + Alt + Del</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>如果真的为了一个人撕心裂肺哭过一次，那么那个人就会从至关重要的人变成可有可无的人，因为那个人能把自己伤害到那个样子的机会只有一次。那一次之后，即使自己还爱他，可是总有一些东西真的改变了。</p>
<p>毕业如一场告别的宴席，几杯酒下肚后就各自回家了，留在桌上的是彼此要做一辈子好朋友的誓言，带走的是我们终会把各自遗忘然后再去遇见别人的明天。</p>
<p>世界上每天都有许多爱情故事发生，或遗憾，或悲伤，或幸福，或虚假，每个善男信女向空中抛出“我想爱”的信号，撞上了一些人，避开了一些人，经历了抛物线最高的高点，也落回最初的原点。当故事要结局的时候，才发现过去那些所谓遇见分离，最后都会化为平淡，再轰轰烈烈的我爱你你爱我，归根结底，都会落入平淡。</p>
<p>我觉得我不是喜欢你，而是习惯有你；我觉得我不是失去了你，而是失去了最好的青春。</p>
<footer><strong>没在一起 挺好的</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<p><code>Drama Queen 作做女王</code></p>
<blockquote><p>现代男人的焦虑与恐慌，在工作繁重收入高的人群中尤为常见，他们除非遇上自己称心如意的人，否则绝不轻易谈恋爱，若是碰上一个情商爆表的成熟女性，那就分分钟闪婚，最怕的就是遇上胸大无脑，脸美但吵的Drama queen ，要是不小心掉入她们的桃花阵，势必没有富足的时间制造浪漫逗她们开心。</p>
<p>老板在公司是出了名的辛辣刁钻，没人能逃得过她温婉笑容下的锋利匕首，特别擅用全世界通用逼死人不偿命的沟通黄金二字——呵呵——让你体无完肤。</p>
<p>一个女人喜欢你，其实不在乎你们去了哪，做了什么，而是跟你在一起的时候，你有没有让她觉得，你是在乎她的。</p>
<p>最好的浪漫，就是平淡的相处。你知道对方就在那里，很踏实，所有的时间都得以安放，像是忘记你们正在谈恋爱。</p>
<p>就像是本来生活里所有地方都充斥着的回忆，突然之间跟你一点关系都没有了，曾经一同走过的地方、一度养成的习惯，全变成了伤疤，一碰就疼，此前天地都不怕，现在最怕回忆翻滚。</p>
<p>冬天赖床的时候，明明已经醒了，也知道不能再睡了，但还是舍不得温暖的被窝，那时觉得没关系，就再睡一下吧，因为你知道，你总会起床的。</p>
<p>多希望现在认识你，而不是当初，我不知道你有没有真心喜欢过我，但没关系，因为我爱上你了。<br>在爱情面前，我们都不是好人，不然我怎么会允许你就这样从我身边离开，而我也不敢在你背后大声叫住你，“请再看我一眼，再抱我一次。”纵使此生我们都不会再见面，但我仍希望你过得好，至少比我好，不然我会不开心。</p>
<p>那个时候我们都以为爱是你喜欢我，我喜欢你，以为爱是我所希望的就是你所希望的，希望爱是两人份的炸鸡，是一个香喷喷的屁，是被手肘压住的长发，是开在土地里卑微的花，后来才知道，爱是金风玉露一相逢，便胜却人间无数，是相看两不厌，以陪伴互为终点；爱是舒服的沉默，是和有趣的人一起浪费人生，是灵魂伴侣，是原来你也在这里。</p>
<footer><strong>还好最后是 你</strong><cite>张皓宸</cite></footer></blockquote>

<hr>
<blockquote><p>这个世界上的爱情分为多种，一种是心灵伴侣，靠一碗鸡汤秉承爱就是不见也不散；一种是卑微如尘，对方给你一巴掌，你还会关心Ta手为什么这么凉；另一种是彼此折磨，两个人像周瑜打黄盖，一个愿打一个愿挨；还有一种是无间道宫心计，互相猜，好像瞅准了看谁先出轨似的；最后一种，是心照不宣的暧昧，就像电影里说，你想和她上床，她也想和你上床，你们都知道总有一天你们会上床，但不知道你们会在哪一天上床，这就是最好的时光。</p>
<p>她在不同男人面前变成不同的女人，遇到保护欲强的，就二十四小时装脆弱，看3D《泰坦尼克》哭，看3D《史瑞克》哭；遇到动漫爱好者，就穿着女仆装约会，一、二次元无障碍转换；遇到霸道总裁，就每天娇滴滴被阵风都能吹跑；遇到花心男，就成了耐追的绿茶婊；遇到色胚，就把自己捆好放床上。</p>
<p>有些人沦为平庸浅薄，金玉其外，而败絮其中。可不经意间，有一天你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。</p>
<p>人嘛，就是要在关键时刻不要脸，我们平时就是乖太久，才会在爱降临的时候，按部就班，像是经不起一点委屈的温顺兔子，被鸡汤洗脑，高喊着要在爱里活出自己的口号，一遇到刁难就折腰。其实在爱面前，我们什么都不是，我们并没有想象的那么伟大，清风能醉人，尘埃能致命。既然如此，不如彻底放肆，破坏规则，最是青春留不住，青春也不须留。</p>
<p>这个世界从不缺好的故事，故事的结局，静香没有嫁给大雄，晴子可能也就负责打开樱木花道的初恋大门，有人曾牵手，但不会到最后。就像刚好在赶不同的列车，可能就与缘分失之交臂，抑或是原本以为能长久同行的人，结果提前下了车，看似遗憾，但人生海海，总要允许有人错过你，才能赶上最好的相遇。</p>
<p>我们谁都会受伤，也都会在爱里成熟，不依赖天长地久的承诺，不抱有唯我独尊的自负。<br>在一百次冲动之前，看看自己在这段感情里的收获，别轻易觉得爱可弃，心可医，一个人能行。</p>
<p>时间是永恒的敌人，永远跟有没有勇气没关系，跟牵了多久的手也没有关系，它能给人无穷尽的生命，也能给两个人最长的距离，能让你忘记所有快乐的细节，却偏偏记得痛是多么刻骨铭心。</p>
<footer><strong>和你赶上最好的相遇</strong><cite>张皓宸</cite></footer></blockquote>]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>稳定性：</p>
<ul>
<li>稳定：对于关键字相等的记录，排序后的序列和排序前的序列顺序相同；</li>
<li>不稳定：对于关键字相等的记录，排序后的序列和排序前的序列顺序不一定相同。</li>
</ul>
<h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><p><em>待排序记录存放在计算机存储器中进行的排序过程</em></p>
<ol>
<li>插入排序<ol>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>2路插入排序</li>
<li>希尔排序</li>
</ol>
</li>
<li>快速排序<br><em>大循环内 先判断奇次交换 再判断偶次交换。</em><ul>
<li>设k=a[0]，将k挪到适当位置，使比k小的元素都在k左边，使比k大的元素都在k右边；</li>
<li>对k左边部分快速排序；</li>
<li>对k右边部分快速排序。</li>
</ul>
</li>
<li>选择排序<ol>
<li>简单选择排序</li>
<li>树形选择排序</li>
<li>堆排序</li>
</ol>
</li>
<li>归并排序<ul>
<li>将前一半排序；<ul>
<li>将后一半排序；</li>
<li>将两半归并到一个新的有序数组(可使用双指针)；</li>
<li>再拷贝回原数组。</li>
</ul>
</li>
</ul>
</li>
<li>基数排序</li>
</ol>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p><em>待排序记录的数量大，内存不能一次容纳全部记录</em></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h2><p>Binary Search Tree，又称二叉查找树/二叉排序树。</p>
<ul>
<li>任意结点的左子树不空，则左子树上所有结点的值均小于其根结点的值； </li>
<li>任意结点的右子树不空，则右子树上所有结点的值均大于其根结点的值； </li>
<li>任意结点的左、右子树也分别为二叉搜索树。</li>
</ul>
<p>时间复杂度：$O(log^n)$</p>
<p>既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>Red Black Tree，本质上是一种二叉查找树（自平衡二叉查找树），但它在二叉查找树的基础上额外添加了一个颜色标记。</p>
<ol>
<li>Every node is either red or black；</li>
<li>The root is black；</li>
<li>Every leaf (NIL) is black；</li>
<li>If a node is red, then both its children are black；</li>
<li>For each node, all simple paths from the node to descendant leaves contain the same number of black nodes（从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点）。</li>
</ol>
<p>若一棵二叉查找树是红黑树，则它的任一子树必为红黑树。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><em>默认插入的结点设置为red，否则会破坏规则5。</em></p>
<p>可分为三种类型：</p>
<ul>
<li>要插入的结点的parent为black，直接插入即可；</li>
<li>要插入的结点的parent为red，uncle为red，change color；</li>
<li>要插入的结点的parent为red，uncle为black or null，分情况旋转后color。</li>
</ul>
<p>旋转：</p>
<ul>
<li>左左型：parent成为grandparent，grandparent成为parent的left结点；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5.jpg" alt="红黑树插入"></li>
<li>左右型：要插入的结点成为grandparent，grandparent成为left的uncle；</li>
<li>右右型：parent成为grandparent，grandparent成为parent的right结点；</li>
<li>右左型：要插入的结点成为grandparent，grandparent成为right的uncle；</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>亦可分为三种类型：</p>
<ul>
<li>要删除的节点正好是叶子节点，直接删除；</li>
<li>只有左孩子或者右孩子，直接把这个孩子上移放到要删除的位置上；</li>
<li>有左右两个孩子，需要选一个合适的孩子节点作为新的根节点，该节点称为继承节点。<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4.png" alt="红黑树删除"></li>
</ul>
<p><em>删除结点需要考虑的与插入类似。</em></p>
<p>参考：<br><a href="https://blog.csdn.net/yangyutong0506/article/details/78204953" target="_blank" rel="noopener">https://blog.csdn.net/yangyutong0506/article/details/78204953</a><br><a href="https://zhuanlan.zhihu.com/p/79980618" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79980618</a><br><a href="https://baijiahao.baidu.com/s?id=1645429373049393021&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1645429373049393021&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>局部二值LBP</title>
    <url>/2020/06/04/%E5%B1%80%E9%83%A8%E4%BA%8C%E5%80%BCLBP/</url>
    <content><![CDATA[<h1 id="LBP-局部二值模式"><a href="#LBP-局部二值模式" class="headerlink" title="LBP-局部二值模式"></a>LBP-局部二值模式</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/lbp.png" alt="lbp"></p>
<ol>
<li>将每个像素点与周围点大小比较：<ul>
<li>半径为R的圆，均匀采样P个点；</li>
<li>大小量化为0或1.</li>
</ul>
</li>
<li>多个bit组成一个书，统计每个数的直方图。</li>
</ol>
<p>解决旋转不变性：</p>
<ul>
<li>将LBP周围的二进制码按位旋转，取二进制码最小的值为最终LBP值。</li>
</ul>
<h1 id="Extended-LBP-Circular-LBP"><a href="#Extended-LBP-Circular-LBP" class="headerlink" title="Extended LBP/Circular LBP"></a>Extended LBP/Circular LBP</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/ExtendedLBP.png" alt="ExtendedLBP"></p>
<p>将3*3邻域扩展到任意领域，并用圆形领域代替正方形领域。</p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器连接</title>
    <url>/2020/03/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="ssh远程连接（无需输入密码）"><a href="#ssh远程连接（无需输入密码）" class="headerlink" title="ssh远程连接（无需输入密码）"></a>ssh远程连接（无需输入密码）</h1><ol>
<li><p>确保已经有生成有SSH公钥：<br>进入 <code>~/.ssh</code> 可看到有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> ，其中 <code>id_rsa.pub</code> 为公钥。<br>若没有，运行：<code>ssh-keygen -t rsa -C &quot;***@gmail.com&quot;</code> 或 <code>ssh-keygen</code></p>
</li>
<li><p>将本电脑公钥发送到服务器端：<br><code>ssh-copy-id username@144.202.***.***</code></p>
</li>
<li><p>验证：<br><code>ssh &#39;username@144.202.***.***&#39;</code><br>自动连接！</p>
</li>
</ol>
<ul>
<li>若使用该方式后重置，再次连接时，会出现 <code>Host key verfication failed</code> 情况，使用 <code>ssh-keygen -R ip地址</code> 清除。</li>
</ul>
<h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><ol>
<li><p>上传本地文件夹到服务器<br><code>scp -P port -r LocalWorkSpaces username@IP:WorkSpaces</code></p>
</li>
<li><p>下载服务器文件夹到本地<br><code>scp -P port -r username@IP:WorkSpaces LocalWorkSpaces</code> </p>
</li>
<li><p>上传本地文件到服务器<br><code>scp -P port file username@IP:WorkSpaces</code></p>
</li>
<li><p>下载服务器文件到本地<br><code>scp -P port 用户名@IP:file LocalWorkSpaces</code> </p>
</li>
</ol>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>remote</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习</title>
    <url>/2020/06/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="深度学习与神经网络的区别"><a href="#深度学习与神经网络的区别" class="headerlink" title="深度学习与神经网络的区别"></a>深度学习与神经网络的区别</h1><ul>
<li>网络架构：3-5层$\longrightarrow$上千层</li>
<li>激活函数：sigmoid$\longrightarrow$ReLU</li>
<li>层间连接：全连接$\longrightarrow$权值共享、ResNet</li>
<li>梯度下降：SGD$\longrightarrow$Adam<br>   一般先用Adam快速验证，再精调SGD进行极致优化。</li>
<li>目标函数：MSE$\longrightarrow$CE</li>
<li>除过拟合：凭经验$\longrightarrow$Dropout</li>
</ul>
<h1 id="SoftMax"><a href="#SoftMax" class="headerlink" title="SoftMax"></a>SoftMax</h1><p>SoftMax层的作用是突出最大值，并转换成概率的形式。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/softMax.jpg" alt="softMax"></p>
<p>将一些输入映射为0-1之间的实数，并且归一化保证和为1，并且按照概率分布，即分值大的值取到的概率大，分值小的值偶尔取到。</p>
<p>假定现有一个数组V，v_i 表示V中第i个元素，那么这个元素的soft-max值为$s_i = \frac{e^i}{\sum_j e^j}$</p>
<h1 id="梯度消失问题"><a href="#梯度消失问题" class="headerlink" title="梯度消失问题"></a>梯度消失问题</h1><p>随着网络层数的增加，网络发生了退化(degradation)的现象：</p>
<ul>
<li>随着网络层数的增多，训练集loss逐渐下降，然后趋于饱和；</li>
<li>当再增加网络深度时，训练集loss反而会增大；</li>
<li>不是过拟合，因为在过拟合中训练loss是一直减小的。</li>
</ul>
<p>梯度消失的原因：</p>
<ul>
<li>神经元的激活函数采用了Sigmoid函数；</li>
<li>大部分情况下$|w| &lt; 1$，而Sigmoid的导数$\sigma’ &lt; \frac{1}{4}$。</li>
</ul>
<p>2006年，Hinton等用受限玻尔兹曼机RBM预训练的方式解决梯度消失的问题；<br>2015年，开始使用<a href="/2020/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" title="ReLU">ReLU</a>激活函数。</p>
<h1 id="目标函数-损失函数-代价函数"><a href="#目标函数-损失函数-代价函数" class="headerlink" title="目标函数/损失函数/代价函数"></a>目标函数/损失函数/代价函数</h1><h2 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h2><p>$$\sum_{i=1}^n (y_i - \widehat{y}_i)^2$$</p>
<p>预测得到的结果与真实值间的误差的平方和的平均值。</p>
<h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>$$-\sum_{i=1}^n \widehat{y}_i ln y_i = 0$$</p>
<p>计算出的y值不可能为0，可避免计算困难。<br>交叉熵目标函数的最优值搜索空间的“地形”更陡，更有利于快速找到最优值。</p>
<h1 id="学习步长"><a href="#学习步长" class="headerlink" title="学习步长"></a>学习步长</h1><ul>
<li>若学习步长过大，则目标函数可能不降低；</li>
<li>若学习步长过小，训练过程可能非常缓慢。</li>
</ul>
<p>解决方法：训练几轮后按一些因素调整学习步长。</p>
<h1 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h1><p>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Batch_Normalization.png" alt="Batch_Normalization"></p>
<ul>
<li>在每次SGD时，通过mini-batch来对相应的activation做规范化操作，使得输出信号各维度的均值为0，方差为1；</li>
<li>最后的<code>scale and shift</code>是为了让因训练所需而刻意加入的BN能够还原最初的输入。</li>
</ul>
<h1 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h1><p>当目标函数在<code>验证集</code>上不再减小时，训练就应该停止了，不能一味追求<code>训练集</code>的误差减小。</p>
<p>权重衰减：因为在BP中很多权重是无用的，因此对于原梯度下降$w \leftarrow w - \eta \frac{\partial L}{\partial w}$将权重衰减为$w \leftarrow (1-\lambda)w - \eta \frac{\partial L}{\partial w}$，其中，$\lambda$为衰减率，随着训练持续越来越小。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Dropout.jpg" alt="Dropout"></p>
<ul>
<li>每次更新参数前，按照一定的比例来删减部分神经元；</li>
<li>Dropout是集成学习的一种，使用一小块数据来训练一系列“子网络”。</li>
</ul>
<p><strong>测试时，要使用所有神经元，并且权重要按照同衰减比例缩小。</strong></p>
<p>参考：<br><a href="https://www.cnblogs.com/guoyaohua/p/8724433.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8724433.html</a></p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
  </entry>
  <entry>
    <title>数学公式</title>
    <url>/2020/04/25/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>$e^{ix} = cos{x} + isin{x}$</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F.png" alt="欧拉公式"></p>
<h1 id="链式求导法则"><a href="#链式求导法则" class="headerlink" title="链式求导法则"></a>链式求导法则</h1><p>$$(f(g(x)))’ = f’(g(x)) g’(x)$$</p>
<p>或</p>
<p>$$\frac{dy}{dx} = \frac{dy}{dz} \cdot \frac{dz}{dx}$$</p>
<h1 id="极大似然估计MLE"><a href="#极大似然估计MLE" class="headerlink" title="极大似然估计MLE"></a>极大似然估计MLE</h1><ol>
<li>样本集中的样本都是独立同分布iid的，可以只考虑一类样本集D，来估计参数向量$\theta$。</li>
</ol>
<p>$D = {x_1, x_2, … ,x_N}$</p>
<ol start="2">
<li>似然函数(likelihood function)：联合概率密度函数$p(D| \theta )$称为相对于$\theta$的似然函数。</li>
</ol>
<p>$l(\theta) = p(D|\theta) = p(x_1, x_2,…,x_N | \theta) = \prod_{i=1}^N p(x_i | \theta)$</p>
<p>当$\widehat{\theta}$是参数空间中<strong>使似然函数最大的$\widehat{\theta}$值</strong>，那么，$\widehat{\theta}$很可能是最可能的参数值，则$\widehat{\theta}$为$\theta$的极大似然估计量。</p>
<ol start="3">
<li>MLE：求解使得出现该组样本的概率最大的$\theta$值。</li>
</ol>
<p>$$\widehat{\theta} = arg\underset{\theta}max l(\theta) = arg\underset{\theta}max \prod_{i=1}^N p(x_i | \theta)$$</p>
<ol start="4">
<li>对数似然函数（便于分析）</li>
</ol>
<p>$$\widehat{\theta} = arg\underset{\theta}max H(\theta) = arg\underset{\theta}max ln l(\theta) = arg\underset{\theta}max \sum_{i=1}^N ln p(x_i|\theta)$$</p>
<h1 id="Lipschitz连续"><a href="#Lipschitz连续" class="headerlink" title="Lipschitz连续"></a>Lipschitz连续</h1><p>在一个连续函数f上面额外施加一个限制，要求存在一个常数$K \geq 0$，使得定义域内的任意两个元素$x_1$和$x_2$都满足$|f(x_1) - f(x_2)| \leq K|x_1 - x_2|$，即f的导数的绝对值不超过K。</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>激活函数</title>
    <url>/2020/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/sigmoid.jpg" alt="sigmoid"></p>
<p>$g(z) = \frac{1}{1 + e^{-z}}$</p>
<p>常用于二元分类的输出层，输出介于0-1之间。</p>
<h1 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/tanh.png" alt="tanh"></p>
<p>$tanh(x) = \frac{e^x - e^{-x}}{e^{-x} + e^x}$</p>
<h1 id="ReLu"><a href="#ReLu" class="headerlink" title="ReLu"></a>ReLu</h1><p><em>rectified linear unit，修正线性单元</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/ReLU.jpg" alt="ReLU"></p>
<ul>
<li>常规ReLU：$Max(0,x_i)$<ul>
<li>当$x\geq0$时，$y_i=x_i$；</li>
<li>当$x&lt;0$时，$y_i=0$；</li>
</ul>
</li>
<li>Leaky ReLU：$Max(ax_i,x_i)$<ul>
<li>当$x\geq0$时，$y_i=x_i$；</li>
<li>当$x&lt;0$时，$y_i=a_i x_i$；</li>
</ul>
</li>
<li>Randomized Leaky ReLU：<ul>
<li>当$x\geq0$时，$y_i=x_i$；</li>
<li>当$x&lt;0$时，$y_{ji}=a_{ji} x_{ji}$；</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/ReLU%E6%BF%80%E6%B4%BB.png" alt="ReLU激活"></p>
<p>使用ReLU激活后，一些单元的输出成了0，另一些则变为线性单元，避免了调整各层权重时的梯度消失的问题。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/ReLU%E4%BC%98%E5%8C%96.png" alt="ReLU优化"></p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
  </entry>
  <entry>
    <title>熵</title>
    <url>/2020/06/27/%E7%86%B5/</url>
    <content><![CDATA[<h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><ul>
<li>假设一个样本集中有<strong>两个概率分布p、q</strong>，其中p为真实分布，q为非真实分布；</li>
<li>按照真实分布p来衡量识别一个样本所需要的编码长度的期望为：$$\sum_i p(i) \cdot log(\frac{1}{p(i)})$$</li>
<li>按照错误分布q表示来自真实分布p的平均编码长度的期望为：$$\sum_i p(i) \cdot log(\frac{1}{q(i)})$$</li>
<li>$H(p,q)$称之为交叉熵。</li>
</ul>
<h1 id="相对熵-KL散度"><a href="#相对熵-KL散度" class="headerlink" title="相对熵/KL散度"></a>相对熵/KL散度</h1><p>KL散度，是两个概率分布P和Q差别的非对称性的度量。</p>
<p>通常情况下，</p>
<ul>
<li>P表示数据的真实分布；</li>
<li>Q表示数据的理论分布（模型分布、P的近似分布）$D(P||Q) = \sum P(x) log \frac{P(x)}{Q(x)}$ 。</li>
</ul>
<p>KL散度<strong>不对称</strong>，不满足距离的性质，即$D_{KL}(P||Q) \neq D_{KL}(Q||P)$ 。</p>
<h1 id="JS散度"><a href="#JS散度" class="headerlink" title="JS散度"></a>JS散度</h1><p>JS散度，度量两个概率分布的相似度；是基于KL散度的变体，解决了KL散度非对称性的问题。</p>
<p>$$JS(P||Q) = \frac{1}{2} KL(P(x)||\frac{P(x)+Q(x)}{2}) + \frac{1}{2} KL(Q(x)||\frac{P(x)+Q(x)}{2})$$</p>
<p>KL散度具有对称性，其取值区间为[0,1]。</p>
]]></content>
  </entry>
  <entry>
    <title>生成对抗网络</title>
    <url>/2020/06/09/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="生成式模型和判别式模型"><a href="#生成式模型和判别式模型" class="headerlink" title="生成式模型和判别式模型"></a>生成式模型和判别式模型</h1><ul>
<li>判别式模型</li>
</ul>
<p>已知观察变量X和隐含变量z，对$p(z|X)$进行建模，根据输入的观察变量x得到隐含变量z出现的概率。</p>
<ul>
<li>生成式模型</li>
</ul>
<p>已知观察变量X和隐含变量z，对$p(X|z)$进行建模，根据隐含变量z得到输出是观察变量x的概率。</p>
<h1 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/GAN%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="GAN基本流程"></p>
<ul>
<li><p>生成器网络Generator：$x = G(z; \theta^{(G)})$，负责生成样本数据；</p>
<ul>
<li>输入：高斯白噪声向量z；</li>
<li>输出：样本数据向量x；</li>
</ul>
</li>
<li><p>判别器网络Discriminator：$y = D(x, \theta^D)$，负责检测样本数据真假；</p>
<ul>
<li>输入：真实/生成 样本数据；</li>
<li>输出：真/假 标签；</li>
</ul>
</li>
</ul>
<p><em>该网络参数一定满足可微分。</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/G2D.png" alt="G2D"></p>
<p>基本思路：</p>
<ol>
<li>让第一代的G产生一些图片，将其和部分真实图片放到D中学习；</li>
<li>让第一代的D能够分辨生成的图片和真实的图片；</li>
<li>训练第二代的G，让第二代G生成的图片，能欺骗过第一代的D；</li>
<li>训练第二代的D；</li>
<li>依次循环3、4，直到满足终止条件。</li>
</ol>
<p><em>通过将新一代的G和上一代的D连接起来(感觉有些类似级联分类器)，形成一个新的G，生成能欺骗过上一代D的图像。</em></p>
<p>模型的目标：</p>
<ul>
<li>训练数据集的模型：$x ~ p_{train} (x)$</li>
<li>生成样本的模型：$x ~ p_{model} (x)$</li>
<li>使其相等：$p_{train} (x) = p_{model} (x)$</li>
</ul>
<p>优化目标/价值函数：<br>  $$min_G max_D V(D,G) = E_{x \sim p_{data}(x)} [log D(x)] + E_{z \sim p_z(z)} [log (1-D(G(z)))]$$</p>
<ul>
<li>生成器G固定后，使用$max_D V(D,G)$来评价$p_{data}$和$p_z$间的差异；</li>
<li>判别器优化方向 -&gt; 最大化价值函数$$J(D) = -\frac{1}{2} E_{x \sim p_{data}} log D(x) - \frac{1}{2} E_z log(1-D(G(z)))$$；</li>
<li>生成器优化方向 -&gt; 最小化价值函数$$J(G) = -J(D) = \frac{1}{2} E_z log(1-D(G(z)))$$；</li>
</ul>
<p>  <em>优化目标函数，直到达到纳什均衡</em></p>
<p>为了引入KL散度和JS散度，对目标函数进行变换：</p>
<ol>
<li>$KL(P_1||P_2)=E_{x \sim P_1} log \frac{P_1}{P_2}$</li>
<li>$JS(P_1||P_2)=\frac{1}{2} KL(P_1|| \frac{P_1+P_2}{2} + \frac{1}{2} KL(P_2|| \frac{P_1+P_2}{2})$</li>
<li>$2JS(P_r||P_g) - 2log2$</li>
<li>$E_{x \sim P_r}[log D(x)] + E_{x \sim P_g}[log (1-D(x)]$</li>
<li>$E_{x \sim P_r}log \frac{P_r (x)}{\frac{1}{2} [P-r(x) + P_g(x)]} + E_{x \sim P_g}log \frac{P_g(x)}{\frac{1}{2} [P_r(x) + P_g(x)]} - 2log2$</li>
</ol>
<p>在最优判别器下，GAN定义的$G_{loss}$可等价变换为<strong>最小化真实函数与生成分布</strong>的JS散度。</p>
<p>主要解决问题：</p>
<ul>
<li>构建高维、复杂概率分布；</li>
<li>解决数据缺少问题；</li>
<li>用于多模态输出；</li>
<li>解决真实输出任务；</li>
<li>进行数据预测etc。</li>
</ul>
<p>存在问题：</p>
<ul>
<li>训练困难，难以达到纳什均衡点，且无法有效监控收敛状态；</li>
<li>模型崩溃，D能力明显强于G；</li>
<li>输出多样性低，G将数据集中生成在D最好的空间点；</li>
<li>不适用于离散输出（不可微分）。</li>
</ul>
<h2 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DCGAN.png" alt="DCGAN"></p>
<p>模型稳定训练的tricks：</p>
<ul>
<li>全连接层、池化层、上采样层 -&gt; 卷积层；</li>
<li>使用<code>batch normalization</code>；</li>
<li>生成器中使用ReLU激活函数，输出使用Tanh；</li>
<li>判别器中使用<code>Leaky ReLU</code>激活函数；</li>
<li>使用Adam优化器训练，学习率建议0.0002。</li>
</ul>
<p>生成的特征具有向量的计算特性，即特征可以进行加减运算。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/z%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E7%89%B9%E6%80%A7.png" alt="z向量的计算特性"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/z%E5%90%91%E9%87%8F%E7%9A%84%E6%8F%92%E5%80%BC%E7%89%B9%E6%80%A7.png" alt="z向量的插值特性"></p>
<p>生成效果：LSUN数据集</p>
<ul>
<li>仅支持低分辨率的图片；</li>
<li>无法捕捉物体的结构特性。</li>
</ul>
<h2 id="CGAN"><a href="#CGAN" class="headerlink" title="CGAN"></a>CGAN</h2><p>将GAN中输入的随机的数据，更改为有意义的数据。ex.手写数字字体的生层，输入的是一个数字，输出对应的字体。</p>
<p>实现思路：</p>
<ul>
<li>在生成网络的输入z的基础上连接一个输入y；</li>
<li>在判别网络的输入x的基础上连接一个y；</li>
<li>目标函数变为 $$ min_G max_D V(D,G) = E_{x \sim p_{data}(x)} [log D(x|y)] + E_{z \sim p_z(z)} [log (1-D(G(z|y)))] $$。</li>
</ul>
<h2 id="Wasserstein-GAN"><a href="#Wasserstein-GAN" class="headerlink" title="Wasserstein GAN"></a>Wasserstein GAN</h2><p>目标函数问题：</p>
<ul>
<li>$P_r$和$P_g$不重叠部分，JS为固定常数，对SGD来说梯度为0；</li>
<li>$P_r$和$P_g$的重叠部分基本可以忽略；</li>
<li>在最优D下，最小化G的loss等价于最小化$P_r$和$P_g$间的JS散度。</li>
</ul>
<p>由于$P_r$和$P_g$多少都会有可以忽略的重叠部分，所以，无论相聚多远，JS散度都是常数，最终导致G的梯度近似为0，梯度消失。</p>
<p>Wasserstein距离/Earth-Mover距离：$$W(P_r,P_G)=inf_{\gamma \sim \Pi(P_r, P_g)} \mathbb{E}_{(x,y)\sim \gamma} [||x-y||]$$</p>
<p>$W(P_r,P_G)$即为最优路径规划下的最小能量，可理解为将$P_r$转为$P_g$的能量。</p>
<p>Wasserstein距离相比KL散度、JS散度的优点：即便两个分布没有重叠，Wasserstein距离依然能反映$P_r$和$P_g$的距离。</p>
<p>目标函数：</p>
<ul>
<li>生成器loss：$-\mathbb{E}_{x\sim P_g}[f_w(x)]$</li>
<li>判别器loss：$\mathbb{E}<em>{x\sim P_g}[f_w(x)] - \mathbb{E}</em>{x\sim P_r}[f_w(x)]$</li>
</ul>
<p>创新点：</p>
<ol>
<li>判别器最后一层去掉sigmoid（不做分类，改为回归问题）；</li>
<li>G和D的loss不取log；</li>
<li>每次更新D的参数后将其绝对值截断到不超过一个固定常数c；</li>
<li>不用基于动量的优化算法(momentum、adam等)，推荐RMSProp、SGD等。</li>
</ol>
<p>实现效果：</p>
<ul>
<li>解决GAN训练不稳定的问题，无需担心平衡G和D的训练程度；</li>
<li>基本解决<code>collapse mode</code>的问题，确保生成样本的多样性；</li>
<li>训练过程中拥有了交叉熵、准确率等数值表示来指导训练的过程，数值越小G生成的图像质量越高；</li>
<li>最简单的多层全连接网络即可达到较好效果，不需精心设计的网络架构。</li>
</ul>
<p><em>WGAN不用DCGAN各种特殊的架构设计，与DCGAN结果类似。</em></p>
<h1 id="Super-ResolutionGAN"><a href="#Super-ResolutionGAN" class="headerlink" title="Super-ResolutionGAN"></a>Super-ResolutionGAN</h1><p>$I^{HR}$，高分辨率图像，来自数据库；<br>$I^{LR}$，由$I^{HR}$进行高斯滤波，然后下采样获得。</p>
<p>目标函数：<br>$$min_{\theta_G} max_{\theta_D} \mathbb{E}<em>{I^{HR} \sim p</em>{train}(I^{HR})}[log D_{\theta_D}(I^{HR})] + \mathbb{E}<em>{I^{LR} \sim p_G(I^{LR})}[log (1- D</em>{\theta_D}(G_{\theta_G}(I^{LR})))]$$</p>
<p>参数$\theta_G$通过优化一个损失函数$l^{SR}$得到：$$\widehat{\theta}<em>G = arg min</em>{\theta_G} \frac{1}{N} \sum_{n=1}^N l^{SR} (G_{\theta_G}(I_n^{LR}), I_n^{HR})$$</p>
<ol>
<li>生成网络：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/SRGAN_G.png" alt="SRGAN_G"><ul>
<li>应用分布相同的B残差块，每个残差块由两个卷积层；</li>
<li>卷积层后加上BN层，并用PReLU为激活函数；</li>
<li>卷积层的卷积核全部为3*3，并有64个特征图；</li>
<li>添加跳层/跃层连接。</li>
</ul>
</li>
<li>判别网络：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/SRGAN_D.png" alt="SRGAN_D"><ul>
<li>由连续卷积块构成，包括卷积层、LeakyReLU、BN层；</li>
<li>卷积核为3*3；</li>
<li>最后使用两个dense层，并通过sigmoid进行判别。</li>
</ul>
</li>
</ol>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/104575937" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104575937</a><br><a href="https://blog.csdn.net/gdymind/article/details/82696481" target="_blank" rel="noopener">https://blog.csdn.net/gdymind/article/details/82696481</a></p>
]]></content>
  </entry>
  <entry>
    <title>监督学习</title>
    <url>/2020/06/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Delta学习规则"><a href="#Delta学习规则" class="headerlink" title="Delta学习规则"></a>Delta学习规则</h1><p>通过神经元的实际输出，与期望输出的差别，来调整连接权重。</p>
<p>$$\bigtriangleup w_{ij} = a \cdot (d_i - y_i) x_j(t)$$</p>
<p>其中,</p>
<ul>
<li>$\bigtriangleup w_{ij}$表示神经元j到神经元i的连接权重增量；</li>
<li>$d_i$是神经元i的期望输出；</li>
<li>$y_i$是神经元i的实际输出；</li>
<li>$x_i$是神经元j的状态；</li>
<li>$a$表示学习速率。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>皮囊</title>
    <url>/2020/03/09/%E7%9A%AE%E5%9B%8A/</url>
    <content><![CDATA[<p>本来是抱着一个很轻松的心情翻开这本书的，但是在看完几页之后愈感沉重，以至于不得不分到几天时间才能看完。总体来说，这种书写得很厚重，只有在经历了人生的坡坡坎坎之后才能有此积淀。我觉得这本书最出彩的地方在于它可以主动去勾起你的回忆，以及对人生的思考。人生在世，我们每个人都披了一层皮囊，以此区别于不同的人，为其注入各种不同的思想，活出自己的精彩人生。</p>
<p>倔强而又骄傲的母亲，为了完成与心爱之人的约定，执着又顽强的坚定的遵从自己的内心。活出了女性的坚持与美丽。与之对应的是爱面子的父亲，在重病期间依旧想的是如何撑起这个家，他将一生全部奉献给了这个家。这是国内传统家庭的真实写照，男主外女主内，在父亲病重后由儿子撑起这个家，在这种交替中，完成了一种身份的转变，责任的交接。</p>
<p>“张美丽”和“阿小”是当时在那个大环境下的必然产物，是人的内心欲望使然，是人们开始过上美好富裕生活的必然转变，他们是活在了那个特殊的年代，因此显得与周围人格格不入，也正是由于有了这些人的存在，为我们的时代发展转变做出了自己的贡献，我们在现代这个大环境下才活得那么的自然。</p>
<p>“天才文展”与“厚朴”是我们基本都会遇到的，一个被尊奉为天才，一个充满正能力，有理想，是我们每个人都渴望成为的那类人的分解。“天才文展”学习好，够坚持，有目标，但是活得过于压抑；“厚朴”每天活在自己的想象中，快乐，虚假，脱离了实际。这两类人又是两种互补人格，以两个人的结局与自己形成鲜明对比，告诫我们要如何选择自己的人生。</p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>目标检测DPM</title>
    <url>/2020/06/02/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BDPM/</url>
    <content><![CDATA[<h1 id="DPM"><a href="#DPM" class="headerlink" title="DPM"></a>DPM</h1><p>该模型包含了一个<code>8*8</code>分辨率的根滤波器(Root filter)，和<code>4*4</code>分辨率的组件滤波器(Part filter)，和高斯滤波后的2倍空间模型。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DPM.png" alt="DPM"></p>
<p><em>中间分辨率为左图的2倍，梯度更加精细。</em></p>
<p><em>自行车DPM检测：</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%87%AA%E8%A1%8C%E8%BD%A6DPM.png" alt="自行车DPM"></p>
<h2 id="响应分数"><a href="#响应分数" class="headerlink" title="响应分数"></a>响应分数</h2><p>$$ score(x_0, y_0, l_0) = R_{0,l_0}(x_0, y_0) + \sum_{i=1}^n D_{i,l_0-\lambda}(2(x_0,y_0)+v_i) + b $$</p>
<p>其中，$x_0,y_0,l_0$分布为锚点的横坐标、纵坐标、尺度；<br>$R_{0,l_0}(x_0,y_0)$为跟模型的响应分数；<br>$D_{i,l_0-\lambda}(2(x_0,y_0)+v_i)$为部件模型的响应分数；<br>b为不同模型组件间的偏移系数，使其与根模型对齐；<br>$2(x_0,y_0)$表示组件模型的像素为原始的2倍。</p>
<h2 id="检测流程"><a href="#检测流程" class="headerlink" title="检测流程"></a>检测流程</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DPM%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B.png" alt="DPM检测流程"></p>
<ol>
<li>对输入图像，提取其DPM特征图，然后将原图像进行高斯金字塔上采样，然后提取其DPM特征图；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DPM_31D%E7%89%B9%E5%BE%81.png" alt="DPM_31D特征"></li>
<li>对原图像的DPM特征图和训练好的<code>Root filter</code>做卷积操作，得到<code>Root filter</code>的响应图；</li>
<li>对2倍图像的DPM特征图和训练好的<code>Part filter</code>做卷积，得到<code>Part filter</code>的响应图；</li>
<li>对其精细高斯金字塔做下采样操作，使<code>Root filter</code>响应图和<code>Part filter</code>响应图具有相同分辨率；</li>
<li>对其进行加权平均，得到最终响应图。<em>亮度越大响应值越大</em></li>
</ol>
<h2 id="Latent-SVM"><a href="#Latent-SVM" class="headerlink" title="Latent SVM"></a>Latent SVM</h2><a href="/2020/06/02/svm/" title="Latent-SVM">Latent-SVM</a>

<p>DPM选择最大的正样本，但是其latent变量较多，如<code>bounding box</code>在HOG特征金字塔中的level，某样本属于哪一类component。<br>即有一张正样本图像，标注了<code>bounding box</code>，我们要在某一位置、某一尺度，提取出最大正样本作为某一component的正样本。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/DPM-SVM.png" alt="DPM-SVM"></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>object detection</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生复试</title>
    <url>/2018/03/15/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/</url>
    <content><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>Good morning, dear professors. It is my pleasure to be here for this interview. My name is …, I am 24 years old, born in …, hebei province. I have finished my graduate education in … university, majoring in software engineering.</p>
<p>I have broad interests. In my spare time, I like riding, reading and especially in engineering such as software programming, website design. I like to ride a bike to relax when I am in a bad mood or I have no idea. In the past few years, I have accomplished two websites: one is the website of our online examination system, and the other is the website of my graduation design. Furthermore, I am interested in C programming language and have written some application programs. During the days preparing for postgraduate examination I insist on running everyday. Thanks to this, I could concentrate on my study .</p>
<p>Although I have broad interests in many aspects and grasp the essential knowledge of the major, but I think at present, I can do many things in a superficial level, but not be competent to do things professionally owing to lack of ample knowledge and ability. So I think further study is still urgent for me to realize self-value. I think further education is still urgent for me to realize self-value. Life is precious. It is necessary to seize any chance for self-development, especially in this competitive modern world. In a word, I am looking forward to making a solid foundation for future profession after three years study here. </p>
<p>If I got a chance to study here, I would spare no effort to do research of my major, build up systematic view of management and achieve self value .</p>
<p>That’s all. Thank you.</p>
]]></content>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/2020/06/05/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png" alt="人工神经网络"></p>
<p>神经网络：由大量神经元节点按照一定体系架构连接而成的网状结构，一般包含输入层、隐藏层、输出层三部分。</p>
<p>神经网络可用于分类、模式识别、连续值预测 etc. </p>
<p><em>一般的浅层网络只有3-5层，这也是区别于DL的主要地方。</em></p>
<h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><h3 id="生物神经元"><a href="#生物神经元" class="headerlink" title="生物神经元"></a>生物神经元</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%94%9F%E7%89%A9%E7%A5%9E%E7%BB%8F%E5%85%83.jpg" alt="生物神经元"></p>
<p>生物神经元之间的相互连接，使得信息在大脑中得以传递。</p>
<h3 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h3><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E5%85%83.jpg" alt="人工神经元"></p>
<p>每个神经元都是一个结构相似的独立单元，接受前一层传来的数据，并将其加权和输入到非线性激活函数中，然后，将非线性激活函数的输出传递给下一层。</p>
<p>神经元包括以下内容：</p>
<ul>
<li>输入向量x；</li>
<li>权重向量w；</li>
<li>偏置向量b；</li>
<li>激活函数f；</li>
</ul>
<h2 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h2><ul>
<li>前馈神经网络采用一种单向多层结构；</li>
<li>各神经元从输入层开始，接收前一级输入，并输出到下一级，直到输出层。</li>
<li>每一层包含若干各神经元，同一层间的神经元间没有连接，层间信息的传递只沿一个方向进行；</li>
<li>整个网络中没有反馈，类似一个有向无环图。</li>
</ul>
<h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><a href="/2020/06/05/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" title="Delta学习规则">Delta学习规则</a>

<p>$$J(w) = \frac{1}{2} \Vert t - z \Vert^2 = \frac{1}{2} \sum_{k=1}^c (t_k - z_k)^2$$<br>其中，$t = (t_1,…,t_c$表示期望输出，$z = (z_1,…,z_c$表示实际输出。</p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/gradient_descent.png" alt="gradient_descent"></p>
<p>这是一个表示参数w与目标函数J(w)的关系图，红色部分表示J(w)有较高取值，需要让J(w)的值尽可能降低，到达深蓝色部分。</p>
<p>$$w(m+1) = w(m) + \bigtriangleup w(m) = w(m) - \eta \frac{\partial J}{\partial w}$$</p>
<p>看到一个很形象的示意图：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="梯度下降示意图"></p>
<p>整体思路：</p>
<ul>
<li>先确定一个初始点；</li>
<li>将w按照梯度下降方向进行调整，使J(w)向更低方向变化；</li>
<li>直到，w无法继续下降为止。</li>
</ul>
<h2 id="误差反向传播"><a href="#误差反向传播" class="headerlink" title="误差反向传播"></a>误差反向传播</h2><p>定义几个变量：J为目标函数；z为输出结果；$net_k$为输出单元的总输入；$net_j$为隐藏层单元的总输入；$y_j$为隐藏层单元的输出。</p>
<ol>
<li>输出层权重改变量：</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%BE%93%E5%87%BA%E5%B1%82%E6%9D%83%E9%87%8D%E6%94%B9%E5%8F%98.png" alt="输出层权重改变"></p>
<p>$$\frac{\partial J}{\partial w_{kj}} = \frac{\partial J}{\partial net_k} \frac{\partial net_k}{\partial w_{kj}}$$</p>
<p>其中，</p>
<ul>
<li>$$J(w) = \frac{1}{2} \Vert t - z \Vert^2 = \frac{1}{2} \sum_{k=1}^c (t_k - z_k)^2$$</li>
<li>$$net_k = \sum_{i=1}^{n_H} w_{ki}y_i$$</li>
<li>$$\frac{\partial J}{\partial net_k} = \frac{\partial J}{\partial z_k} \frac{\partial z_k}{\partial net_k} = -(t_k - z_k) f’(net_k)$$</li>
<li>$$\frac{\partial net_k}{\partial w_{kj}} = y_j$$</li>
</ul>
<ol start="2">
<li>隐藏层权重改变量：</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%9A%90%E8%97%8F%E5%B1%82%E6%9D%83%E9%87%8D%E6%94%B9%E5%8F%98.png" alt="隐藏层权重改变"></p>
<ul>
<li>先找到$w_{ji}$与$net_j$的关系；</li>
<li>然后找$net_j$与隐藏层输出$y_j$的关系。</li>
</ul>
<p>$$\frac{\partial J}{\partial w_{ji}} = \frac{\partial J}{\partial y_j} \frac{\partial y_i}{\partial net_j} \frac{\partial net_j}{\partial w_{ji}}$$</p>
<p>其中，</p>
<ul>
<li>$$\frac{\partial net_j}{\partial w_{ji}} = \frac{\partial}{\partial w_{ji}} (\sum_{m=1}^d w_{jm} x_m) = x_i$$</li>
<li>$$\frac{\partial y_j}{\partial net_j} = f’(net_j)$$</li>
<li>$$\frac{\partial J}{\partial y_i} = \frac{\partial}{\partial y_j} [\frac{1}{2} \sum_{k=1}^{c} (t_k - z_k)^2] = -\sum_{k=1}^c (t_k - z_k) \frac{\partial z_k}{\partial y_i} = -\sum_{k=1}^c (t_k - z_k) \frac{\partial z_k}{\partial net_k} \frac{\partial net_k}{\partial y_i} =  -\sum_{k=1}^c (t_k - z_k) f’(net_k) w_{kj}$$</li>
</ul>
<ol start="3">
<li>输出层和隐藏层的误差传播公式可统一为：</li>
</ol>
<ul>
<li>权重增量 = -1 * 学习步长 * 目标函数对权重的偏导数；</li>
<li>目标函数对权重的偏导数 = -1 * 残差 * 当前层的输入；</li>
<li>残差 = 当前层激活函数的导数 * 上层反传的误差；</li>
<li>上层反传的误差 = 上层残差的加权和。</li>
</ul>
<h3 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h3><p>随机梯度下降SGD在样本量很大时，对每个样本迭代更新速度过慢，可能只需其中部分样本即可迭代到最优解。</p>
<p>SGD噪音比BGD(批量梯度下降)多，因此，并不是每次迭代都向着整体最优方向。</p>
<p>优点：<strong>稳定</strong>。</p>
<p>存在的问题：</p>
<ul>
<li>学习步长不易确定，太小收敛满，太大损失函数会在极小值处震荡或偏离；</li>
<li>每个参数的learning rate都相同，当数据稀疏时，难以对出现频率低的特征进行大一点的更新；</li>
<li>学习过程中容易陷入到马鞍面中，所有方向梯度值几乎为0；</li>
</ul>
<p><em>马鞍面：</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%A9%AC%E9%9E%8D%E9%9D%A2.png" alt="马鞍面"></p>
<h3 id="Mini-batch-Gradient-Descent"><a href="#Mini-batch-Gradient-Descent" class="headerlink" title="Mini-batch Gradient Descent"></a>Mini-batch Gradient Descent</h3><p>每次从所有训练数据中取一个子集用于计算梯度，是BGD和SGD的折中。</p>
<ul>
<li>在CNN训练时，绝大多数都采用基于mini-batch的随机梯度下降算法为基础进行训练；</li>
<li>随着输入数据的不断变化，网络中的参数不断调整，网络各层输入数据的分布也不断变化；</li>
<li>各层在训练的过程中需要不断的改变，以适应新的数据分布，容易造成网络训练困难，难以拟合的问题。</li>
</ul>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
  </entry>
  <entry>
    <title>科学上网</title>
    <url>/2020/03/09/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>在<a href="https://my.vultr.com" target="_blank" rel="noopener">vultr</a>注册并创建一个国外的服务器，本人使用的是 <code>Ubuntu1604</code> 版本的服务器。</p>
<h2 id="V2Ray配置"><a href="#V2Ray配置" class="headerlink" title="V2Ray配置"></a>V2Ray配置</h2><ul>
<li><p>安装 <code>V2Ray</code>，安装后输入 <code>v2ray</code> 即可进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;KiriKira&#x2F;v2ray.fun&#x2F;kiriMod&#x2F;install.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;KiriKira&#x2F;v2ray.fun&#x2F;kiriMod&#x2F;uninstall.sh &amp;&amp; bash uninstall.sh</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="进行加速配置："><a href="#进行加速配置：" class="headerlink" title="进行加速配置："></a>进行加速配置：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget —no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>
<ol>
<li>更改加速权限：<code>chmod +x bbr.sh</code>；</li>
<li>开始进行配置：<code>./bbr.sh</code>；</li>
<li>安装后重启；</li>
<li>验证加速设置 <code>lsmod | grep bbr</code>，出现 <code>tcp_bbr</code>。</li>
</ol>
<h2 id="SSR配置（不建议使用）"><a href="#SSR配置（不建议使用）" class="headerlink" title="SSR配置（不建议使用）"></a>SSR配置（不建议使用）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ToyoDAdoubi&#x2F;doubi&#x2F;master&#x2F;ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>
<p>修改时使用 <code>bash ssr.sh</code> 进入管理界面。</p>
<hr>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="Mac推荐使用-V2RayU-进行配置"><a href="#Mac推荐使用-V2RayU-进行配置" class="headerlink" title="Mac推荐使用 V2RayU 进行配置"></a>Mac推荐使用 <code>V2RayU</code> 进行配置</h2><h2 id="Chrome管理插件-Proxy-SwitchyOmega"><a href="#Chrome管理插件-Proxy-SwitchyOmega" class="headerlink" title="Chrome管理插件 Proxy SwitchyOmega"></a>Chrome管理插件 <code>Proxy SwitchyOmega</code></h2><ol>
<li>先配置Proxy文件，端口号根据自己设定自行更改；</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Proxy%E9%85%8D%E7%BD%AE.png" alt="Proxy配置"></p>
<ol start="2">
<li>再配置Switch文件，并添加规则；</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Switch%E9%85%8D%E7%BD%AE.png" alt="Switch配置"><br>规则链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gfwlist&#x2F;gfwlist&#x2F;master&#x2F;gfwlist.txt</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可自定添加规则定制，如添加YouTube设置；<br>在Switch配置文件中，选择 <code>Add condition</code> ，在域名前更改为 * ，并更改 <code>Profile</code>。</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E8%87%AA%E5%AE%9A%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE.png" alt="自定规则配置"></p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>稀疏表示</title>
    <url>/2020/03/16/%E7%A8%80%E7%96%8F%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h1><p>就是给定一组数据，我们要尽可能的用更少的数据来表示该数据。稀疏表示对应一个超完备字典，利用少量数据与字典的矩阵乘法运算来表示该组数据。<br>即假如原本包含5个值，我们用SR，只用4个值就可以表示。(此处借用一张导师给的example)<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/sr%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.jpg" alt="sr简单理解"></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>在稀疏表示学习过程中，必然会接触到以下词汇：</p>
<pre><code>- autoencoder：简单理解为一个压缩编码器；
- sparse coding：是将输入的样本集X分解为多个基元的线性组合；
- Sparse Autoencoder = sparse coding + autoencoder。</code></pre><p>$$ min_{A,\alpha_i} \sum^m_{i=1} ||{x_i-A\alpha_i}||^2_2 + \lambda \sum^m_{i=1} ||{\alpha_i}||_1 $$<br>第一个累加项说明了字典学习的第一个目标是字典矩阵与稀疏表示的线性组合尽可能的还原样本；<br>第二个累加项说明了 $ \alpha_i $ 应该尽可能的稀疏。<br>满足条件：<br>    $ A^T_j*A_j\leq1 \forall j $<br>    即按常数比例缩放A的同时再按这个常数的倒数缩放\alpha，结果不会改变误差大小，却会减少稀疏代价值。</p>
<p>总体来说，可以归为两部分，先构建一个超完备字典，再通过约束条件（可以是非0个数等）对字典进行一个约束，因为合适的字典一般不只是一个。<br>在常见的PCA算法中，是可以找到一组基来分解X的，只不过那个基的数目比较小，所以可以得到分解后的系数a是可以唯一确定，而在sparse coding中，k太大，比n大很多，其分解系数a不能唯一确定。一般的做法是对系数a作一个稀疏性约束，这也就是sparse coding算法的来源。</p>
<p>$$ J(A,s)=||{x-As}||^2_2 + \lambda \sqrt{s^2+\epsilon}+\gamma||A||^2_2 $$<br>针对上式进行了优化，尤其是对 <code>s</code> 取第一范式时在 <code>0</code> 处不可导问题。</p>
<h1 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h1><p>一些初始化的设置，随后进行迭代优化。</p>
<ol>
<li>随机初始化A</li>
<li>重复以下步骤直至收敛：<ul>
<li>根据上一步给定的A，求解能够最小化J(A,s)的s</li>
<li>根据上一步得到的s，，求解能够最小化J(A,s)的A</li>
</ul>
</li>
</ol>
<p>优化：</p>
<ul>
<li>将样本分批为“mini块”</li>
<li>设置良好的 <code>s</code> 初始值 </li>
</ul>
<hr>
<h2 id="部分以下待完善"><a href="#部分以下待完善" class="headerlink" title="部分以下待完善"></a>部分以下待完善</h2><h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><ul>
<li><p>patch：20000</p>
</li>
<li><p>特征数：256，此处在后续使用时标注121</p>
</li>
<li><p>块维度：16</p>
</li>
<li><p>可见大小：16*16=256，此处在后续使用时标注64</p>
</li>
<li><p>池化维度：3</p>
</li>
<li><p>分组区域维度：3*3</p>
</li>
<li><p>每batch的patch数：2000</p>
</li>
<li><p>$ lambda $：5e-5</p>
</li>
<li><p>$ epsion $：1e-5，此处是为了防止第二个参数在原点处不可导的改进。</p>
</li>
<li><p>$ gamma $：1e-2，此处是在上式基础上添加了一个对sr的惩罚项。</p>
</li>
</ul>
<h2 id="查看mat文件包含图片内容"><a href="#查看mat文件包含图片内容" class="headerlink" title="查看mat文件包含图片内容"></a>查看mat文件包含图片内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load IMAGES.mat</span><br><span class="line">whos</span><br><span class="line">for i &#x3D; 1:10</span><br><span class="line">    subplot(4,5,i)</span><br><span class="line">    imshow(IMAGES(:,:,i))</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>图片大小为 <code>512*512</code>，共10组：<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/images_mat.jpg" alt="images_mat"></p>
<h2 id="patches设置"><a href="#patches设置" class="headerlink" title="patches设置"></a>patches设置</h2><p>参数：images; patchDim=16; numPatches=20000.<br>选取10000张图片做训练，patchsize=8</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/tornadomeet/archive/2013/04/13/3018393.html" target="_blank" rel="noopener">https://www.cnblogs.com/tornadomeet/archive/2013/04/13/3018393.html</a><br><a href="https://www.cnblogs.com/yifdu25/p/8385204.html#3991271" target="_blank" rel="noopener">https://www.cnblogs.com/yifdu25/p/8385204.html#3991271</a><br><a href="https://www.cnblogs.com/sprint1989/p/3982204.html" target="_blank" rel="noopener">https://www.cnblogs.com/sprint1989/p/3982204.html</a><br><a href="https://www.jianshu.com/p/38dc2253e4fb" target="_blank" rel="noopener">https://www.jianshu.com/p/38dc2253e4fb</a></p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>稀疏表示</tag>
      </tags>
  </entry>
  <entry>
    <title>直方图均衡化</title>
    <url>/2020/06/06/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</url>
    <content><![CDATA[<h1 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h1><ul>
<li>实质上是对图像进行非线性拉伸，重新分配各个灰度单位的像素点数量，使其均匀分布；</li>
<li>利用图像直方图对图像的对比度进行调整；</li>
<li>通常用于增强局部的对比度而不影响整体对比度，过黑或过曝的处理。</li>
</ul>
<p>思路：</p>
<ol>
<li>统计每个颜色出现的概率；</li>
<li>计算累计概率；</li>
<li>根据累计概率求取新的颜色映射表：p*255；</li>
<li>利用新颜色映射表完成颜色映射。</li>
</ol>
<h2 id="自适应直方图均衡AHE"><a href="#自适应直方图均衡AHE" class="headerlink" title="自适应直方图均衡AHE"></a>自适应直方图均衡AHE</h2><ul>
<li>移动模版在源图像上按stride滑动；</li>
<li>移动后，模版区域内做直方图均衡，映射后的结果赋值给模版区域内所有点；</li>
<li>对每个点取多次赋值的均值。</li>
</ul>
<p>缺点：过度放大平滑区域噪声。</p>
<h2 id="CLAHE（自适应直方图均衡）"><a href="#CLAHE（自适应直方图均衡）" class="headerlink" title="CLAHE（自适应直方图均衡）"></a>CLAHE（自适应直方图均衡）</h2><p>算法步骤：</p>
<ol>
<li>对图像进行分块，以块为单位；</li>
<li>先计算直方图，然后对其进行修剪，然后均衡；<br><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CLAHE%E4%BF%AE%E5%89%AA.png" alt="CLAHE修剪"></li>
<li>遍历各个图像块，对块间区域进行双线性差值，使图像平滑；</li>
<li>与源图像做涂层滤色混合操作（可选）。</li>
</ol>
<p>映射关系：<br>    <img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/CLAHE%E6%98%A0%E5%B0%84.png" alt="CLAHE映射"></p>
<ul>
<li>小黑点处的灰度值由映射函数直接计算得出；</li>
<li>粉色区域灰度值由映射函数计算得出；</li>
<li>滤色区域灰度值由相邻2块灰度值映射线性插值得出；</li>
<li>紫色区域灰度值由相邻4块灰度值映射线性插值得出。</li>
</ul>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>多尺度变换</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计与算法</title>
    <url>/2020/01/02/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="程序设计与算法-郭炜-北京大学"><a href="#程序设计与算法-郭炜-北京大学" class="headerlink" title="程序设计与算法 郭炜-北京大学"></a>程序设计与算法 郭炜-北京大学</h1><p>网课地址：<a href="https://www.icourse163.org/learn/PKU-1001894005?tid=1206483202#/learn/announce" target="_blank" rel="noopener">https://www.icourse163.org/learn/PKU-1001894005?tid=1206483202#/learn/announce</a></p>
<ul>
<li>有公式套公式，多数题目要分情况讨论；</li>
<li>浮点数比较大小不能使用==，要看其差值是否小于某一极小值。</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>完美立方、生理周期、称硬币(真假)、熄灯问题</code></p>
<p>基于逐个尝试答案的一种问题求解策略。合理缩小范围以减少计算量。</p>
<p><em>称硬币 ABCD EFGH；ABCI EFJK；ABIJ EFGH</em></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><code>求阶乘、汉诺塔问题、N皇后，逆波兰表达式、表达式求值，上台阶/爬楼梯、放苹果、算24</code></p>
<p>一个函数调用（栈）其自身。</p>
<p>用途：</p>
<ol>
<li>替代多重循环；</li>
<li>解决本来就是用递归形式定义的问题；</li>
<li>将问题分解为规模更小的子问题进行求解。</li>
</ol>
<h2 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h2><p><code>二分查找函数、二分法求方程的根（区间内单调才可求）、一对数、农夫和奶牛</code></p>
<ul>
<li>数组必须为有序数组；</li>
<li>为防止(L+R)过大溢出，应将中间元素下标设置为$mid = L + \frac{R - L}{2}$。</li>
</ul>
<p>一般题解方法：</p>
<ol>
<li>枚举/穷举；</li>
<li>先排序，再进行二分查找；</li>
<li>先排序，使用双指针进行查找遍历。</li>
</ol>
<h2 id="分治（常用递归实现）"><a href="#分治（常用递归实现）" class="headerlink" title="分治（常用递归实现）"></a>分治（常用递归实现）</h2><p><code>称假币、输出前m大的数、求排列的逆序数</code></p>
<p>将一个任务，分成形式和原任务相同，但规模更小的几个部分任务，或只需<strong>选一部分完成</strong>，然后再处理完成后几部分结果，实现整个任务的完成。</p>
<h2 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h2><p><code>数字三角形、最长上升子序列、最长公共子序列、最佳加法表达式、Help Jimmy、滑雪、神奇的口袋、0-1背包问题、分蛋糕</code></p>
<ul>
<li>避免重复计算：数字三角形的记忆递归型动归程序（使用数组存储中间计算）；递归转成递推（利用数组从底层依次向上）。</li>
<li>递推到动规的一般转化方法：递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数的逆过程。</li>
</ul>
<p>动规解题的一般思路：</p>
<ol>
<li>将原问题分解为若干子问题：<ul>
<li>将原问题分解为若干子问题，子问题和原问题形式相同或类似，只是规模变小了；</li>
<li>子问题的解一旦求出就会被保存，因此，每个子问题只需求解一次即可。</li>
</ul>
</li>
<li>确定状态：<br> <em>将与子问题相关的各个变量的一组取值称为一个“状态”。</em><br> 一个状态对应于一个或多个子问题，所谓某个状态下的值，即是该状态所对应的子问题的解。</li>
<li>确定一些初始状态（边界状态）的值；</li>
<li>确定状态转移方程。</li>
</ol>
<p>能用动规解决的问题的特点：</p>
<ul>
<li>问题具有最优子结构特性，即求最优解、最值等问题；</li>
<li>无后效性，即一旦该状态值确定，就可用此值推出下一个状态的值，而无需再使用之前确定该状态的值。</li>
</ul>
<p>动规的两种常用形式：</p>
<ol>
<li>递归型<ul>
<li>优点：直观、易编写；</li>
<li>缺点：会因递归层数深而爆栈、函数调用带来额外时间开销，无法使用滚动数组节省空间。</li>
</ul>
</li>
<li>递推型<br> 效率高，可使用滚动数组节省空间。</li>
</ol>
<h2 id="深度优先搜索："><a href="#深度优先搜索：" class="headerlink" title="深度优先搜索："></a>深度优先搜索：</h2><p><code>城堡问题、踩方格、寻路问题、生日蛋糕</code></p>
<p>在图上寻找路径：从起点出发，选取一条路走，走不通就回退。用栈进行存储。</p>
<p>图的表示方法：</p>
<ul>
<li>二维数组，时间复杂度O(n^2)；</li>
<li>邻接表，时间复杂度O(n+e),e为边的数目。</li>
</ul>
<p>优化：</p>
<ul>
<li>最优性剪枝；</li>
<li>可行性剪枝；</li>
</ul>
<h2 id="广度优先搜索："><a href="#广度优先搜索：" class="headerlink" title="广度优先搜索："></a>广度优先搜索：</h2><p><code>抓住那头牛、迷宫问题、八数码</code></p>
<p><em>对于很多深度优先搜索案例进行最优性剪枝后很像广度优先搜索</em></p>
<p>从起点开始给结点进行分层，按层进行遍历。用队列进行存储，需要大量存储空间。</p>
<h2 id="贪心算法："><a href="#贪心算法：" class="headerlink" title="贪心算法："></a>贪心算法：</h2><p><code>圣诞老人的礼物、电影节、分配畜栏、放置雷达、钓鱼</code></p>
<a href="/2020/06/04/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="贪心算法">贪心算法</a>

<ul>
<li>每一步行动总是按某种指标选取最优的操作来进行，该指标只看眼前，并不考虑以后可能造成的影响。</li>
<li>贪心算法需要证明其正确性。</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>级联分类器</title>
    <url>/2020/06/04/%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    <content><![CDATA[<h1 id="级联分类器"><a href="#级联分类器" class="headerlink" title="级联分类器"></a>级联分类器</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB.png" alt="级联分类"></p>
<p>级联分类器是将多个强分类器连接在一起进行操作，每一个强分类器都由若干个弱分类器加权构成。</p>
<p>级联分类器，每一个强分类器都是对负样本更敏感，使得每次被强分类器拒绝的，都几乎是负样本。<br>因此，通过所有强分类器的，基本上可以认定为正样本。</p>
<h1 id="强-弱分类器"><a href="#强-弱分类器" class="headerlink" title="强/弱分类器"></a>强/弱分类器</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/Boosting%E5%88%86%E7%B1%BB%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Boosting分类器示意图"></p>
<p>将每轮得到的最佳弱分类器按照一定方法(Boosting)提升为强分类器。</p>
<h2 id="弱分类器："><a href="#弱分类器：" class="headerlink" title="弱分类器："></a>弱分类器：</h2><p>训练一个弱分类器，即在当前权重分布下，确定f的最优阈值，使该弱分类器对所有训练样本的分类误差最低。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E5%BC%B1%E5%88%86%E7%B1%BB%E5%99%A8%E8%AF%86%E5%88%AB%E4%BA%BA%E8%84%B8.png" alt="弱分类器识别人脸"></p>
<ul>
<li>在海量特征中，选取一个特征，能够区分是否为人脸，使错误率最低；</li>
<li>能够以<strong>稍低于50%的错误率</strong>来区分人脸和非人脸图像；</li>
</ul>
<hr>
<h1 id="Adaboost分类器"><a href="#Adaboost分类器" class="headerlink" title="Adaboost分类器"></a>Adaboost分类器</h1><p><em>Adaboost是一种基于级联分类模型的分类器。</em></p>
<p>adaboost训练：</p>
<ol>
<li>初始化数据权值分布；</li>
<li>遍历阈值p：选取最小阈值p——t；</li>
<li>计算权重；</li>
<li>更新训练数据权重分布。</li>
</ol>
<p>训练终止条件：</p>
<ol>
<li>for循环次数；</li>
<li>p小于设定阈值。</li>
</ol>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>分类器</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/06/04/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="贪心算法-贪婪算法"><a href="#贪心算法-贪婪算法" class="headerlink" title="贪心算法/贪婪算法"></a>贪心算法/贪婪算法</h1><p>贪心算法，在每一个选择过程中都选择<strong>当前最优解</strong>，从而希望最终结果达到最优的算法。</p>
<h2 id="算法实现步骤："><a href="#算法实现步骤：" class="headerlink" title="算法实现步骤："></a>算法实现步骤：</h2><ol>
<li>创建数学模型来描述问题；</li>
<li>把求解的问题<strong>分成若干个子问题</strong>；</li>
<li>对每一子问题求解，得到子问题的<strong>局部最优解</strong>；</li>
<li>把子问题的解局部最优解合成所求问题的一个解。</li>
</ol>
<p><strong>贪心算法的实现，要根据具体问题具体分析。</strong></p>
<h2 id="常用解决的问题："><a href="#常用解决的问题：" class="headerlink" title="常用解决的问题："></a>常用解决的问题：</h2><ul>
<li>贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码、旅行推销员问题等。</li>
<li>对于其它问题，贪心算法一般不能得到我们所要求的答案，常用作辅助算法或直接解决一些要求结果不是特别严格的问题。</li>
<li>一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决该问题的最好方法。</li>
</ul>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>对解决问题具有高效性；</li>
<li>所得结果更接近于最优结果。</li>
</ul>
<h2 id="贪心算法与动态规划的不同"><a href="#贪心算法与动态规划的不同" class="headerlink" title="贪心算法与动态规划的不同"></a>贪心算法与动态规划的不同</h2><ul>
<li>贪心算法要求对每个子问题的解决方案都要做出选择，且不能回退；</li>
<li>动态规划会保存之前的运算结果，并依据以前的结果对当前方案进行选择，可回退。</li>
</ul>
<p>换个思路，就是贪心算法有一个优先级的问题；动态规划则是使用一个数组来进行记录当前方案，会对每一种方法进行尝试。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>金字塔变换</title>
    <url>/2020/05/14/%E9%87%91%E5%AD%97%E5%A1%94%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h1><p>在传统金字塔的基础上，对每一层用不同的参数$\sigma$做高斯模糊，使得每一层金字塔有多张高斯模糊图像，这样的一组图像称为一个$octave$。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94.png" alt="高斯金字塔"></p>
<p>$octave(i+1)$的第一张（从下往上）图像是由$octave(i)$中的倒数第三张图像降采样得到。</p>
<p>高斯金字塔的构建：</p>
<ol>
<li>对图像做不同尺度的高斯模糊；</li>
<li>对图像做降采样(隔点采样)。</li>
</ol>
<p>金字塔的层数根据图像的原始大小和塔顶图像的大小共同决定。<br>为使其尺度体现连续性，高斯金字塔在简单降采样的基础上添加了高斯滤波。</p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>高斯模糊是一种图像滤波器，使用正态分布(高斯函数)计算模糊模板，并使用该模板与原图像做卷积运算，达到模糊图像的目的。</p>
<p>每个像素的值都是周围相邻像素值的加权平均：原始像素的值有最大的高斯分布值，具有最大的权重，相邻像素随着距离原始像素越来越远，其权重也越来越小。</p>
<p>优点：</p>
<ul>
<li>比其它的均衡模糊滤波器更好的保留了边缘效果。<br>缺点：</li>
<li>因模板矩阵的关系而造成边缘图像缺失，$\theta$越大，缺失像素越多，丢弃模板会造成黑边；</li>
<li>当$\theta$变大时，高斯模板(高斯核)和卷积运算量将大幅度提高。</li>
</ul>
<p><em>理论上来讲，图像中每个像素点的分布都不为零，即每个像素的计算都需要包含整幅图像。</em><br><em>在实际应用中，在计算高斯函数的离散近似时，在大概$3\theta$距离之外的像素都可以看作不起作用，即高斯模板矩阵的大小$(6\theta+1) * (6\theta+1)$。大尺度对应于图像的概貌特征，小尺度对应于图像的细节特征。</em><br><em>为了确保模板矩阵中的元素在[0,1]之间，需将模板矩阵归一化。</em></p>
<h3 id="分离高斯模糊"><a href="#分离高斯模糊" class="headerlink" title="分离高斯模糊"></a>分离高斯模糊</h3><p>高斯函数的可分离性是指使用二维矩阵变换得到的效果可通过在水平方向进行一维高斯矩阵变换加上竖直方向的一维高斯矩阵变换得到。</p>
<p>根据高斯函数的可分离性，可对二维高斯模糊函数进行改进：两次一维的高斯卷积将消除二维高斯矩阵所产生的边缘。</p>
<h1 id="高斯差分金字塔"><a href="#高斯差分金字塔" class="headerlink" title="高斯差分金字塔"></a>高斯差分金字塔</h1><p>高斯差分函数，Difference of Gaussian，简称DoG算子，可产生较强的边缘响应。</p>
<p>在实际计算时，使用<strong>高斯金字塔每组中相邻上下两层图像相减，得到高斯差分图像</strong>，进行极值检测。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/LoG_DoG.jpg" alt="LoG_DoG"></p>
<p>由于高斯差分的计算更加简单，因此常用DoG算子近似替代LoG算子。</p>
<a href="/2020/05/25/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81/" title="高斯拉普拉斯LoG">高斯拉普拉斯LoG</a>

<h1 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94.png" alt="拉普拉斯金字塔"><br>保留所有层在卷积和下采样过程中丢失的高频信息，用于图像恢复。</p>
]]></content>
      <categories>
        <category>image</category>
      </categories>
      <tags>
        <tag>多尺度变换</tag>
      </tags>
  </entry>
  <entry>
    <title>自编码机</title>
    <url>/2020/06/23/%E8%87%AA%E7%BC%96%E7%A0%81%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81.png" alt="编码与解码"></p>
<p>左侧将原始图像编码为向量，右侧通过解卷积层“解码”，还原回原始图像。</p>
<p><em>可以用尽可能多的图像来训练网络，当保存了某张图像的编码向量，可用解码组件重建。</em></p>
<h1 id="经典自编码机VAE"><a href="#经典自编码机VAE" class="headerlink" title="经典自编码机VAE"></a>经典自编码机VAE</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE.png" alt="VAE"></p>
<p><em>通过编码向量，创造潜在向量，或实现连续、平滑的潜在空间表示。</em></p>
<p>通过给编码网络添加一个约束，使其所产生的潜在向量大体上服从单位高斯分布。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E7%BA%A6%E6%9D%9F.png" alt="VAE约束"></p>
<p>如图，只需从单位高斯分布中采样出一个潜在向量，并将其传递到解码器，就可以生成一张新的图像了。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E9%87%87%E6%A0%B7.png" alt="VAE采样"></p>
<p>基本思路：</p>
<ul>
<li>假定输入数据的数据集D的分布完全由一组隐变量z操控，并且，该组隐变量间相互独立且服从高斯分布；</li>
<li>VAE让encoder学习输入数据的隐变量模型，即学习该组隐变量的高斯概率分布的参数：隐变量高斯分布的均值$\Mu$和方差$\theta$的$log$值；</li>
<li>隐变量z通过对参数的正态分布中采样得到：$z \sim N(\Mu, \theta)$；</li>
<li>通过decoder对隐变量进行解码，重构函数。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE%E5%88%86%E5%B8%83.png" alt="VAE分布"></p>
<p>总体目标函数：<br>    $\mathcal{L}(x,\widehat{x}) + \sum_j KL(q_j(z|x)||p(z))$</p>
<p>误差：误差项精确度及潜在变量在单位高斯分布上的契合程度。</p>
<ul>
<li>生成误差，用以衡量网络重构图像精准度的均方误差；</li>
<li>潜在误差，用以衡量潜在变量在单位高斯分布上的契合程度的KL散度。</li>
</ul>
<h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h2><p><em>VAE模型并没有真正的用$z \sim N(\Mu,\theta)$来采样得到z变量：因为采样后无法对$(\Mu,\theta)$进行求导。</em></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE_Reparameterization.png" alt="VAE_Reparameterization"></p>
<p>一般先采样一个标准的高斯分布/正态分布$\epsilon \sim N(0,1)$，然后令$z=\Mu+\epsilon*\theta$，这样得到的z就服从$z \sim N(\Mu,\theta)$，同时也可正常对(\Mu,\theta)$求导。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点：遵循“编码-解码”模式，能直接将生成的图像同原始图像进行对比；</li>
<li>缺点：直接采用均方误差，导致其神经网络倾向生成较为模糊的图像。</li>
</ul>
<h1 id="VAE和GAN的区别"><a href="#VAE和GAN的区别" class="headerlink" title="VAE和GAN的区别"></a>VAE和GAN的区别</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangzongyu00/images/VAE_vs_GAN.png" alt="VAE_vs_GAN"></p>
<p>GAN是VAE后半部分再加上一个鉴别网络，导致完全不同的训练方式。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_40955254/article/details/82315224" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315224</a></li>
<li><a href="https://blog.csdn.net/weixin_40955254/article/details/82315909?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315909?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></li>
</ul>
]]></content>
  </entry>
</search>
